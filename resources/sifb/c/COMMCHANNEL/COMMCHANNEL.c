// This file is generated by FBC.
// Sets up Inter-resource Comm Channel.
// Per-resource Config file gives a mapping of LINKPubs, EventRecv and DataRecv

/*Per Tick:
	Check for LINKPUBLISHER.REQ s
	send to socket
	non-blocking recv on socket for data from other resources
*/

#include "COMMCHANNEL.h"
#include <string.h>
#include <stdio.h>

// GLOBAL


void addChannel(COMMCHANNEL* me)
{
	COMMCHANNELLinkedList *element = &commChannels;
	
	
	while( element->channel != 0 )
	{
		// get next
		if( element->next == 0 )
		{
			// new next...
			element->next = malloc(sizeof(COMMCHANNELLinkedList));
			if( element->next <= 0 )
			{
				printf("Error: malloc failed\n");
				exit(2);
			}
			// set element to next
			element = element->next;
			
			// Init Elements things to 0
			element->channel = 0;
			element->next = 0;
			break;
		}
		else
			element = element->next;
	
	}
		
	if( element->channel == 0 )
	{
		element->channel = me;
	}
	else
	{
		// ???
		printf("addChannel element->channel != 0\n");
	}
	
	
}

COMMCHANNEL* getChannel(ULINT id)
{
	COMMCHANNELLinkedList *element = &commChannels;
	
	while( element->channel != 0 )
	{
		if( element->channel->_ID == id )
			return element->channel;
		// get next
		if( element->next == 0 )
			break;
		
		element = element->next;
	}
	
	return NULL;

}

// END GLOBAL


/* COMMCHANNEL initialization function */
void COMMCHANNELinit(COMMCHANNEL* me)
{
    memset(me, 0, sizeof(COMMCHANNEL));
}


/* COMMCHANNEL execution function */
void COMMCHANNELrun(COMMCHANNEL* me)
{
    me->_output.events = 0;

   if (me->_input.event.INIT) {
		// Connect to peer
		COMMCHANNELopen(me, me->_PEERADDR);
		
		me->_SRVRQO = me->_QI;
		me->inited = true;
		me->_output.event.INITO = 1;
	}

	if( me->inited )
		COMMCHANNELsend(me);
	
	
	
	
	me->_input.events = 0;
}

void COMMCHANNELaddPublisher(COMMCHANNEL* me, char* buffer, int* buflen)
{
	// add to global list commChannels
	BufferLinkedList* element = &me->pubData;
	
	while( element->buffer != NULL ) // TODO: while buffer pointer != NULL..?
	{
		// get next
		if( element->next == 0 )
		{
			// new next...
			element->next = malloc(sizeof(BufferLinkedList));
			if( element->next <= 0 )
			{
				printf("Error: malloc failed\n");
				exit(2);
			}
			// set element to next
			element = element->next;
			// Init Elements things to 0
			element->buffer = 0;
			element->buflen = 0;
			element->next = 0;
			break;
		}
		else
			element = element->next;
	
	}
		
	if( element->buffer == 0 )
	{
		element->buffer = buffer;
		element->buflen = buflen;
	}
	else
	{
		// ???
		printf("addChannel element->buffer != 0\n");
	}
}

int COMMCHANNELopen(COMMCHANNEL* me, char* peerAddr)
{
		char *token;
		struct in_addr iaddr;
		unsigned char ttl = 1;
		unsigned char loop = 1;
		int iOptVal = 1;
		
		//IECValue RES0Z1Interface1INITPubdata[1];
		
#ifdef _MSC_VER
		WSADATA wsaData;
		int ret = WSAStartup(0x101,&wsaData); // use highest version of winsock avaliable
		if(ret != 0)
		{
			perror("ret != 0\n");
			return -1;
		}
#endif

		// My Socket
		me->myAddr.sin_family = AF_INET;
		me->myAddr.sin_port = htons(0);					// use the first free port
		me->myAddr.sin_addr.s_addr = htonl(INADDR_ANY);	// bind socket to any interface

		
		
		// Dest / server socket
		me->dstAddr.sin_family=AF_INET;
		token = strtok(peerAddr, ":");
		me->dstAddr.sin_addr.s_addr = inet_addr(token);
		token = peerAddr + strlen(token) + 1;
		me->dstAddr.sin_port = htons( (unsigned short)strtol(token, NULL, 10) );
		
		me->channelSendSock=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
		//me->channelSendSock=socket(AF_INET,SOCK_STREAM,0); 


#ifdef _MSC_VER
		if(me->channelSendSock == INVALID_SOCKET)
		{
			perror("me->channelSendSock == INVALID_SOCKET\n");
			return -1;
		}
#else
		if(me->channelSendSock < 0)
		{
			perror("me->channelSendSock < 0 (INVALID_SOCKET)\n");
			return -1;
		}
#endif		
		
		if( bind(me->channelSendSock,(struct sockaddr*)&me->myAddr,sizeof(me->myAddr)) !=0 )
		{
			perror("bind(me->channelSendSock,(sockaddr*)&me->myAddr,sizeof(me->myAddr)) !=0\n");
#ifdef _MSC_VER
		printf("WSock error: %d\n", WSAGetLastError());
#endif
			return -1;
		}
		//*/

		setNonblocking(me->channelSendSock);
		
		// Definately for WIN32
		// Untested for Unix
		setsockopt(me->channelSendSock, SOL_SOCKET, SO_BROADCAST, &iOptVal, sizeof(iOptVal) );
		

		printf("NxtCOMMCHANNEL connected to port: %s:%s.\n", peerAddr, token);

		return 0; // success
}

int COMMCHANNEL_KeepAliveMessage(COMMCHANNEL* me)
{
	int offset = 0;
	int tempV;
	
	// Version
	tempV = 2;
	
	offset = appendNxtPacketValue(me->keepAlive, offset, IEC_USINT, (void*)&tempV);
	if( offset <= 0 )
		return -1;
	
	//Source
	offset = appendNxtPacketValue(me->keepAlive, offset, IEC_STRING, (void*)sourceName);
	if( offset <= 0 )
		return -1;
	
	// Command
	tempV = 1;
	offset = appendNxtPacketValue(me->keepAlive, offset, IEC_USINT, (void*)&tempV);
	if( offset <= 0 )
		return -1;
	
	offset = appendNxtPacketValue(me->keepAlive, offset, IEC_ULINT, (void*)&me->_ID);
	if( offset <= 0 )
		return -1;

	printHex(me->keepAlive, 0, offset);

	me->keepAliveLen = offset;
	return offset;
}

void COMMCHANNELsend(COMMCHANNEL* me)
{
	// Loop through me->pubData
	BufferLinkedList* element = &me->pubData;
	struct timeval timeChange;
	struct timeval timeNow;
	unsigned long deltaTime = 0;
	int offset = 0;

	gettimeofday(&timeNow, NULL);
	timersub(&timeNow, &me->lastKeepAlive, &timeChange );

	deltaTime = timeChange.tv_sec * 1000000;
	deltaTime += timeChange.tv_usec;
	// delta time is time diff in usec
	// Alive is 5x keep alive timer in ms
	if( deltaTime > (me->_ALIVE/5)*1000 )
	{
		// Send KeepAlive if time passed
		if( me->keepAliveLen == 0 )
		{	
			printf("Sending KeepAlive every %d ms\n", me->_ALIVE/5);
		
			me->keepAliveLen = COMMCHANNEL_KeepAliveMessage(me);
		}
		//
		if ( sendto(me->channelSendSock, me->keepAlive, me->keepAliveLen, 0, (struct sockaddr*)&(me->dstAddr), sizeof(me->dstAddr)) < 0 )// TODO: flags == 0?
		{
			printf("COMMCHANNEL: KA Error sending data through socket.");
			#ifdef _MSC_VER
					printf("WSock error: %d\n", WSAGetLastError());
			#endif
		}
		//*/
		// Set last 'time'
		me->lastKeepAlive.tv_sec = timeNow.tv_sec;
		me->lastKeepAlive.tv_usec = timeNow.tv_usec;
	}
	//else
	//	printf("Delta time = %ld\n", deltaTime);


	
	   
	
	while( element->buffer != NULL )
	{
		// get next
		if( (*element->buflen) > 0 )
		{
			// send
			#ifdef DEBUG
				printf("Sending a buffer\n");
				printf("%s\n", element->buffer);
			#endif
			if ( sendto(me->channelSendSock, element->buffer, (*element->buflen), 0, (struct sockaddr*)&(me->dstAddr), sizeof(me->dstAddr)) < 0 )// TODO: flags == 0?
			{
				printf("COMMCHANNEL: LinkPub Error sending data through socket.");
				#ifdef _MSC_VER
						printf("WSock error: %d\n", WSAGetLastError());
				#endif
			}

			// clear buffer
			(*element->buflen) = 0; 
		}
		
		if( element->next == 0 )
		{
			break;
		}
		element = element->next;
	
	}
}
