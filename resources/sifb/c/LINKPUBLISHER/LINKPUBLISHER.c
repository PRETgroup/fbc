// This file is generated by FBC.
// Sets up Inter-resource Comm Channel.
// Per-resource Config file gives a mapping of LINKPubs, EventRecv and DataRecv

/*Per Tick:
	Check for LINKPUBLISHER.REQ s
	send to socket
	non-blocking recv on socket for data from other resources
*/

#include "LINKPUBLISHER@unique@.h"
#include <string.h>
#include <stdio.h>

// TODO: Rename
#include "NxtCommunication.h"

/* LINKPUBLISHER@unique@ initialization function */
void LINKPUBLISHER@unique@init(LINKPUBLISHER@unique@* me)
{
    memset(me, 0, sizeof(LINKPUBLISHER@unique@));
}

// Static
void LINKPUBLISHER@unique@_ConnectChannel(LINKPUBLISHER@unique@* me)
{
	me->channelHost = getChannel(me->_CHANID);
	if( me->channelHost == NULL )
		me->_QO = false;
	else
	{
		me->_QO = true;

		COMMCHANNELaddPublisher(me->channelHost, me->buffer, &me->bufLen);
	}

}

/* LINKPUBLISHER@unique@ execution function */
void LINKPUBLISHER@unique@run(LINKPUBLISHER@unique@* me)
{
	int offset = 0 ;
	if( me->bufLen > 0 )
	{
		printf("Buf len was allowed to stay > 0 (%d)\n", me->bufLen);
	}

    me->_output.events = 0;

    if (me->_input.event.INIT) {
		LINKPUBLISHER@unique@_ConnectChannel(me);
		me->_output.event.INITO = 1;
		
	}
	if(me->_input.event.REQ)
	{
		offset = LINKPUBLISHER@unique@packdata(me);
		if( offset <= 0 )
			return; // some error
		me->bufLen = offset;
		printHex(me->buffer, 0, me->bufLen);

	}

	me->_input.events = 0;
}


/*****************************************************************************
 The rest needs to be custom / block :|
*****************************************************************************/

int LINKPUBLISHER@unique@packdata(LINKPUBLISHER@unique@* me)
{
    int offset = 0;
    unsigned int tempV = 0;
    int di = 0;
	// Version
	tempV = 2;
	offset = appendNxtPacketValue(me->buffer, offset, IEC_USINT, (void*)&tempV);
	if( offset <= 0 )
		return -1;
		
	//Source
	offset = appendNxtPacketValue(me->buffer, offset, IEC_STRING, (void*)sourceName);
	if( offset <= 0 )
		return -1;
		
	//Command Type
	@begin_varlist#CommandType@
	tempV = @var@;
	@end_varlist@
	offset = appendNxtPacketValue(me->buffer, offset, IEC_USINT, (void*)&tempV);
	if( offset <= 0 )
		return -1;

	offset = appendNxtPacketValue(me->buffer, offset, IEC_ULINT, (void*)&me->_CHANID);
	if( offset <= 0 )
		return -1;

    offset = appendNxtPacketValue(me->buffer, offset, IEC_ULINT, (void*)&me->_EVENTWIREID);
    if( offset <= 0 )
        return -1;

    // Reserved
	tempV = 0x00;
    offset = appendNxtPacketValue(me->buffer, offset, IEC_UDINT, (void*)&tempV);
    if( offset <= 0 )
        return -1;

    // VARIABLE
	@begin_varlist#SD_@
        // Data wire id
        offset = appendNxtPacketValue(me->buffer, offset, IEC_ULINT, (void*)&me->_DATAWIREIDS[@v#-1@]); // SD_1 => _DATAWIREIDS[0]
        if( offset <= 0 )
            return -1;

        // Value
        offset = appendNxtPacketValue(me->buffer, offset, IEC_@type@, (void*)&me->_@var@);
        if( offset <= 0 )
            return -1;
	@end_varlist@
    // END VARIABLE
	
    return offset;
}