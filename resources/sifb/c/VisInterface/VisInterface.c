// This file is generated by FBC.

#include "VisInterface.h"
#include <stdio.h> // printf
#include <string.h>


#include <assert.h>

#ifdef _MSC_VER
#include <Winsock2.h>
#include <Ws2tcpip.h>
#else

#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#endif

/* VisInterface initialization function */
void VisInterfaceinit(VisInterface* me)
{
    memset(me, 0, sizeof(VisInterface));
}

void VisInterfacesendPublisher(VisInterface* me)
{
	Publisher* pub = &me->publish;
	size_t size = 0;
	
	assert((size + sizeof(short)) <= UDPBUFSIZE);
	memmove(pub->buffer + size, &me->_BagCount, sizeof(short));
	size += sizeof(short);
	
	if( me->_BagCount > 0 )
	{
		assert((size + (sizeof(short)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagIDData, sizeof(short)*me->_BagCount);
		size += sizeof(short)*me->_BagCount;
		
		assert((size + (sizeof(int)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagXPosData, sizeof(int)*me->_BagCount);
		size += sizeof(int)*me->_BagCount;
		
		assert((size + (sizeof(int)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagYPosData, sizeof(int)*me->_BagCount);
		size += sizeof(int)*me->_BagCount;
		
		assert((size + (sizeof(short)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagAngleData, sizeof(short)*me->_BagCount);
		size += sizeof(short)*me->_BagCount;
		
		assert((size + (sizeof(short)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagLengthData, sizeof(short)*me->_BagCount);
		size += sizeof(short)*me->_BagCount;
		
		assert((size + (sizeof(short)*me->_BagCount) ) <= UDPBUFSIZE);
		memmove(pub->buffer + size, &me->_BagWidthData, sizeof(short)*me->_BagCount);
		size += sizeof(short)*me->_BagCount;
	}
	
	assert((size + (sizeof(bool)*6) ) <= UDPBUFSIZE);
	memmove(pub->buffer + size, &me->_PEDetects, sizeof(bool)*6);
	size += sizeof(bool)*6;
	
	assert((size + (sizeof(short)*6) ) <= UDPBUFSIZE);
	memmove(pub->buffer + size, &me->_PEStatus, sizeof(short)*6);
	size += sizeof(short)*6;
	
	assert((size + (sizeof(short)) ) <= UDPBUFSIZE);
	memmove(pub->buffer + size, &me->_ConvStatus, sizeof(short));
	size += sizeof(short);
	
	assert((size + (sizeof(short)) ) <= UDPBUFSIZE);
	memmove(pub->buffer + size, &me->_ConvExtraStatus, sizeof(short));
	size += sizeof(short);
	
	if ( sendto(pub->sockfd, pub->buffer, size, 0, (struct sockaddr*)&(pub->dstAddr), 
				sizeof(pub->dstAddr)) < 0 ) {
		perror("Publ: Error sending data through socket.");
#ifdef _MSC_VER
		printf("WSAGetLastError: %d\n", WSAGetLastError());
#endif
	}

	
}

/* VisInterface execution function */
void VisInterfacerun(VisInterface* me)
{
	me->_output.events = 0;

	if (me->_input.event.INIT) {
		if (me->_QI) {
			openPublisher(&me->publish, 1, me->_PubTo);
			me->_QO = true;
			strncpy(me->_STATUS, "OK", MAX_STATUS_LEN);
			me->_output.event.INITO = 1;
		}
		else {
			closePublisher(&me->publish);
			me->_QO = false;
			strncpy(me->_STATUS, "", MAX_STATUS_LEN);
			me->_output.event.INITO = 1;
		}
	}
	else if (me->_input.event.REQ) {
		if (me->_QI) {
			VisInterfacesendPublisher(me);
			me->_QO = true;
			strncpy(me->_STATUS, "OK", MAX_STATUS_LEN);
			me->_output.event.CNF = 1;
		}
		else {
			me->_QO = false;
			strncpy(me->_STATUS, "INHIBITED", MAX_STATUS_LEN);
			me->_output.event.CNF = 1;
		}
	}
		
	me->_input.events = 0;
}
