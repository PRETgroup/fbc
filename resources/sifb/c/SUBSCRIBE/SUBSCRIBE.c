// This file is generated by FBC.

#include "SUBSCRIBE@postfix@.h"
#include <string.h>

#include <assert.h>

#ifdef _MSC_VER
#include <Winsock2.h>
#include <Ws2tcpip.h>
#else

#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#endif

/* SUBSCRIBE@postfix@ initialization function */
void SUBSCRIBE@postfix@init(SUBSCRIBE@postfix@* me)
{
	memset(me, 0, sizeof(SUBSCRIBE@postfix@));
#if @queue@ > 0
	me->_head = 0;
	me->_tail = 0;
#endif
}

bool SUBSCRIBE@postfix@receiveSubscriber(SUBSCRIBE@postfix@* me)
{
	struct sockaddr_in publaddr;
	socklen_t socklen = sizeof(publaddr);
	Subscriber* sub = &me->subscribe;
	bool rx = false;
	int len;
	int size = 0;
		
	while ( (len = recvfrom(sub->sockfd, sub->buffer, UDPBUFSIZE, 0,
			(struct sockaddr*)&publaddr, &socklen)) >= 0 ) {
		//printf("Received from: %s:%d\n", inet_ntoa(publaddr.sin_addr), ntohs(publaddr.sin_port));
		rx = true;
		size = 0;
		
#if @queue@ > 0
		if (me->_qlen >= @queue@) { // queue full
			me->_head += 1;
			if (me->_head >= @queue@)
				me->_head = 0;
		}
		else
			(me->_qlen)++;

		@begin_varlist#RD_@
		assert((size + sizeof(me->_q_@var@[me->_tail])) <= UDPBUFSIZE);
		memmove(&me->_q_@var@[me->_tail], sub->buffer + size, sizeof(me->_q_@var@[me->_tail]) );
		size += sizeof(me->_q_@var@[me->_tail]);
		if (size >= len)
				break;
		@end_varlist@

		me->_tail += 1;
		if (me->_tail >= @index@)
			me->_tail = 0;
#else
	@begin_varlist#RD_@
	assert((size + sizeof(me->_@var@)) <= UDPBUFSIZE);
	memmove(&me->_@var@, sub->buffer + size, sizeof(me->_@var@) );
	size += sizeof(me->_@var@);
	if (size >= len)
		break;
	@end_varlist@

#endif

	}

	return rx;
}
	
/* SUBSCRIBE@postfix@ execution function */
void SUBSCRIBE@postfix@run(SUBSCRIBE@postfix@* me)
{
	me->_output.events = 0;

	if (me->_input.event.INIT) {
		me->QI = me->_QI;
		strncpy(me->ID, me->_ID, MAX_ID_LEN);
	}
	if (me->_input.event.RSP) {
		me->QI = me->_QI;
	}
	
	if (!me->_entered) {
		me->_entered = true;
	}
	else {
		if (me->_input.event.INIT) {
			if (me->QI) {
				openSubscriber(&me->subscribe, me->ID);
				me->QO = true;
				strncpy(me->STATUS, "OK", MAX_STATUS_LEN);
				me->_output.event.INITO = 1;
			}
			else {
				closeSubscriber(&me->subscribe);
				me->QO = false;
				strncpy(me->STATUS, "", MAX_STATUS_LEN);
				me->_output.event.INITO = 1;
			}
		}
		else {
#if @queue@ > 0
			SUBSCRIBE@postfix@receiveSubscriber(me);
			if (me->_qlen) {
#else
			if( SUBSCRIBE@postfix@receiveSubscriber(me) ) {
#endif
				me->QO = true;
				strncpy(me->STATUS, "OK", MAX_STATUS_LEN);
				me->_output.event.IND = 1;
			}
		}
	}
	me->_input.events = 0;
	
	if (me->_output.event.INITO) {
		me->_QO = me->QO;
		strncpy(me->_STATUS, me->STATUS, MAX_STATUS_LEN);
	}
	if (me->_output.event.IND) {
		me->_QO = me->QO;
		strncpy(me->_STATUS, me->STATUS, MAX_STATUS_LEN);
#if @index@ > 0
#if @queue@ > 0 // Vars & Queue
		@begin_varlist#RD_@
		me->_@var@ = me->_q_@var@[me->_head];
		@end_varlist@
		
		me->_head += 1; //
		if (me->_head >= @queue@)
			me->_head = 0;
#endif
#endif

#if @queue@ > 0 // Queue
		me->_qlen--;
#endif
		
	}
}
