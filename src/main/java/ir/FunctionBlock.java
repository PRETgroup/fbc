/* FunctionBlock.java
 * Defines the Function Block class for C code generation.
 *
 * Written by: Li Hsien Yoong
 */

package ir;

import java.io.*;
import java.util.*;

import fb.*;
import fbtostrl.*;

public class FunctionBlock {	
	// Set of all created function blocks
	static public HashSet<FunctionBlock> fbs = new HashSet<FunctionBlock>();
	public static NameDB globalNames = new NameDB(null);	// name repository for function
													// blocks, algorithms and types
	static HashSet<String> hostTypes = new HashSet<String>();
	
	public NameDB ieNames;	// name repository for input events
	NameDB oeNames;			// name repository for output events
	NameDB idNames;			// name repository for input data
	NameDB odNames;			// name repository for output data
	public NameDB sigNames;	// name repository for local signals
	public NameDB varNames;	// name repository for internal variables

	String compiledType;
	String fbType;
	private boolean uniqueFB;	// true whenever an FB instance has a unique FunctionBlock 
								// object associated to it 
	String fqinstanceName;
	String comment;
	String[] headers;
	InterfaceList iface;
	public Event[] inputEvents;
	public Event[] outputEvents;
	public VarType[] inputData;
	// Kyle: public MethodReference[] methodReferences;
	public VarType[] outputData;
	Parameter[] parameters;

	// For Basic function blocks only:
	BasicFB basicFB;
	VarType[] internalVars;
	Procedure[] procedures;
	SyncState[] syncStates;
	
	HashMap<String,SyncState[]> hceccSyncStates; // ECC name, syncstates for ECC
	SyncState rootState;	// root of synchronous state

	// For Composite function blocks only:
	public Composite compositeFB;
	String[] inheritedResumes;	// Resume inputs generated by sub-blocks
	
	// For Service Interface function blocks only:
	SIPath sifbInfo;			// information on the referenced SIFB
	
	// For PretC blocks Only
	PretC pretC;
	
	public FunctionBlock(FBType fbt, Options o, String fullInstName, 
			Parameter[] params, String targetType) {
		parameters = params;
		if (targetType == null)
			fbType = fbt.getName();
		else {
			fbType = targetType;
			fbt.setTargetType(targetType);
		}
		fbt.params = params;
		
		if (FBType.getGlobalVarType(fbType) != null)
			uniqueFB = true;
		if ( fbt.needsUnique()) {
			if ( fbt.isSIFB() ) {
				//URL sifbURL = FBtoStrl.class.getResource("/ir");
				String plainPath = "./";//sifbURL.toString();
				if (plainPath.startsWith("file:"))
					plainPath = plainPath.substring(5);
				File path = new File(plainPath);
				// Use the native fb type, not the compiled type
				sifbInfo = new SIPath(path, fbType, o, true, params);
				fbt.setSIFBindex(sifbInfo.getIndex());
				fbt.setSIFBname(sifbInfo.getBlockName());
				fbt.setSIFBQlen(sifbInfo.getQLen());
				compiledType = fbType + sifbInfo.getUniquePostfix();
			}else
				compiledType = fbType + "_" + Integer.toString(SIPath.getUniqueCount());
			
			uniqueFB = true;
		}
		else if (o.pretc) {
			compiledType = fbType + "_" + fullInstName.replaceAll("\\Q.\\E", "_") + Integer.toString(SIPath.getUniqueCount()); //fix . in name due to ancestor having dot when getting parent name in FBtoStrl makeFBNetwork function
			uniqueFB = true;
			
		}
		
		else if ( fbt.isPretC() && fullInstName.length() > 0 ) {
			String fileSafeName = fullInstName.replaceAll("[\\.]", "_");
			compiledType = fileSafeName + "_" + fbType;
		}
		else
			compiledType = fbType;
		
		// NOTE: Update toplevel file name (used in run / sim) to be the unique/compileType name
		if( FBtoStrl.topLevelFile.equalsIgnoreCase(fbType) )
			FBtoStrl.topLevelFile = compiledType;
		
		fqinstanceName = fullInstName;
		if (globalNames.contains(compiledType)) {
			
			if( !fbt.isSIFB() ) // Gareth: Allow duplication of underlying fbt for (possibly) dynamic SIFBs.
			{
				// Name and interface stuff will have already been checked when original fbt was added...
				OutputManager.printError(compiledType, "Multiple definitions of block type: `" +
						compiledType + "\'.", OutputLevel.FATAL);
				System.exit(0);
			}
		}
		else {
			globalNames.add(compiledType);
		}
		comment = fbt.getComment();
		headers = fbt.getHeaders();
		iface = fbt.getInterfaceList();
				
		ieNames = new NameDB(globalNames);
		oeNames = new NameDB(globalNames);
		idNames = new NameDB(globalNames);
		odNames = new NameDB(globalNames);
		sigNames = new NameDB(globalNames);
		varNames = new NameDB(globalNames);
		
		// Module names and host declarations are visible to the whole application.
		// Therefore, they must be unique to all other names.
		NameDB[] nameDBs = {ieNames, oeNames, idNames, odNames, sigNames, varNames};
		globalNames.addCommonDB(nameDBs);
		
		// Signals should be unique with respect to each other and the global names
		//nameDBs[0] = globalNames;	// modAlg, oe, id, od, sig
		for (int i = 1; i < 5; i++)
			ieNames.addCommonDB(nameDBs[i]);
		nameDBs[1] = ieNames;		// modAlg, ie, id, od, sig
		for (int i = 1; i < 5; i++)
			oeNames.addCommonDB(nameDBs[i]);
		nameDBs[2] = oeNames;		// modAlg, ie, oe, od, sig
		for (int i = 1; i < 5; i++)
			idNames.addCommonDB(nameDBs[i]);
		nameDBs[3] = idNames;		// modAlg, ie, oe, id, sig
		for (int i = 1; i < 5; i++)
			odNames.addCommonDB(nameDBs[i]);
		nameDBs[4] = odNames; 		// modAlg, ie, oe, id, od
		for (int i = 1; i < 5; i++)
			sigNames.addCommonDB(nameDBs[i]);
		
		// Vars should be unique with respect to each other and the global names
		// varNames.addCommonDB(globalNames);
				
		if (iface != null) {
			// Verify uniqueness of input events
			inputEvents = iface.eventInputs;
			if (inputEvents != null) {
				for (int i = 0; i < inputEvents.length; i++) {
					String eventName = inputEvents[i].getName();
					if (ieNames.contains(eventName)) {
						OutputManager.printError(compiledType, "Multiple definitions of input event `" +
						           eventName + "\' in " + compiledType + ".", OutputLevel.FATAL);
						System.exit(0);
					}
					else
						ieNames.add(eventName);
				}
			}

			// Verify uniqueness of output events
			outputEvents = iface.eventOutputs;
			if (outputEvents != null) {
				for (int i = 0; i < outputEvents.length; i++) {
					String eventName = outputEvents[i].getName();
					if (oeNames.contains(eventName)) {
						OutputManager.printError(compiledType, "Multiple definitions of output event `" +
						           eventName + "\' in " + compiledType + ".", OutputLevel.FATAL);
						System.exit(0);
					}
					else
						oeNames.add(eventName);
				}
			}

			// Verify uniqueness of input data
			if (iface.inputVars != null) {
				inputData = new VarType[iface.inputVars.length];
				for (int i = 0; i < inputData.length; i++) {
					inputData[i] = new VarType(Category.IFACE_IN, iface.inputVars[i], 
							                   hostTypes);
					String varName = inputData[i].getName();
					if (idNames.contains(varName)) {
						OutputManager.printError(compiledType, "Multiple definitions of input data `" +
								varName + "\' in " + compiledType + ".", OutputLevel.FATAL);
						System.exit(0);
					}
					else
						idNames.add(varName);
				}
			}
			
			/* Kyle:
			// Acquire method references
			if (iface.methodReferences != null) {
				methodReferences = new MethodReference[iface.methodReferences.length];
				for (int i = 0; i < methodReferences.length; i++) {
					methodReferences[i] = new MethodReference(iface.methodReferences[i].getName(), 
							iface.methodReferences[i].getComment());
				}
			}
			*/

			// Verify uniqueness of output data
			if (iface.outputVars != null) {
				outputData = new VarType[iface.outputVars.length];
				for (int i = 0; i < outputData.length; i++) {
					outputData[i] = new VarType(Category.IFACE_OUT, iface.outputVars[i], 
							                    hostTypes);
					String varName = outputData[i].getName();
					if (odNames.contains(varName)) {
						OutputManager.printError(compiledType, "Multiple definitions of output data `" +
								varName + "\' in " + compiledType + ".", OutputLevel.FATAL);
						System.exit(0);
					}
					else
						odNames.add(varName);
				}
			}
		}

		if (fbt.getFBNetwork() != null) {
			compositeFB = new Composite(fbt, fqinstanceName);			
		}
		else if ( (basicFB = fbt.getBasicFB()) != null ) {
			// Verify uniqueness of internal variables
			VarDeclaration[] vars = basicFB.internalVars;
			if (vars != null) {
				internalVars = new VarType[vars.length];
				for (int i = 0; i < internalVars.length; i++) {
					internalVars[i] = new VarType(Category.INTERNAL, vars[i], hostTypes);
					String varName = internalVars[i].getName();
					if ( varNames.contains(varName) ) {
						OutputManager.printError(compiledType, "Multiple definitions of internal variable `" +
						           varName + "\'.", OutputLevel.FATAL);
						System.exit(0);
					}
					else
						varNames.add(varName);
				}
			}

			// Verify uniqueness of algorithm names
			Algorithm[] algorithms = basicFB.algorithms;
			if (algorithms != null) {
				procedures = new Procedure[algorithms.length];
				for (int i = 0; i < algorithms.length; i++) {
					procedures[i] = new Procedure(algorithms[i], inputData,
							                      outputData, internalVars, compiledType);
					String procName = procedures[i].getFullName();
					if (globalNames.contains(procName)) {
						OutputManager.printError(compiledType, "Multiple definitions of `" +
								procName + "\'.", OutputLevel.FATAL);
						System.exit(0);
					}
					else {
						globalNames.add(procName);
					}
				}
			}
		
			// Map ECStates to synchronous states
			syncStates = getSyncStates();
			rootState = syncStates[0];
		}
		else if( fbt.isSIFB() && fbt.name.endsWith("_HMI") )
		{
			// pass
		}
		else if( fbt.isPretC() )
		{
			pretC = fbt.getPretC();
			
		}
		else if( fbt instanceof AdapterType )
		{
			// Process adapter... which is just an interface
		}
		// Also handled at top of this function now (if uniqueID)
		else if ( !fbt.needsUnique() && (fbt.isSIFB() || basicFB == null) ) {
			//URL sifbURL = FBtoStrl.class.getResource("/ir");
			String plainPath = "./";//sifbURL.toString();
			if (plainPath.startsWith("file:"))
				plainPath = plainPath.substring(5);
			File path = new File(plainPath);
			// Use the native fb type, not the compiled type
			sifbInfo = new SIPath(path, fbType, o, false, params);
			fbt.setSIFBindex(sifbInfo.getIndex());
			fbt.setSIFBname(sifbInfo.getBlockName());
			fbt.setSIFBQlen(sifbInfo.getQLen());
		}
		fbs.add(this);
	}
	
	private SyncState[] getSyncStates() {
		if( basicFB instanceof BasicHCECCFB )
		{
			hceccSyncStates = new HashMap<String,SyncState[]>();
			HCECC hcecc = ((BasicHCECCFB)basicFB).hcecc;
			//String rootName = hceccFB.getECCRoot().name; // THIS 1st the root ECC... so find root state....
			syncStates = getSyncStates(this, hcecc.name, hcecc.states);
			hceccSyncStates.put(hcecc.name, syncStates);
			rootState = syncStates[0];

			if( rootState == null )
			{
				OutputManager.printError(compiledType, "Root state not found in HCECC.", OutputLevel.FATAL);
				System.exit(-1);
			}

			
			if( hcecc.eccs.length > 1 )
			{
				rootState.parallel = new LinkedHashMap<String,SyncState[]>();
				for(int e = 1; e < hcecc.eccs.length; e++)
				{
					ECC ecc = hcecc.eccs[e];
					SyncState[] sStates = getSyncStates(this, ecc.name, ecc.states);	
					rootState.parallel.put(ecc.name, sStates);
					hceccSyncStates.put(ecc.name, sStates);
				}
			}
			
			
			return syncStates;
		}
		else
		{
			return getSyncStates(this, basicFB.getECCRoot().name, basicFB.getAllECStates());
		}
		
		
	}

	public String getBaseType() {
		return fbType;
	}
	
	final public String getCompiledType() {
		return compiledType;
	}
	
	public String getComment() {
		return comment;
	}
	
	public BasicFB getBasicFB() {
		return basicFB;
	}
	
	public Composite getCompositeFB() {
		return compositeFB;
	}
	
	public HashSet<String> getHostTypes() {
		return hostTypes; 
	}
	
	public InterfaceList getInterfaceList() {
		return iface;
	}
	
	public String getFQInstName() {
		return fqinstanceName;
	}
	
	/* Returns the set containing the names of all input/output ports for the 
	 * given subblock, "subname" 
	 */
	public HashSet<String> getSubBlockIOSet(String subname) {
		HashSet<String> io = new HashSet<String>();
		Iterator<FunctionBlock> i = fbs.iterator();
		while (i.hasNext()) {
			FunctionBlock fb = i.next();
			if (fb.compiledType.equals(subname)) {
				if (fb.inputEvents != null) {
					for (int j = 0; j < fb.inputEvents.length; j++) {
						io.add(fb.inputEvents[j].getName());
					}
				}
				if (fb.outputEvents != null) {
					for (int j = 0; j < fb.outputEvents.length; j++) {
						io.add(fb.outputEvents[j].getName());
					}
				}
				if (fb.inputData != null) {
					for (int j = 0; j < fb.inputData.length; j++) {
						io.add(fb.inputData[j].getName());
					}
				}
				if (fb.outputData != null) {
					for (int j = 0; j < fb.outputData.length; j++) {
						io.add(fb.outputData[j].getName());
					}
				}
				return io;
			}
		}
		return null;
	}
	
	/* Returns the set containing all input/output ports for the given subblock, 
	 * "subname" 
	 */
	public HashSet<PortName> getSubBlockPortSet(String subname) {
		HashSet<PortName> io = new HashSet<PortName>();
		Iterator<FunctionBlock> i = fbs.iterator();
		while (i.hasNext()) {
			FunctionBlock fb = i.next();
			if (fb.compiledType.equals(subname)) {
				if (fb.inputEvents != null) {
					for (int j = 0; j < fb.inputEvents.length; j++) {
						io.add(new PortName("", "", fb.inputEvents[j].getName(), null, ""));
					}
				}
				if (fb.outputEvents != null) {
					for (int j = 0; j < fb.outputEvents.length; j++) {
						io.add(new PortName("", "", fb.outputEvents[j].getName(), null, ""));
					}
				}
				if (fb.inputData != null) {
					for (int j = 0; j < fb.inputData.length; j++) {
						io.add(new PortName("", "", fb.inputData[j].getName(), 
							   fb.inputData[j].getType(), ""));
					}
				}
				if (fb.outputData != null) {
					for (int j = 0; j < fb.outputData.length; j++) {
						io.add(new PortName("", "", fb.outputData[j].getName(), 
							   fb.outputData[j].getType(), ""));
					}
				}
				return io;
			}
		}
		return null;
	}
	
	private static SyncState[] getSyncStates(FunctionBlock m, String eccName, ECState[] states ) {
		//SyncState rootState = null; // SHOULD be 1st state
		SyncState[] sstates = null;
		if (states != null) {
			sstates = new SyncState[states.length];
			for (int i = 0; i < states.length; i++)
			{
				sstates[i] = new SyncState(m, states[i]);
				sstates[i].index = i;
				
				if( states[i].hcecc != null ) // Refined
				{
					HCECC refiningHCECC = states[i].hcecc; 
					sstates[i].refiningECCName = refiningHCECC.name;
					sstates[i].refiningStates = getSyncStates(m, refiningHCECC.name, refiningHCECC.states);
					if( refiningHCECC.eccs.length > 1  ) // Refined has parallel
					{
						sstates[i].parallel = new LinkedHashMap<String,SyncState[]>();
						for(int pECC = 1; pECC < refiningHCECC.eccs.length; pECC++ )
						{
							ECC parallelECC = refiningHCECC.eccs[pECC];
							sstates[i].parallel.put(parallelECC.name, getSyncStates(m, parallelECC.name, parallelECC.states));
						}
					}
				}
			}

			for (int i = 0; i < states.length; i++) {
				ECState[] children = states[i].children;
				if (children != null) {
					sstates[i].children = new SyncState[children.length];
					for (int j = 0; j < children.length; j++) {
						if (children[j] == null) 
						{
							OutputManager.printError(m.compiledType, "Broken State Child " + j, OutputLevel.FATAL);
							System.exit(0);							
						}
						for (int k = 0; k < sstates.length; k++) {
							if( sstates[k] == null )
							{
								OutputManager.printError(m.compiledType, "Broken SyncState " + k, OutputLevel.FATAL);
								System.exit(0);
							}
							if ( children[j].getName().equals(sstates[k].name) ) {
								sstates[i].children[j] = sstates[k];
								break;
							}
						}
					}
				}
				
				ECState[] parents = states[i].parents;
				if (parents != null) {
					sstates[i].parents = new SyncState[parents.length];
					for (int j = 0; j < parents.length; j++) {
						for (int k = 0; k < sstates.length; k++) {
							if ( parents[j].getName().equals(sstates[k].name) ) {
								sstates[i].parents[j] = sstates[k];
								break;
							}
						}
					}
				}
				
				sstates[i].parseConditions();
				//if ( sstates[i].name.equals(rootName) )
				//	rootState = sstates[i];
			}
			
		}
		return sstates;
	}
	
	public int getNumOfECStates() {
		if (syncStates != null) 
			return syncStates.length;
		return 0;
	}
	
	public boolean isSIFB()
	{
		return sifbInfo != null;
	}
	
	public boolean isPretC()
	{
		return pretC != null;
	}
	
	public String getPretCCode()
	{
		return pretC.code;
	}
	
	// Mostly to help debugging
	
	public String toString()
	{
		return compiledType + " : " + fqinstanceName;
	}

	public boolean isUnique() {
		return uniqueFB;
	}
	
	public static FunctionBlock getFunctionBlock(FBInstance fbi, String fqName)
	{
		
		Iterator<FunctionBlock> i = FunctionBlock.fbs.iterator();

		while (i.hasNext()) {
			FunctionBlock fb = i.next();
			if ( (fb.isUnique() && fb.fqinstanceName.equals(fqName)) || 
				 (!fb.isUnique() && fb.fbType.equals(fbi.type)) ) {
				return fb;
			}
		}
		return null;
	}
	
	void resolveAny(String varName, String varType) {
		for (VarType var : inputData) {
			if (var.getName().equals(varName)) {
				if (var.getType().equalsIgnoreCase("ANY"))
					var.setType(varType);
				return;
			}
		}
		
		for (VarType var : outputData) {
			if (var.getName().equals(varName)) {
				if (var.getType().equalsIgnoreCase("ANY"))
					var.setType(varType);
				return;
			}
		}
	}
}
