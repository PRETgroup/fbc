/* CGenerator.java
 * C code generator
 *
 * Written by: Li Hsien Yoong
 */

package pretc;

import java.io.*;
import java.util.*;
import java.util.Map.Entry;

import ccode.CProgGenerator;
import ccode.LocalComInfo;
import ccode.Variables;

import sttranslate.STtoC;

import fbtostrl.*;
import fb.*;
import ir.*;

public class PRETCGenerator extends CodeGenerator {
	public static boolean STFunctionsUsed;
	private static final int INTSIZE = 32;
	private int ieArrayLen;
	private int oeArrayLen;
	private CodePrinter cprinter;
	private CodePrinter rprinter;
	private CodePrinter sprinter;
	private String filetype;
	private Block[] sortedNodes;
	private String statePrefix = "";	// prefix for ECC name.. required for HCECCs :|
	private String currentFbName = "";
	private boolean skipSampleInput = false;
	private boolean skipSampleOutput = false;
	
	// Constants to control printing of input assignments for delayed/non-delayed connections
	private static enum DelayType {
		DELAYALL,	// used when compiling without --sorted
		DELAYONLY, 	// used for the case where only delayed connections are considered 
		DELAYNONE	// used for the case where non-delayed connections are considered
	}

	public PRETCGenerator(FunctionBlock f, Options o, LinkedList<String> files,
			String n, String pn, LinkedList<CodeGenerator> cgs, Block[] nodes) {
		super(f, o, files, n, pn, cgs);
		if (opts.isCpp())
			filetype = ".cpp";
		else
			filetype = ".c";
		sortedNodes = nodes;
		
		ieArrayLen = (getNumOfIEvents() + INTSIZE - 1) / INTSIZE;
		if (outputEvents != null)
			oeArrayLen = (outputEvents.length + INTSIZE - 1) / INTSIZE;
		
		// Infer that this is a resource if interface is non-existent.
		// -- Parameters are like input data, so we don't check it.

		
	}

	/**
	 * DESCRIPTION: Generates code for this module
	 * 
	 * @param fileName - base name of the output file(s) produced
	 * @param top - true if this is the top-level file, otherwise false
	 * @param comBlocks - set of local communication blocks
	 * @return Null if code was generated; otherwise, the code generator itself
	 */
	static boolean firstFB = true;
	public PRETCGenerator generateCode(String fileName, boolean top,
			HashSet<Block> comBlocks) throws IOException {
		fileName = getParentName(fileName) + fb.getCompiledType();
		if (sifbInfo != null) {
			retrieveSIFB(fileName);
			if (top && (opts.isRunnable())) {
				OutputManager.printError(fb.getBaseType(),
						"Using an SIFB as the only file for Run or Simulation is not supported.",
						OutputLevel.ERROR);
			}
			return null;
		} 
		else {
			
			//String cname = fileName + filetype;
			//getParentName(fileName) is path
			String hname = getParentName(fileName)+FBtoStrl.inputFileName+".h";
			String header = getFileName(hname);
			String cname = getParentName(fileName)+FBtoStrl.inputFileName+".c";
			System.out.println(cname); 
			if (firstFB) {
				
				printer = new CodePrinter(hname);
				fileNames.add(hname);
		
				cprinter = new CodePrinter(cname);
				
				cprinter.print("#include <string.h>");
				cprinter.print("#include <stdlib.h>");
				cprinter.print("#include <stdio.h>", 1);
				cprinter.print("#include \"fbtypes.h\"");
				cprinter.print("#include \"" + header + "\"");
				fileNames.add(cname);
				firstFB = false;
			}else{
				printer = new CodePrinter(hname,true);
				cprinter = new CodePrinter(cname,true);
			}
			sprinter = new CodePrinter();
			sprinter.writeToBuf();
			

			if (top) {
				if (opts.isRunnable()) {
					//cname = fileName + "run" + filetype;
					//rprinter = new CodePrinter(cname);
					if (firstFB) {
						rprinter = new CodePrinter(cname);
						firstFB = false;
					}else{
						rprinter = new CodePrinter(cname,true);
					}
					//fileNames.add(cname);
				}
			}

			// String simDef = "";
			String def = makeHeaderMacro(header+"_"+fb.getCompiledType());
			printer.print("// This file is generated by FBC.", 1);
			printer.print("#ifndef " + def);
			printer.print("#define " + def, 1);
			/* printer.print("#include <stdbool.h>");
			 * Moved to 'custom' bool typedef in fbtypes (because Windows doesn't have it)
			 */
			//printer.print("#include \"fbtypes.h\"");

			
			cprinter.print("// This file is generated by FBC.", 1);
			//cprinter.print("#include \"" + header + "\"");
			if (FBtoStrl.currentDeviceType.equals(Device.TYPE_PTARM)==false) {			
				//cprinter.print("#include <string.h>");
				// cprinter.print("#include <wchar.h>");
				//cprinter.print("#include <stdio.h>", 1);
			}
			
			if (headers != null) {
				for (String head : headers) {
					if ( (head.startsWith("\"") && head.endsWith("\"")) ||
						 (head.startsWith("<") && head.endsWith(">")) ) {
						printer.print("#include " + CodeGenerator.escapeFilePaths(head));
					}
					else {
						File file = new File(head);
						//absolute
						if (file.isAbsolute()) {
							String parent = file.getParent();
							if (parent != null)
								includePaths.add(parent);
							String child = file.getName();
							if ( !child.isEmpty() ) {
								printer.print("#include \"" + 
										CodeGenerator.escapeFilePaths(child) + "\"");
							}
						}//source relative
						else if(head.startsWith("..")) {
							printer.print("#include \"" + 
									CodeGenerator.escapeFilePaths(head) + "\"");
						}//complete relative
						else {
							printer.print("#include <" + 
									CodeGenerator.escapeFilePaths(head) + ">");
						}
					}
				}
			}
			
			HashSet<String> includedUDTs = new HashSet<String>();
			
			// Include DataTypes
			if( fb.inputData != null ) {
				for(VarType v : fb.inputData) {
					String type = v.getType();
					if (!includedUDTs.contains(type) && !IEC61131Types.isIEC61131Type(type)) {
						printer.print("#include \"" + type + ".h\"");
						includedUDTs.add(type);
					}
				}
			}
			// Include DataTypes
			if( fb.outputData != null ) {
				for(VarType v : fb.outputData) {
					String type = v.getType();
					if (!includedUDTs.contains(type) && !IEC61131Types.isIEC61131Type(type)) {
						printer.print("#include \"" + type + ".h\"");
						includedUDTs.add(type);
					}
				}
			}
			
			// If there are ST functions, include STFunctions.h (and copy it)
			if (fb.getBasicFB() != null) {
				if (fb.getBasicFB().algorithms != null) {
					// Include DataTypes
					if( fb.getBasicFB().internalVars != null ) {
						for(VarDeclaration v : fb.getBasicFB().internalVars) {
							String type = v.getType();
							if (!includedUDTs.contains(type) && 
								!IEC61131Types.isIEC61131Type(type)) {
								printer.print("#include \"" + type + ".h\"");
								includedUDTs.add(type);
							}
						}
					}
				
					for (Algorithm a : fb.getBasicFB().algorithms) {
						if (a.getLanguage().equals("ST")) {
							printer.print("#include \"STFunctions.h\"");
							String stfunctions = getParentName(fileName) + "STFunctions.h";
							String resources = "resources" + File.separatorChar + "STFunctions.h";
							BufferedWriter writer = null;
							BufferedReader reader = null;
							if (!fileNames.contains(stfunctions)) {
								fileNames.add(stfunctions);
								try {
									writer = new BufferedWriter(new FileWriter(stfunctions));
									reader = new BufferedReader(new FileReader(resources));
								} catch (FileNotFoundException e) {
									OutputManager.printError("", resources + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								} catch (IOException e) {
									OutputManager.printError("", stfunctions + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								}
								plainCopyFile(writer, reader);
							}

							stfunctions = getParentName(fileName) + "STFunctions.c";
							resources = "resources" + File.separatorChar + "STFunctions.c";
							if (!fileNames.contains(stfunctions)) {
								fileNames.add(stfunctions);
								try {
									writer = new BufferedWriter(new FileWriter(stfunctions));
									reader = new BufferedReader(new FileReader(resources));
								} catch (FileNotFoundException e) {
									OutputManager.printError("", resources + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								} catch (IOException e) {
									OutputManager.printError("", stfunctions + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								}
								plainCopyFile(writer, reader);
							}
							break;
						}
					}
				}
			}


			if (rprinter != null) {
				rprinter.print("// This file is generated by FBC.", 1);
			}

			String fbName = fb.getCompiledType();
			Composite compositeFB = fb.getCompositeFB();
			if (compositeFB == null) {
				printer.print("");
				if (fb.getBasicFB() != null) {
					generateBasicFB(fbName,top);
				}
				else {
					// This prints the interface .h file for Adapters!!!! (and PretC)
					generateInterface(fbName, false, true);
				}
			}
			else {
				HashSet<String> files = new HashSet<String>();
				for (int i = 0; i < runs.length; i++) {
					String runType = runs[i].getType();

					if (!files.contains(runType) && !isLocalComBlock(runType)) {
						//printer.print("#include \"" + runType + ".h\"");
						//files.add(runType);
					}
				}


				printer.print("");

				// Check if global variables for local communication blocks are to be generated
				if (comBlocks != null && opts.isRunnable()) {
					HashMap<String, Variables> globalVars = CProgGenerator.createGlobalVars(comBlocks);
					String comFile = fileName + "run.h";
					CodePrinter comPrinter = new CodePrinter(comFile);
					comPrinter.print("// This file is generated by FBC.", 1);
					comFile = makeHeaderMacro(getFileName(comFile));
					comPrinter.print("#ifndef " + comFile);
					comPrinter.print("#define " + comFile, 1);
					CProgGenerator.printGlobalVars(globalVars, rprinter, comPrinter);
					comPrinter.print("#endif // " + comFile);
					comPrinter.close();
					rprinter.writeToBuf();
					rprinter.indent();
					CProgGenerator.initGlobalVars(globalVars, rprinter);
					rprinter.unindent();
					rprinter.writeToFile();
				}

				generateInterface(fbName, true, false);
				if (opts.isSorted()) {
					printSortedComposite(fbName);
				}else{
					System.err.println("PRET-C needs to be sorted");
					System.exit(0);
				}
					

				// Print out all deferred blocks
				ListIterator<CodeGenerator> cgIterator = deferredBlocks.listIterator();
				
				while ( cgIterator.hasNext() ) {
					CodeGenerator dcg = cgIterator.next();
					// Get instance
					Instance inst = getInstance(dcg.getName());


					if (dcg.fb.isSIFB()) {
						if (dcg.sifbInfo.getIndex() < 0) {
							// try to get one
							String cntValue = FBtoStrl.varSizeMap.get(inst.getFQName() + ".CNT");
							if (cntValue != null)
								dcg.setSIFBCountValue("CNT", Integer.valueOf(cntValue));
						}
					}
					dcg.generateCode(dcg.getFileName(), false, null);
					
					// Deferred code generators should be removed once they are no longer
					// needed to avoid confusion later as to whether they are still needed. 
					cgIterator.remove();
				}

			}

			if (rprinter != null)
				rprinter.close();






			cprinter.close();
			

			printer.print("#endif // " + def);
			printer.close();

			// Just for first file
			hname = getParentName(fileName) + "fbtypes.h";
			if (!fileNames.contains(hname)) {
				// fbtypes.h
				hname = getParentName(fileName) + "fbtypes.h";
				printer = new CodePrinter(hname);
				fileNames.add(hname);
				printer.print("// This file is generated by FBC.", 1);
				
				def = makeHeaderMacro("fbtypes.h");
				printer.print("#ifndef " + def);
				printer.print("#define " + def, 1);
				
				printer.print("/*********************************************************************");
				printer.print(" This file contains the mapping between IEC 61131 and C data types.");
				printer.print(" Since C data types are non-portable, this file MUST be customized to");
				printer.print(" match the data width assumed by the C compiler used for compiling the");
				printer.print(" generated code. This enables the generated code to be easily ported");
				printer.print(" to other platforms.");
				printer.print("*********************************************************************/", 1);
				
				printer.println("// Time data types");
				printer.println("#if _MSC_VER");
					printer.println("#include <winsock2.h>");
				printer.println("#else");
					printer.println("#include <sys/time.h>");
				printer.println("#endif");
				printer.println();
				printer.println("// bool stuff");
				printer.println("#ifndef __cplusplus");
					printer.println("typedef char bool;");
				printer.println("#endif // __cplusplus");
				printer.println();
				printer.println("#ifndef true");
					printer.println("#define true 1");
					printer.println("#define false 0");
				printer.println("#endif");
				printer.println();
				printer.println("#ifndef TRUE");
					printer.println("#define TRUE true");
				    printer.println("#define FALSE false");
				    printer.println("#endif");
				printer.println("");
				
				// DATATYPES:
				// http://en.wikipedia.org/wiki/IEC_61131-3#Data_Types
				// these defines are useless because the conversion functions need to take into account the size / max min values
				
				printer.print("#define STRING_LENGTH " + Integer.toString(Options.strlen()), 1);
				
				printer.println("// Bit strings");
				printer.println("typedef bool BOOL;");
				printer.println("typedef unsigned char BYTE;");
				printer.println("typedef unsigned short WORD;");
				printer.println("typedef unsigned int DWORD;");
				printer.println("typedef unsigned long long LWORD;");
				printer.println();
				printer.println("// Integers");
				printer.println("typedef char SINT;");
				printer.println("typedef unsigned char USINT;");
				printer.println("typedef short INT;");
				printer.println("typedef unsigned short UINT;");
				printer.println("typedef int DINT;");
				printer.println("typedef unsigned int UDINT;");
				printer.println("typedef long long LINT;");
				printer.println("typedef unsigned long long ULINT;");
				printer.println();
				printer.println("// Reals");
				printer.println("typedef float REAL;");
				printer.println("typedef double LREAL;");
				printer.println();
				printer.println("// Duration");
				printer.println("typedef long long TIME;");
				printer.println("");
				// TODO: Find a platform independent implementation for DATE and TIME etc types
				//printer.println("typedef long long TIME_OF_DAY;");
				//printer.println("typedef struct timeval DATE;");
				//printer.println("typedef struct timeval DATE_AND_TIME;");
				//printer.println("");
				printer.println("// Strings");
				// TODO: Remove FBstring and just use STRING
				printer.println("typedef char FBstring[STRING_LENGTH];");
				printer.println("typedef FBstring STRING;");
				printer.println("typedef FBstring WSTRING;");
				printer.println();
				printer.print("#endif // " +def, 1);
				printer.close();
				
			}
		}
		return null;
	}

	static String getComBlockType(String blockType) {
		if (isLocalComBlock(blockType)) {
			return blockType.substring(0, blockType.indexOf('_') + 1);
		}
		return "";
	}

	String getComPartnerType(String blockType) {
		if (blockType.equals("SEND_"))
			return "RECV_";
		else
			/* if (blockType.equals("RECV_")) */
			return "SEND_";
	}

	void clearOutputEvents(String blockType, String insName) throws IOException {
		if (blockType.startsWith("SEND_")) {
			cprinter.print("_" + insName + "._output.event.SEND_CNF = 0;");
		}
		else if (blockType.startsWith("RECV_")) {
			cprinter.print("_" + insName + "._output.event.RECV_IND = 0;");
		}
	}

	int[] getComBlockIndices(String blockType) {
		int[] indices = new int[2];
		String tail = blockType.substring(5);
		if (blockType.startsWith("SEND_") || blockType.startsWith("RECV_")) {
			int idx = tail.indexOf('_');
			if (idx > 0) {
				String qlen = tail.substring(idx + 1);
				String index = tail.substring(0, idx);
				if (SIPath.isAllDigit(qlen) && SIPath.isAllDigit(index)) {
					indices[0] = Integer.parseInt(index);
					indices[1] = Integer.parseInt(qlen);
				}
			}
		}
		else {
			if (SIPath.isAllDigit(tail))
				indices[0] = Integer.parseInt(tail);
		}

		return indices;
	}

	private String makeIFLocalDataAssignment(String instance, String sig, String blockType) {
		return "_" + instance + "._d" + sig;
	}

	private String makeLocalDataAssignment(String instance, String sig, String blockType) {
		if (blockType.startsWith("SEND_"))
			return "_" + instance + ".d" + sig + "[_" + instance + "._wrptr]";
		else /* if (blockType.startsWith("RECV_")) */
			return "_" + instance + ".d" + sig + "[_" + instance + "._rdptr]";
	}

	public static String makeLocalEvAssignment(String instance, String sig,
			String blockType, boolean io) {
		if (!io)
			return "_" + instance + "._input.event." + getComBlockType(blockType) + sig;
		else
			return "_" + instance + "._output.event." + getComBlockType(blockType) + sig;
	}

	String getComPortIndex(String portName) {
		if (portName.startsWith("SD_") || portName.startsWith("RD_"))
			return portName.substring(3);
		return portName;
	}

	boolean hasComPortIndex(String portName) {
		return SIPath.isAllDigit(getComPortIndex(portName));
	}

	/* Returns a set containing all declarations for toANY converter functions */
	protected HashSet<String> getToAnyConverterDecls() {
		HashSet<String> decls = new HashSet<String>();
		int index = sifbInfo.getIndex();
		for (int i = 0; i < index; i++) {
			String[] func = sifbInfo.getToAnyConverterDecl(i);
			decls.add("ANY " + func[0] + "(" + func[1] + ");");
		}
		return decls;
	}

	/* Returns a set containing all declarations for ANYto converter functions */
	protected HashSet<String> getAnyToConverterDecls() {
		HashSet<String> decls = new HashSet<String>();
		int index = sifbInfo.getIndex();
		for (int i = 0; i < index; i++) {
			String[] func = sifbInfo.getAnyToConverterDecl(i);
			decls.add(func[1] + " " + func[0] + "(ANY);");
		}
		return decls;
	}
	
	/**
	 * Prints the .h file for PUBL service interface function blocks.
	 * @param file name of the PUBL file
	 * @throws IOException
	 */
	protected void printPUBL_h_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		String globalType = sifbInfo.getGlobalVarType();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#ifndef PUBL" + postfix + "_H_");
		sifbPrinter.print("#define PUBL" + postfix + "_H_", 1);
		
		sifbPrinter.print("#include \"fbtypes.h\"");
		sifbPrinter.print("#include \"" + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h\"");
		ArrayList<String> userDefinedTypes = 
			sifbInfo.getUserTypesForPorts(fullyQualifiedInsName);
		for (String userType : userDefinedTypes)
			sifbPrinter.print("#include \"" + userType + ".h\"");
		sifbPrinter.println();
		
		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INIT : 1; // service initialization");
		sifbPrinter.smartPrint("UDINT REQ : 1; // service request");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} PUBL" + postfix + "IEvents;", 1);

		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INITO : 1; // initialization confirm");
		sifbPrinter.smartPrint("UDINT CNF : 1; // service confirmation");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} PUBL" + postfix + "OEvents;", 1);

		sifbPrinter.smartPrint("typedef struct {");
		sifbPrinter.smartPrint("//BOOL _entered;");
		sifbPrinter.smartPrint("PUBL" + postfix + "IEvents _input;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String type = anyTypes[i-1].getType();
			if (type.equalsIgnoreCase("ANY"))
				type = "BOOL";
			String portName = "SD_" + i;
			sifbPrinter.smartPrint(type + " _" + portName + 
					getArrayIndex(anyTypes[i-1].getArraySize(), fullyQualifiedInsName, 
							portName) + ";");
		}
		sifbPrinter.smartPrint("PUBL" + postfix + "OEvents _output;");
		sifbPrinter.smartPrint(globalType + "* _globalBuf;");
		sifbPrinter.smartPrint("} PUBL" + postfix + ";", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "init(PUBL" + postfix + "* me, " + 
				globalType + "* global);", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "run(PUBL" + postfix + "* me);", 1);

		sifbPrinter.smartPrint("#endif /*PUBL" + postfix + "_H_*/");
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .c file for PUBL service interface function blocks.
	 * @param file name of the PUBL file
	 * @throws IOException
	 */
	protected void printPUBL_c_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#include \"PUBL" + postfix + ".h\"");
		sifbPrinter.print("#include <string.h>", 1);
		
		sifbPrinter.smartPrint("/* PUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "init(PUBL" + postfix + "* me, " + 
				sifbInfo.getGlobalVarType() + "* global)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("//me->_entered = false;");
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("me->_output.events = 0;");
		sifbPrinter.smartPrint("me->_globalBuf = global;");
		sifbPrinter.smartPrint("}", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "run(PUBL" + postfix + "* me)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_output.events = 0;", 1);
		sifbPrinter.smartPrint("//if (!me->_entered) {");
		sifbPrinter.smartPrint("//me->_entered = true;");
		sifbPrinter.smartPrint("//}");
		sifbPrinter.smartPrint("else {");
		sifbPrinter.smartPrint("if (me->_input.event.INIT) {");
		sifbPrinter.smartPrint("me->_output.event.INITO = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else if (me->_input.event.REQ) {");
		sifbPrinter.smartPrint("me->_globalBuf->status = _NEW;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String index = Integer.toString(i);
			sifbPrinter.smartPrint( makeAssignment(anyTypes[i-1], 
					"me->_globalBuf->buffer.data_" + index, "me->_SD_" + index, (byte)0) );
		}
		sifbPrinter.smartPrint("me->_output.event.CNF = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("}", 1);
		
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("}");		
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .h file for SUBL service interface function blocks.
	 * @param file name of the SUBL file
	 * @throws IOException
	 */
	protected void printSUBL_h_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		String globalType = sifbInfo.getGlobalVarType();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#ifndef SUBL" + postfix + "_H_");
		sifbPrinter.print("#define SUBL" + postfix + "_H_", 1);
		
		sifbPrinter.print("#include \"fbtypes.h\"");
		sifbPrinter.print("#include \"" + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h\"");
		ArrayList<String> userDefinedTypes = 
			sifbInfo.getUserTypesForPorts(fullyQualifiedInsName);
		for (String userType : userDefinedTypes)
			sifbPrinter.print("#include \"" + userType + ".h\"");
		sifbPrinter.println();
		
		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INIT : 1; // service initialization");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} SUBL" + postfix + "IEvents;", 1);

		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INITO : 1; // initialization confirm");
		sifbPrinter.smartPrint("UDINT IND : 1; // service indication");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} SUBL" + postfix + "OEvents;", 1);

		sifbPrinter.smartPrint("typedef struct {");
		sifbPrinter.smartPrint("//BOOL _entered;");
		sifbPrinter.smartPrint("SUBL" + postfix + "IEvents _input;");
		sifbPrinter.smartPrint("SUBL" + postfix + "OEvents _output;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String type = anyTypes[i-1].getType();
			if (type.equalsIgnoreCase("ANY"))
				type = "BOOL";
			String portName = "RD_" + i;
			sifbPrinter.smartPrint(type + " _" + portName + 
					getArrayIndex(anyTypes[i-1].getArraySize(), fullyQualifiedInsName,
							portName) + ";");
		}
		sifbPrinter.smartPrint(globalType + "* _globalBuf;");
		sifbPrinter.smartPrint("} SUBL" + postfix + ";", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "init(SUBL" + postfix + "* me, " + 
				globalType + "* global);", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "run(SUBL" + postfix + "* me);", 1);

		sifbPrinter.smartPrint("#endif /*SUBL" + postfix + "_H_*/");
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .c file for SUBL service interface function blocks.
	 * @param file name of the SUBL file
	 * @throws IOException
	 */
	protected void printSUBL_c_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#include \"SUBL" + postfix + ".h\"");
		sifbPrinter.print("#include <string.h>", 1);
		
		sifbPrinter.smartPrint("/* SUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "init(SUBL" + postfix + "* me, " + 
				sifbInfo.getGlobalVarType() + "* global)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("//me->_entered = false;");
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("me->_output.events = 0;");
		sifbPrinter.smartPrint("me->_globalBuf = global;");
		sifbPrinter.smartPrint("}", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "run(SUBL" + postfix + "* me)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_output.events = 0;", 1);
		sifbPrinter.smartPrint("//if (!me->_entered) {");
		sifbPrinter.smartPrint("//me->_entered = true;");
		sifbPrinter.smartPrint("//}");
		sifbPrinter.smartPrint("else {");
		sifbPrinter.smartPrint("if (me->_input.event.INIT) {");
		sifbPrinter.smartPrint("me->_output.event.INITO = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else if (me->_globalBuf->status & _NEW) {");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String index = Integer.toString(i);
			sifbPrinter.smartPrint( makeAssignment(anyTypes[i-1], "me->_RD_" + index, 
					"me->_globalBuf->buffer.data_" + index, (byte)1) );
		}
		sifbPrinter.smartPrint("me->_globalBuf->status &= ~_NEW;");
		sifbPrinter.smartPrint("me->_output.event.IND = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("}", 1);
		
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("}");		
		sifbPrinter.close();
	}

	/**
	 * Retrieves the desired SIFB and produces the corresponding code.
	 * @param fileName base name of the output file(s) produced
	 */
	protected void retrieveSIFB(String fileName) throws IOException {
		String blockName = sifbInfo.getBlockName();
		if (blockName.equals("SEND") || blockName.equals("RECV") ||
			blockName.equals("SENDD3") || blockName.equals("RECVD3")) {
			return;
		}
		
		if (blockName.equals("PUBL")) {
			printPUBL_h_file(fileName + ".h");
			printPUBL_c_file(fileName + filetype);
			return;
		}
		else if (blockName.equals("SUBL")) {
			printSUBL_h_file(fileName + ".h");
			printSUBL_c_file(fileName + filetype);
			return;
		}
		else if (blockName.endsWith("_HMI")) {
			OutputManager.printNotice(blockName, "Ignoring " + fileName + " for now.", 
					OutputLevel.INFO);
			return;
		}

		String file = fileName + ".h";
		if (fileNames.contains(file))
			return;
					
		String sourcePath = sifbInfo.getPath() + blockName;
		BufferedWriter out = null;
		BufferedReader in = null;
		try {
			out = new BufferedWriter(new FileWriter(file));
			fileNames.add(file);
			file = sourcePath + ".h";
			in = new BufferedReader(new FileReader(file));
		} catch (IOException e) {
			OutputManager.printError(fileName, file + ": Could not be opened.\n", 
					OutputLevel.FATAL);
			System.exit(-1);
		}
		copyFile(out, in);

		file = fileName + filetype;
		try {
			out = new BufferedWriter(new FileWriter(file));
			fileNames.add(file);
			file = sourcePath + filetype;
			in = new BufferedReader(new FileReader(file));
		} catch (IOException e) {
			OutputManager.printError(fileName, file + ": Could not be opened.\n", 
					OutputLevel.FATAL);
			System.exit(-1);
		}
		copyFile(out, in);
	}

	/**
	 * Generates code to perform send for local communication block.
	 * @param queue queue length 
	 * @param insName instance name of the local communication block 
	 * @param index number of data elements of the communication block 
	 * @param blockType type of local communication block 
	 * @param partnerType corresponding partner type of the communcation block 
	 * @param prefix prefix for generating code
	 */
	private void generateSend(int queue, String insName, int index,
			String blockType, String partnerType, String prefix)
			throws IOException {
		if (queue > 0) {
			String count = "_" + insName + "._count";
			String wrptr = "_" + insName + "._wrptr";
			String qlen = Integer.toString(queue);
			cprinter.print("if (" + count + " < " + qlen + ") {");
			cprinter.indent();
			for (int j = 0; j < index; j++) {
				String internal = makeLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				String external = makeIFLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				DataType data = FBtoStrl.getAnyDataType(insName, blockType, j + 1);
				String varType = data.getType();
				if (varType.equalsIgnoreCase("STRING") || varType.equalsIgnoreCase("WSTRING")) {
					cprinter.print("strcpy(" + internal + ", " + external + ");");
				}
				else {
					cprinter.print(internal + " = " + external + ";");
				}
			}
			cprinter.print(count + "++;");
			cprinter.print(wrptr + "++;");
			cprinter.print("if (" + wrptr + " >= " + qlen + ") ");
			cprinter.indent();
			cprinter.print(wrptr + " = 0;");
			cprinter.unindent();
			cprinter.print(prefix + blockType + "CNF = 1;");
			// cprinter.print(prefix + partnerType + "IND = 1;");
			cprinter.unindent();
			cprinter.print("}");
		}
		else {
			for (int j = 0; j < index; j++) {
				String internal = makeLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				String external = makeIFLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				DataType data = FBtoStrl.getAnyDataType(insName, blockType, j + 1);
				String varType = data.getType();
				if (varType.equalsIgnoreCase("STRING") || varType.equalsIgnoreCase("WSTRING")) {
					cprinter.print("strcpy(" + internal + ", " + external + ");");
				}
				else {
					cprinter.print(internal + " = " + external + ";");
				}
			}
			cprinter.print(prefix + "SHARED = 1;");
			cprinter.print(prefix + blockType + "CNF = 1;");
		}
	}
	
	/**
	 * Looks for SENDuCOS blocks that will be rescheduled among all the subblocks 
	 * in a function block network.
	 * @return List of all SENDuCOS blocks in the network
	 */
	ArrayList<String> getReschedSENDuCOSblocks() {
		ArrayList<String> sendBlocks = new ArrayList<String>();
		for (int i = 0; i < runs.length; i++) {
			// No run function for local communication blocks and adapters
			if (!isLocalComBlock(runs[i].getType()) && !runs[i].isPlug() && !runs[i].isSocket()) {
				if (runs[i].getType().startsWith("SENDuCOS_")) {
					String msgID = runs[i].getParamValue("ID");
					if (msgID == null)
						continue;
					MsgPeriods periods = msgPeriodMap.get(msgID);
					if (periods.getSendPeriod() > periods.getRecvPeriod())
						sendBlocks.add(runs[i].getType() + "send(&me->" + runs[i].name + ");");
				}
			}
		}
		return sendBlocks;
	}


	Instance getInstance(FBInstance instance) {
		for (int i = 0; i < runs.length; i++) {
			if (runs[i].equals(instance))
				return runs[i];
		}
		assert (false) : "Instance " + instance.name + ":" + instance.type + " cannot be found.\n";
		return null;
	}

	/**
	 * Generates topologically sorted code to instantiate the subblocks in a 
	 * composite function block.
	 * @param fbName type name of function block network
	 */
	protected void printSortedComposite(String fbName) throws IOException {
		// Print out the function block execution function
		cprinter.print("/* Function block execution function */");
		  

		cprinter.print("thread " + fbName + "run()");

		cprinter.print("{");
		cprinter.indent();
		

		if (insName.length() == 0) {		
			cprinter.print(fbName + "* me = top_var" + ";", 1);
		}else{
			cprinter.print(fbName + "* me = " + fb.getCompiledType() + "_var;", 1);
		}
		

		

		HashSet<String> clearedInstances = new HashSet<String>();
		ArrayList<LocalComInfo> localComEvents = new ArrayList<LocalComInfo>();


		
		String prevInsName = insName;
		Instance lastInstanceOfComposite = null;
		for (int i = 0; i < sortedNodes.length; i++) {
			
			
			Instance instance = getInstance(sortedNodes[i].getInstance());
			lastInstanceOfComposite = instance;
			String insName = instance.name;
			String insType = instance.getType();
			
			//hack swap printers temporary
			CodePrinter temp = cprinter;
			cprinter = printer;
			
			if (i == 0 && this.insName.length() != 0) { //composite of composite the first block updates it networks.
				//only if it is not the top level
				cprinter.println("void " + fbName+"_networkInput(); //network update of top level composite block");
			}
			
			//temp.println(instance.getType()+"_networkInput();");
			cprinter.println("void "+instance.getType()+"_networkInput() {");
			cprinter.indent();
			if (prevInsName.length() == 0) {		
				cprinter.print(fbName + "* me = top_var" + ";", 1);
			}else{
				cprinter.print(fbName + "* me = " + fb.getCompiledType() + "_var;", 1);
			}
			
			if (i == 0 && this.insName.length() != 0) { //composite of composite the first block updates it networks.
				//only if it is not the top level
				cprinter.println(fbName+"_networkInput(); //network update of top level composite block");
			}
			// Update delayed inputs for each sub-block 
			//for (int j = 0; j < sortedNodes.length; j++) {
			//	Instance instance = getInstance(sortedNodes[j].getInstance());
				for (Signal sig : instance.getSignalSet()) {
					if (sig.getPortType() != PortType.INPUT)
						continue;
					printInputBindings(instance, instance.getType(), instance.name, sig, 
							localComEvents, DelayType.DELAYONLY);
				}
			//}
			cprinter.print("");
			
			// Update inputs for the sub-block
			Event[] events = sortedNodes[i].getInputEvents();
			if (events != null) {
				for (int j = 0; j < events.length; j++) {
					Signal sig = new Signal(new PortName(insName, insType,
							events[j].getName()), PortType.LOCAL);
					printInputBindings(instance, insType, insName, sig, localComEvents, 
							DelayType.DELAYNONE);
				}
			}
			VarDeclaration[] vars = sortedNodes[i].getInputVars();
			if (vars != null) {
				for (int j = 0; j < vars.length; j++) {
					Signal sig = new Signal(insName, insType, vars[j].getName(), 
							vars[j].getType(), vars[j].getArraySize(), PortType.INPUT);
					printInputBindings(instance, insType, insName, sig, localComEvents, 
							DelayType.DELAYNONE);
				}
			}
			cprinter.unindent();
			cprinter.println("}");
			
			cprinter.println("void "+instance.getType()+"_networkOutput() {");
			cprinter.indent();
			if (i == sortedNodes.length -1) {
				if (prevInsName.length() == 0) {		
					cprinter.print(fbName + "* me = top_var" + ";", 1);
				}else{
					cprinter.print(fbName + "* me = " + fb.getCompiledType() + "_var;", 1);
				}
				printCompositeOutputs(fbName);
			}
			cprinter.unindent();
			cprinter.println("}");
			
			
			cprinter = temp;
			//hack end
			
			if (isLocalComBlock(insType)) {
				// Process local communication blocks
				// Clear all output events
				if (!clearedInstances.contains(insName)) {
					clearOutputEvents(insType, insName);
					clearedInstances.add(insName);
					if (insType.startsWith("RECV_")) {
						cprinter.print("if (_" + insName + "._count > 0) {");
						cprinter.indent();
						cprinter.print("_" + insName + "._output.event.RECV_IND = 1;");
						cprinter.unindent();
						cprinter.print("}");
					}
				}

				// Update input event-data associations
				if (events != null) {
					String prefix = makeLocalEvAssignment(insName, "", "", true);
					String blockType = getComBlockType(insType);
					String partnerType = getComPartnerType(blockType);
					int[] indices = getComBlockIndices(insType);
					for (int j = 0; j < events.length; j++) {
						String event = events[j].getName();
						cprinter.print("if (" + makeLocalEvAssignment(insName, event,
								insType, false) + ") {");
						cprinter.indent();
						if (event.equals("REQ")) {
							generateSend(indices[1], insName, indices[0], blockType, 
									partnerType, prefix);
						} 
						else if (event.equals("INIT")) {
							cprinter.print(prefix + blockType + "INITO = 1;");
						}
						cprinter.unindent();
						cprinter.print("}");
					}
				}
			}
			else {
				if (!instance.isPlug() && !instance.isSocket()) {
					// No run function for adapters
					//cprinter.print(insType + "run();", 1);
				}
			}


		}
		cprinter.print("PAR(",0);
		for (int i = 0; i < sortedNodes.length; i++) {
			Instance instance = getInstance(sortedNodes[i].getInstance());
			String insName = instance.name;
			String insType = instance.getType();
			if (i == 0) {
				cprinter.print(insType + "run",0);
			}else{
				cprinter.print(","+insType + "run",0);
			}
			
		}
		if (sortedNodes.length == 1) {
			
			cprinter.print(",void");
		}
		cprinter.print(");");



		cprinter.unindent();
		cprinter.print("}");
	}

	/**
	 * Generates input assignments for subblocks in a composite function block.
	 * @param instance instance of the subblock 
	 * @param insType type of the subblock instance
	 * @param insName name of the subblock instance
	 * @param sig input signal to be assigned 
	 * @param localComEvents container to specially handle local communication blocks 
	 * @param delayedOnly TRUE when printing delayed input signals in --sorted mode; FALSE otherwise
	 */
	private void printInputBindings(Instance instance, String insType, String insName, 
			Signal sig, ArrayList<LocalComInfo> localComEvents, DelayType delayType)
			throws IOException {
		HashSet<Signal> bindings = instance.getBindings(sig);
		if (sig.getSignal().contains("@CNT@")) {
			// TODO: multiple COUNT names... @CNT<other stuff>@
			String baseSignal = sig.getSignal();
			// A variable sized input :|
			for (int vs = 0; vs < 20; vs++) // assume max of 20
			{
				Signal varSig = new Signal(sig.getInstance(), sig.getInsType(),
						baseSignal.replace("@CNT@", "" + vs), sig.getSigType(),
						sig.getArraySize(), sig.getPortType());
				bindings = instance.getBindings(varSig);
				if (bindings == null)
					continue; // skip
				printInputBindings(instance, insType, insName, varSig, localComEvents, 
						delayType);
			}
			return;
		}
		// TODO: use same format as nxtStudio?
		else if (sig.getSignal().contains("${CNT}")) // nxtControl format...
		{
			String baseSignal = sig.getSignal();
			// A variable sized input :|
			for (int vs = 0; vs < 20; vs++) // assume max of 20
			{
				Signal varSig = new Signal(sig.getInstance(), sig.getInsType(),
						baseSignal.replace("${CNT}", "" + vs), sig.getSigType(), 
						sig.getArraySize(), sig.getPortType());
				bindings = instance.getBindings(varSig);
				if (bindings == null)
					continue; // skip
				printInputBindings(instance, insType, insName, varSig, localComEvents, 
						delayType);
			}
			return;
		}

		if (bindings == null)
			return;
		if (bindings.size() < 1)
			return;
		
		printCompositeInputs(instance, sig, localComEvents, bindings, delayType);
	}

	/**
	 * Creates data assignments for the sources of ANY type.
	 * @param instance instance name of the subblock 
	 * @param sig input port of the subblock 
	 * @param bind parameter/port bound to "sig" (the ANY type)
	 */
	/*
	private String makeAnySrcAssignment(Signal srcSig, Signal destSig) {
		StringBuilder line = new StringBuilder();
		boolean isString = srcSig.getSigType().equalsIgnoreCase("STRING");
		boolean isWString = srcSig.getSigType().equalsIgnoreCase("WSTRING");
		String insType = destSig.getInsType();
		PortType bindType = destSig.getPortType();

		String dst;
		if (destSig.getInstance().length() > 0)
			dst = "me->" + destSig.getInstance() + "._" + destSig.getSignal();
		else
			dst = "me->_" + destSig.getSignal();

		if (isLocalComBlock(insType)) {
			if (isString)
				line.append("strcpy(");
			else if (isWString)
				line.append("strcpy(");

			String src;
			if (bindType == PortType.LOCAL || bindType == PortType.LOCALDELAYED) {
				src = makeLocalDataAssignment(srcSig.getInstance(),
						getComPortIndex(srcSig.getSignal()), insType);
			} else {
				if (srcSig.getInstance().length() > 0)
					src = "me->" + srcSig.getInstance() + "._" + srcSig.getSignal();
				else
					src = "me->_" + srcSig.getSignal();
			}

			if (isString || isWString)
				line.append(dst + ", " + src + ");");
			else
				line.append(dst + " = " + src + ";");
		} 
		else {
			if (isString)
				line.append("strcpy(");
			else if (isWString)
				line.append("strcpy(");
			else
				line.append("memcpy(&");
			line.append(dst);

			String src;
			if (srcSig.getInstance().length() > 0)
				src = "me->" + srcSig.getInstance() + "._" + srcSig.getSignal();
			else
				src = "me->_" + srcSig.getSignal();

			if (isString || isWString)
				line.append(", " + src + ".buf);");
			else
				line.append(", " + src + ".buf, " + src + ".len);");
		}

		return line.toString();
	}
	*/

	/**
	 * Generates input assignments for subblocks in a composite function block.
	 * @param run instance of subblock 
	 * @param sig input signal to be assigned 
	 * @param localComEvents container to specially handle local communication blocks 
	 * @param bindings signals to be assigned to "sig"
	 * @param delayType specifies the type of input assignment being generated
	 */
	private void printCompositeInputs(Instance run, Signal sig, 
			ArrayList<LocalComInfo> localComEvents, HashSet<Signal> bindings, DelayType delayType) 
			throws IOException {
		if (sig.getSigType() == null) {			
			// Generate the left-hand-side of the assignment
			String sigName = sig.getSignal();
			StringBuilder line;
			if (!isLocalComBlock(run.type)) {
				line = new StringBuilder("me->" + run.name + "._input.event." + sigName);
			}
			else {
				line = new StringBuilder(makeLocalEvAssignment(run.name, sigName, run.type, false));
				localComEvents.add(new LocalComInfo(sigName, line.toString(), run.name, run.type));
			}
			String lhs = line.toString();
			
			// Generate the type of assignment
			line.append(" = ");
			if (delayType == DelayType.DELAYNONE) {
				// Check if we have bindings that mix delayed and non-delayed connections
				final byte DELAYED = 0x01;
				final byte NONDELAYED = 0x02;
				final byte MIXED = 0x03;
				byte connectionType = 0;
				for (Signal bind : bindings) {
					if (bind.getPortType() == PortType.LOCALDELAYED)
						connectionType |= DELAYED;
					else
						connectionType |= NONDELAYED;
					if (connectionType == MIXED)
						break;
				}
				if (connectionType == MIXED)
					line.append(lhs + " || ");
			}

			// Generate the right-hand-side of the assignment
			boolean printed = false;
			for (Signal bind : bindings) {
				PortType bindType = bind.getPortType();
				switch (delayType) {
					case DELAYALL:
						// For compilation without --sorted
						printed = printInputValue(bind, line, printed);
						break;
					case DELAYONLY:
						// Print LOCALDELAYED ports separately from others
						if (bindType == PortType.LOCALDELAYED)
							printed = printInputValue(bind, line, printed);
						break;
					case DELAYNONE:
						// Print out connections to all other ports
						if (bindType != PortType.LOCALDELAYED)
							printed = printInputValue(bind, line, printed);
						break;
				}
			}
			if (printed) {
				line.append(";");
				cprinter.print(line.toString());
			}
		}
		else {
			assert (bindings.size() == 1) : "Multiple bindings on data port " + run.name + 
					"." + sig.getSignal() + ".\n";
			Signal bind = bindings.iterator().next();
			if (delayType == DelayType.DELAYONLY && bind.getPortType() != PortType.LOCALDELAYED)
				return; // Don't print non-delayed
			if (delayType == DelayType.DELAYNONE && bind.getPortType() == PortType.LOCALDELAYED )
				return; // Don't print delayed
			// Print only non-parameters: parameters are printed in init function
			if (bind.getPortType() != PortType.PARAM) 
				printInputAssignments(run, sig, bind);
		}
	}
	
	/**
	 * Generates values to be assigned to input ports of a subblock in a network 
	 * @param bind value to be assigned 
	 * @param line buffer to store generated values 
	 * @param printed boolean flag to indicate if buffer already contains previous content
	 * @param delayType specifies the type of input assignment being generated
	 * @return TRUE if value was generated; FALSE otherwise
	 */
	private boolean printInputValue(Signal bind, StringBuilder line, boolean printed) {
		switch (bind.getPortType()) {
			case LOCALDELAYED:
			case LOCAL:
				if (printed)
					line.append(" || ");
				String insType = bind.getInsType();
				if (isLocalComBlock(insType)) {
					line.append(makeLocalEvAssignment(bind.getInstance(), bind.getSignal(), 
							insType, true));
				}
				else {
					line.append("me->" + bind.getInstance() + "._output.event." + bind.getSignal());
				}
				return true;
			case INPUT:
				if (printed)
					line.append(" || ");
				line.append("me->_input.event." + bind.getSignal());
				return true;
			case OUTPUT:
				if (printed)
					line.append(" || ");
				line.append("me->_output.event." + bind.getSignal());
				return true;
		}
		return false;
	}

	/**
	 * Generates assignments to the outputs of a composite function block.
	 * @param fbName - type name of composite function block
	 */
	private void printCompositeOutputs(String fbName) throws IOException {
		// Update outputs for each sub-block
		PortMap outputMap = new PortMap();
		HashMap<Signal, Signal> directConnections = fb.compositeFB
				.getDirectConnections();
		for (Signal src : directConnections.keySet()) {
			outputMap.add(directConnections.get(src), src);
		}

		for (int i = 0; i < runs.length; i++) {
			Set<Signal> signals = runs[i].getSignalSet();
			Iterator<Signal> j = signals.iterator();
			while (j.hasNext()) {
				Signal sig = j.next();
				if (sig.getPortType() != PortType.OUTPUT)
					continue;
				HashSet<Signal> bindings = runs[i].getBindings(sig);
				int size = bindings.size();
				if (size < 1)
					continue;
				Iterator<Signal> k = bindings.iterator();
				while (k.hasNext()) {
					Signal bind = k.next();
					PortType bindType = bind.getPortType();
					if (bindType == PortType.OUTPUT) {
						outputMap.add(bind, sig);
					}
				}
			}
		}
		Set<Signal> signals = outputMap.getSignalSet();
		Iterator<Signal> j = signals.iterator();
		while (j.hasNext()) {
			Signal sig = j.next();
			HashSet<Signal> bindings = outputMap.getBindings(sig);
			int size = bindings.size();
			if (size < 1)
				continue;
			if (sig.getSigType() == null) {
				StringBuilder line = new StringBuilder("me->_output.event."
						+ sig.getSignal() + " = ");
				Iterator<Signal> k = bindings.iterator();
				for (;;) {
					Signal bind = k.next();
					String insType = bind.getInsType();
					if (isLocalComBlock(insType)) {
						line.append(makeLocalEvAssignment(bind.getInstance(),
								bind.getSignal(), insType, true));
					} else if (bind.getInstance().length() == 0) {
						// output = something from the composite's interface..
						// i.e. input event
						line.append("me->_input.event." + bind.getSignal());
					} else {
						line.append("me->" + bind.getInstance()
								+ "._output.event." + bind.getSignal());
					}
					if (!k.hasNext())
						break;
					line.append(" || ");
				}
				line.append(";");
				cprinter.print(line.toString());

			} else {
				assert (size == 1) : "Multiple bindings on data port " + fbName
						+ "." + sig.getSignal() + ".\n";
				Signal bind = bindings.iterator().next();
				printOutputAssignments(sig, bind);
			}
		}

		// TODO: Composite block ignores Event-Data associtations
	}

	private void printECC(SyncState[] states) throws IOException {

		for (int s = 0; s < states.length; s++) {
			cprinter.print("asm(\"nop\");");
			cprinter.print(statePrefix +"_"+ states[s].getName() + ":");
			cprinter.indent();
			printState(states[s], states.length);
			cprinter.unindent();
		}

	}

	/**
	 * Prints the input assignments for a given subblock in a composite function block 
	 * @param instance instance of the subblock
	 * @param sig input port of the subblock 
	 * @param bind parameter/port bound to "sig"
	 */
	protected void printInputAssignments(Instance instance, Signal sig, Signal bind) 
			throws IOException {
		String sigName = sig.getSignal();
		String sigType = sig.getSigType();
		if (bind.getSigType() == null) { // bound to an Event !?!?
			OutputManager.printError(fb.getCompiledType() + "." + instance.name,
					"Port `" + sigName + "' is bound to event: " + bind.getFullName(), 
					OutputLevel.FATAL);
			System.exit(0);
		}
		if (bind.getSigType().equalsIgnoreCase("ANY")) {
			bind.setSigType(sigType);
		}
		else if (sigType.equalsIgnoreCase("ANY")) {
			// Ideally, it shouldn't get here :(
			// but it does because we create a new Signal from the VarDeclarations
			// Set sigType to be same as bind
			sig.setSigType(bind.getSigType());
		}

		boolean array;
		int size;
		String arraySize = sig.getArraySize();
		if (!arraySize.isEmpty()) {
			array = true;
			if (arraySize.equals("@CNT@") || arraySize.equals("${CNT}") /* nxtStudio format */) {
				// Just get size of binding
				if (bind.getPortType() == PortType.PARAM) {
					// Get array size from string
					size = 1; // always at least 1
					String source = bind.getSignal();
					while (source.indexOf(',') >= 0) {
						size++;
						source = source.replaceFirst(",", "");
					}
				}
				else {
					size = validateArraySize(bind.getArraySize());
					if (size <= 0) {
						OutputManager.printError(bind.getInsType(),
								"Port `" + bind.getSignal() + "' has an invalid array size.", 
								OutputLevel.FATAL);
						System.exit(0);
					}
				}
			}
			else {
				size = validateArraySize(arraySize);
				if (size <= 0) {
					OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
							"' has an invalid array size.", OutputLevel.FATAL);
					System.exit(0);
				}
			}
		}
		else {
			array = false;
			size = -1;
		}
		
		String[] lines;
		String dst = makeDataPortVarName(instance, sigName, "");
		PortType bindType = bind.getPortType();
		switch (bindType) {
			case PARAM:
				String[] params = parseParam(bind.getSigType(), sigName, bind.getSignal(), array);
				if (array && params.length > size) {
					OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
							"' has an invalid array initializer.", OutputLevel.FATAL);
					System.exit(0);
				}
				ArrayList<String> inits = new ArrayList<String>(params.length);
				if (array) {
					for (int i = 0; i < params.length; i++) {
						String index = "[" + i + "]";
						addInitString(inits, sigType, dst, index, params[i]);
					}
				}
				else
					addInitString(inits, sigType, dst, "", params[0]);
				lines = inits.toArray(new String[0]);
				break;
			case LOCAL:
			case LOCALDELAYED:
				lines = makeAssignment(size, sigType, dst, 
						makeDataPortVarName( getInstance(bind.getInstance()), 
								bind.getSignal(), "") );
				break;
			default:
				lines = makeAssignment(size, sigType, dst, "me->_" + bind.getSignal());
				break;
		}
		for (String line : lines)
			cprinter.smartPrint(line);
	}

	/**
	 * Prints the output assignments for a composite function block.
	 * @param sig output port of the composite function block 
	 * @param bind port bound to "sig"
	 */
	protected void printOutputAssignments(Signal sig, Signal bind) throws IOException {
		String sigName = sig.getSignal();
		String sigType = sig.getSigType();
		if (bind.getSigType().equalsIgnoreCase("ANY")) {
			bind.setSigType(sigType);
		}
		else if (sigType.equalsIgnoreCase("ANY")) {
			sig.setSigType(bind.getSigType());
		}
		
		int size;
		String arraySize = sig.getArraySize();
		if (!arraySize.isEmpty()) {
			size = validateArraySize(arraySize);
			if (size <= 0) {
				OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
						"' has an invalid array size.", OutputLevel.FATAL);
				System.exit(0);
			}
		}
		else {
			size = -1;
		}
		
		String src;
		if (bind.getInstance().isEmpty()) {
			// output = something from the composite's interface..
			// i.e. input variable
			src = "me->_" + bind.getSignal();
		}
		else {
			src = makeDataPortVarName(getInstance(bind.getInstance()), bind.getSignal(), "");
		}
		String dst = "me->_" + sigName;
		
		String[] lines = makeAssignment(size, sigType, dst, src);
		for (String line : lines)
			cprinter.smartPrint(line);
	}
	
	public static final String getArrayIndex(boolean array, int index) {
		if (array)
			return "[" + Integer.toString(index) + "]";
		return "";
	}
	
	/**
	 * Creates the C variable name for a particular data port of a function block
	 * @param instance instance of the function block
	 * @param signal name of the data port
	 * @param index array index
	 * @return The string containing the C variable name
	 */
	private static String makeDataPortVarName(Instance instance, String signal, 
			String index) {
		if (instance.type.startsWith("SENDD3_") || instance.type.startsWith("RECVD3_")) {
			return "_" + instance.getGlobalVarName() + "_" + signal.substring(1) + index;
		}
		return "me->" + instance.getName() + "._" + signal + index;
	}
	
	/**
	 * Creates one or more assignment strings (for the case where the variable is an array).
	 * @param arrayIndex size of the array (-1 for non-array types)
	 * @param type type of variable in the assignment
	 * @param dst destination variable
	 * @param src source variable
	 * @return Returns the assignment string(s) created
	 */
	private String[] makeAssignment(int arrayIndex, String type, String dst, String src) {
		String[] assignments;
		String index;
		int k = 0;
		if (arrayIndex <= 0) {
			// This is not an array type
			assignments = new String[1];
			index = "";
		}
		else if (arrayIndex == 1) {
			// This is a degenerate array
			assignments = new String[1];
			index = "[0]";
		}
		else {
			assignments = new String[6];
			assignments[0] = "{";
			assignments[1] = "int i;";
			assignments[2] = "for (i = 0; i < " + arrayIndex + "; i++) {";
			assignments[4] = "}";
			assignments[5] = "}";
			k = 3;
			index = "[i]";
		}
		
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING")) {
			assignments[k] = "strcpy(" + dst + index + ", " + src + index + ");";
		}
		else {
			assignments[k] = dst + index + " = " + src + index + ";";
		}
		return assignments;
	}
	
	/**
	 * Creates one or more assignment strings (for the case where the variable is an array).
	 * @param var variable for assignment
	 * @param dstPrefix prefix for the destination variable
	 * @param srcPrefix prefix for the source variable
	 * @return Returns the assignment string(s) created
	 */
	private String[] makeAssignment(VarDeclaration var, String dstPrefix, 
			String srcPrefix) {		
		int k = 0;
		String index = null;
		String[] assignments = null;
		String name = var.getName();
		String arraySize = var.getArraySize();
		if (!arraySize.isEmpty()) {
			int arrayIndex = validateArraySize(arraySize);
			if (arrayIndex <= 0) {
				OutputManager.printError(insName, "Variable `" + name + 
						"\' has an invalid array size.", OutputLevel.FATAL);
				System.exit(0);
			}
			else if (arrayIndex == 1) {
				assignments = new String[1];
				index = "[0]";
			}
			else {
				assignments = new String[6];
				assignments[0] = "{";
				assignments[1] = "int i;";
				assignments[2] = "for (i = 0; i < " + arraySize + "; i++) {";
				assignments[4] = "}";
				assignments[5] = "}";
				k = 3;
				index = "[i]";
			}
		}
		else {
			assignments = new String[1];
			index = "";
		}
		
		String type = var.getType();
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING")) {
			assignments[k] = "strcpy(" + dstPrefix + name + index + ", " + srcPrefix +
					name + index + ");";
		}
		else {
			assignments[k] = dstPrefix + name + index + " = " + srcPrefix + name + index + ";";
		}
		return assignments;
	}
	
	/**
	 * Creates an assignment string for the case where one of the variables in the 
	 * assignment is a raw buffer.
	 * @param data data type of the variable used in the assigment
	 * @param dstVar destination variable
	 * @param srcVar source variable
	 * @param sizeofChoice 0 if the length of bytes to be assigned is determined by the
	 * source variable; otherwise, any other value if it is to be determined by the 
	 * destnation variable
	 * @return The assignment string created
	 */
	private static String makeAssignment(DataType data, String dstVar, String srcVar, 
			byte sizeofChoice) {
		String type = data.getType();
		boolean array = type.equalsIgnoreCase("STRING") || 
				type.equalsIgnoreCase("WSTRING") || !data.getArraySize().isEmpty();
		StringBuilder assignment = new StringBuilder();
		
		if (sizeofChoice == 0) {
			// Sizeof assignment is determined by srvVar
			assignment.append("memmove(&" + dstVar + ", ");
			if (!array)
				assignment.append("&");
			assignment.append(srcVar + ", sizeof(" + srcVar + "));");
		}
		else {
			// Sizeof assignment is determined by dstVar
			assignment.append("memmove(");
			if (!array)
				assignment.append("&");
			assignment.append(dstVar + ", &" + srcVar + ", sizeof(" + dstVar + "));");
		}
		
		return assignment.toString();
	}

	/* Generates the code for a basic function block */
	protected void generateBasicFB(String fbName, boolean top) throws IOException {
		generateInterface(fbName, true, true);
		if (fb.getBasicFB() instanceof BasicHCECCFB) {
			formatHCECCStateTree(rootState); // Set childConditions for everything...
			stateIndex = 0;
			visited.clear();
			
			// TODO: NOTE:
			// HCECC relies on formatStateTree to set goto states JUST for the top ECC.
			// BUG: as a result however, states in top ECC will have duplicates of .childConditions...
		}

		formatStateTree(rootState);

		// Print out all procedure declarations
		if (procedures != null) {
			printer.print("/* ECC algorithms */");
			cprinter.print("/* ECC algorithms */");
			for (int i = 0; i < procedures.length; i++) {
				String proto = getPrototype(fbName, procedures[i]);
				printer.print(proto + ";");
				String comment = procedures[i].getComment();
				if (comment != null) {
					if (!comment.isEmpty())
						cprinter.print("/* " + comment + " */");
				}
				boolean noProto = (procedures[i].getPrototype() == null || procedures[i]
						.getPrototype().length() == 0);
				String algText = procedures[i].getText();
				if (algText != null && procedures[i].getLanguage().equalsIgnoreCase("ST")) {
					STFunctionsUsed = true;
					ByteArrayInputStream st = new ByteArrayInputStream(
							algText.getBytes());
					STtoC converter = new STtoC(st, true);
					algText = converter.getC();
					// TODO: ST will never have a prototype right?????
					// else convert that too...
				}
				if (algText != null) {
					algText.replaceAll("printf", "//printf");
				}
				if (noProto) {
					cprinter.print(proto);
					cprinter.print("{");
					if (algText != null)
						cprinter.print(algText);
					cprinter.print("}", 1);
				}
				else if (algText != null)
					cprinter.print(algText, 1);
			}
			printer.print("");
		}

		// Print out the function block execution function
		cprinter.print("/* Function block execution function */");
		cprinter.print("thread " + fbName + "run()");
		cprinter.print("{");
		cprinter.indent();
		if (insName.length() == 0) {		
			cprinter.print(fbName + "* me = top_var" + ";", 1);
		}else{
			cprinter.print(fbName + "* me = " + fb.getCompiledType() + "_var;", 1);
		}



		// Note: temp just to see how often we miss events due to simultaneous-ness
		// Counting bits set, Brian Kernighan's way

		/*
		 * cprinter.print(
		 * "unsigned int v = me->_input.events; // count the number of bits set in v"
		 * );
		 * cprinter.print("unsigned int c; // c accumulates the total bits set in v"
		 * ); cprinter.print("for (c = 0; v; c++)"); cprinter.print("{");
		 * cprinter
		 * .print("  v &= v - 1; // clear the least significant bit set");
		 * cprinter.print("}");
		 * 
		 * cprinter.print("if( c > 1 )"); cprinter.print(
		 * "    printf(\"**********WARNING MULTIPLE EVENTS PRESENT!!\\n\");",1);
		 */




		
		
		
		//hack start
		CodePrinter temp = cprinter;
		cprinter = printer;
		//if top level file and is a basic block then make network functions
		if (top) {
			cprinter.println("void "+fbName+"_networkInput() {");
			cprinter.println("//insert input code");
			cprinter.println("}");
		}else{ //else a prototype is needed only
			cprinter.println("void "+fbName+"_networkInput();");
		}
		cprinter.println("void "+fbName+"_UpdateInputAssoc("+fbName + "* me) {");
		cprinter.indent();
		cprinter.print(fbName+"_networkInput();");
		

		
		// Update all input event-data associations
		if (inputData != null && inputEvents != null) {
			if (inputData.length > 0) {
				if (inputEvents.length > 1) {
					if (ieArrayLen < 2)
						cprinter.print("if (me->_input.events) {");
					else {
						StringBuilder buf = new StringBuilder("if (");
						int l = 0;
						for (;;) {
							buf.append("me->_input.events["
									+ Integer.toString(l) + "]");
							l++;
							if (l >= ieArrayLen)
								break;
							buf.append(" || ");
						}
						buf.append(") {");
						cprinter.print(buf.toString());
					}
					cprinter.indent();
				}
				for (int i = 0; i < inputEvents.length; i++) {
					if (inputEvents[i].withVar != null) {
						cprinter.print("if (me->_input.event."
								+ inputEvents[i].getName() + ") {");
						cprinter.indent();

						for (int j = 0; j < inputEvents[i].withVar.length; j++) {
							VarDeclaration var = inputEvents[i].withVar[j];
							if (var == null) {
								OutputManager.printNotice(insName,
										inputEvents[i].getName() + " is missing a withVar",
										OutputLevel.WARNING);
								continue;
							}

							String[] assignments = makeAssignment(var, "me->", "me->_");
							for (String assign : assignments)
								cprinter.smartPrint(assign);
						}
						cprinter.unindent();
						cprinter.print("}");
					}
				}
				if (inputEvents.length > 1) {
					cprinter.unindent();
					cprinter.print("}");
				}
			}
		}
		
		cprinter.unindent();
		cprinter.println("}");
		cprinter = temp;
		
		//hack end
		
		int numOfStates = gotoStates.size();
		
		//Generate ECC and HCECC states
		//reset output to zero
		if (oeArrayLen == 1)
			cprinter.print("me->_output.events = 0;", 1);
		else {
			for (int i = 0; i < oeArrayLen; i++)
				cprinter.print("me->_output.events[" + Integer.toString(i)
						+ "] = 0;");
			cprinter.print("");
		}
		cprinter.println(fbName+"_UpdateInputAssoc(me);"); 
		for (int i = 0; i < numOfStates; i++) {
			cprinter.print("asm(\"nop\");");
			cprinter.print(fbName + "_"+ gotoStates.get(i).getName() + ":"); 
			cprinter.indent();
			statePrefix = fbName;
			currentFbName = fbName;
			printState(gotoStates.get(i), numOfStates);
			cprinter.print("//-------");
			cprinter.unindent();
		}

		
		// Update all output event-data associations
		//hack start
		
		temp = cprinter;
		cprinter = printer;
		
		//if top level and basic fb then function need to be provided
		if (top) {
			cprinter.println("void "+fbName+"_networkOutput() {");
			cprinter.println("//insert output code");
			cprinter.println("}");
		}else{ //prototype need only
			cprinter.println("void "+fbName+"_networkOutput();");
		}
		cprinter.println("void "+fbName+"_UpdateOutputAssoc("+fbName + "* me) {");
		cprinter.indent();
		
		
		if (outputEvents != null) {
			for (int i = 0; i < outputEvents.length; i++) {
				if (outputEvents[i].withVar != null) {
					cprinter.print("if (me->_output.event." + 
							outputEvents[i].getName() + ") {");
					cprinter.indent();



					for (int j = 0; j < outputEvents[i].withVar.length; j++) {
						VarDeclaration var = outputEvents[i].withVar[j];
						String[] assignments = makeAssignment(var, "me->_", "me->");
						for (String assign : assignments)
							cprinter.smartPrint(assign);
					}
					cprinter.unindent();
					cprinter.print("}");
				} 
			}
			cprinter.println();
		}

		


		cprinter.println(fbName+"_networkOutput();");
		cprinter.unindent();
		cprinter.println("}");
		
		cprinter = temp;
		//hack end
		
		cprinter.unindent();
		cprinter.print("}", 1);
		

		cprinter.print(sprinter.getTempBuffer());
		
		//if top and is basicfb need to provide main
		
		if (top) {
			cprinter.print(fbName + " _var;");
			if (FBtoStrl.startUpFile.length() > 0) {
				try {
					File CfileFILE = new File(FBtoStrl.startUpFile);
					InputStream inputStream = new FileInputStream(CfileFILE);
					BufferedReader Cfile = new BufferedReader(new InputStreamReader(inputStream));
					String line = Cfile.readLine();
					for(;;line = Cfile.readLine()) {
						if (line == null) {
							break;
						}
						cprinter.print(line);
					}
					Cfile.close();
				}catch(IOException e){
					e.printStackTrace();
					System.out.println("Startup file open error:" + e);
				}
			}
			cprinter.print("int main(int argc, char* argv[])");
			if (FBtoStrl.startUpFile.length() > 0) {
				cprinter.print("startup();\n");
			}
			cprinter.print("{");
			cprinter.indent();
			cprinter.print("top_var = &_var;");
			cprinter.print("memset(&_var, 0, sizeof(" + fbName + "));");

			cprinter.print(fbName + "init(&_var);", 1);
			cprinter.print("for (;;) {");
			cprinter.indent();
			if (ieArrayLen == 1)
				cprinter.print("_var._input.events = 0;");
			else {
				for (int i = 0; i < ieArrayLen; i++) {
					cprinter.print("_var._input.events["
							+ Integer.toString(i) + "] = 0;");
				}
			}
			cprinter.print("PAR("+fbName + "run,void);");


			cprinter.unindent();
			cprinter.print("}", 1);
			cprinter.print("return 0;");

			cprinter.unindent();
			cprinter.print("}");
			cprinter.indent();
		}
		
		
		
		
	}

	/**
	 * Creates additional initialization arguments for service interface function
	 * blocks with global variables.
	 * @param ins function block instance
	 * @return String containing the additional initialization arguments.
	 */
	private String getExtraInitArgs(Instance ins) {
		GlobalVar global = ins.getGlobalVarForSIFB();
		if (global == null)
			return "";
		
		if (ins.getType().startsWith("SENDuCOS_")) {
			return ", " + global.getWriteMethod().getName() + ", " + 
					global.getWriteNullMethod().getName();
		}
		else if (ins.getType().startsWith("RECVuCOS_"))
			return ", " + global.getReadMethod().getName();
		else if (ins.getType().startsWith("PUBL_") || ins.getType().startsWith("SUBL_"))
			return ", &" + global.getRawTypeName();
		else
			return "";
	}

	/**
	 * Generates code for Structured Data types
	 * @param name
	 * 		- type name
	 * @param vars
	 * 		- variable in struct
	 * @throws IOException 
	 */
	public static void generateDataType(String name, VarDeclaration[] vars) throws IOException
	{
		CodePrinter dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".h");
		dprinter.print("// This file is generated by FBC.", 1);
		String def = makeHeaderMacro(name);
		dprinter.println("#ifndef " + def);
		dprinter.println("#define " + def);
		dprinter.println();
		dprinter.print("#include \"fbtypes.h\"", 1);
		dprinter.println("typedef struct {");
		dprinter.indent();
		if( vars != null )
		for(int v = 0; v < vars.length; v++)
		{
			String[] declaration = makeDeclaration(new VarType(Category.INTERNAL, vars[v]), "");
			for(String dec : declaration)
				if( dec != null )
					dprinter.println( dec );
		}
		dprinter.unindent();
		dprinter.println("} " + name + ";");
		
		// declare to / from string functions
		dprinter.println();
		dprinter.println("int "+name+"toString(char* str, "+name+"* value);");
		dprinter.println("bool valueOf"+name+"("+name+"* value, char* str);");
		dprinter.println();
		
		dprinter.println("#endif // " + def);
		dprinter.close();
		
		// DEFINE UDT to/from string functions
		dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".c");
		dprinter.println("#include \""+name+".h\"");
		dprinter.println("#include \"datatypes.h\"");
		dprinter.println();
		dprinter.println("int "+name+"toString(char* str, "+name+"* value){");
		dprinter.indent();
			dprinter.println("int offset = 0, sublength;");
			dprinter.print("str[offset++] = '{';");
			if( vars != null )
			for(int v = 0; v < vars.length; v++)
			{
				if( vars[v].getArrayLength() > 1 )
				{
					dprinter.print("str[offset++] = '[';");
					for(int index = 0; index < vars[v].getArrayLength(); index++)
					{
						dprinter.println("sublength = "+vars[v].getType()+"toString(str+offset,&(value->"+vars[v].getName()+"["+index+"]));");
						dprinter.println("offset += sublength;");
						if( index < (vars[v].getArrayLength()-1) )
							dprinter.print("str[offset++] = ',';");
					}
					dprinter.print("str[offset++] = ']';");
				}
				else
				{
					dprinter.println("sublength = "+vars[v].getType()+"toString(str+offset, &value->"+vars[v].getName()+");");
					dprinter.println("offset += sublength;");
				}
				if( v < (vars.length-1) )
					dprinter.print("str[offset++] = ',';");
			}
			dprinter.print("str[offset++] = '}';");
			dprinter.println("return offset; // i.e. Length");
		dprinter.unindent();
		dprinter.println("}");
		dprinter.println();
		dprinter.println("bool valueOf"+name+"("+name+"* value, char* str){");
		dprinter.indent();
			dprinter.println("bool success;");
			dprinter.println("char* substrofStr = str;");
			if( vars != null )
			for(int v = 0; v < vars.length; v++)
			{
				if( vars[v].getArrayLength() > 1 )
				{
					// TODO:
					dprinter.println("return FALSE;");
				}
				else
				{
					dprinter.println("success = valueOf"+vars[v].getType()+"(&value->"+vars[v].getName()+", substrofStr);");
					dprinter.println("if( !success ) return FALSE;");
				}
			}
			dprinter.println("return TRUE;");
		dprinter.unindent();
		dprinter.println("}");
		dprinter.close();
	}
	
	/**
	 * Generates code for Enumerated Data types
	 * @param name
	 * 		- type name
	 * @param values
	 * 		- valuesin enum
	 * @throws IOException 
	 */
	public static void generateDataType(String name, EnumeratedValue[] values) throws IOException
	{
		CodePrinter dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".h");
		dprinter.println("// This file is generated by FBC.");
		String def = makeHeaderMacro(name);
		dprinter.println("#ifndef " + def);
		dprinter.println("#define " + def);
		dprinter.println();
		dprinter.println("typedef enum {");
		dprinter.indent();
		if( values != null )
		for(int v = 0; v < values.length; v++)
		{
			dprinter.println( values[v].getName() + (v<(values.length-1)?",":""));
		}
		dprinter.unindent();
		dprinter.println("} "+name+";");
		dprinter.println("#endif // " + def);
		dprinter.close();
	}
	
	
	
	/**
	 * Generates the function block's interface related code if( simulation )
	 * creates the block's own "Instance" node me->_simdata;
	 * 
	 * @param fbName
	 *            - name of the function block type
	 * @param c
	 *            - true if definition file is to be generated; otherwise false
	 * @param basic
	 *            - true if interface to be generated is for a basic FB
	 */
	protected void generateInterface(String fbName, boolean c, boolean basic)
			throws IOException {
		int vectorSize = getNumOfIEvents() * 2;

		if (c) {
			cprinter.print("/* Function block initialization function */");
			cprinter.print("void " + fbName + "init(" + fbName + "* me)");
			cprinter.print("{");
			cprinter.indent();
			if (rootState != null) {
				if (fb.getNumOfECStates() > 1)
					cprinter.print("me->_" + statePrefix + "state = 0;");
				cprinter.print("//me->_" + statePrefix + "entered = false;");
			}
			if (ieArrayLen == 1)
				cprinter.print("me->_input.events = 0;");
			else {
				for (int i = 0; i < ieArrayLen; i++)
					cprinter.print("me->_input.events[" + Integer.toString(i)
							+ "] = 0;");
			}
			if (oeArrayLen == 1)
				cprinter.print("me->_output.events = 0;");
			else {
				for (int i = 0; i < oeArrayLen; i++)
					cprinter.print("me->_output.events[" + Integer.toString(i)
							+ "] = 0;");
			}

		}

		if (ieArrayLen > 0) {
			printer.print("typedef union {");
			printer.indent();
			if (ieArrayLen == 1)
				printer.print("UDINT events;");
			else
				printer.print("UDINT events["
						+ Integer.toString(ieArrayLen) + "];");
			printer.print("struct {");
			printer.indent();

			// Print out all input event declarations
			if (inputEvents != null) {
				for (int i = 0; i < inputEvents.length; i++) {
					String buf = "UDINT " + inputEvents[i].getName()
							+ " : 1;";
					if (inputEvents[i].getComment() != null)
						buf = buf + " // " + inputEvents[i].getComment();
					printer.print(buf);
				}
			}
			printer.unindent();
			printer.print("} event;");
			printer.unindent();
			printer.print("} " + fbName + "IEvents;", 1);
		}

		// Print out all output event declarations
		if (outputEvents != null) {
			printer.print("typedef union {");
			printer.indent();
			if (oeArrayLen == 1)
				printer.print("UDINT events;");
			else
				printer.print("UDINT events["
						+ Integer.toString(oeArrayLen) + "];");
			printer.print("struct {");
			printer.indent();
			for (int i = 0; i < outputEvents.length; i++) {
				String buf = "UDINT " + outputEvents[i].getName()
						+ " : 1;";
				if (outputEvents[i].getComment() != null)
					buf = buf + " // " + outputEvents[i].getComment();
				printer.print(buf);
			}
			printer.unindent();
			printer.print("} event;");
			printer.unindent();
			printer.print("} " + fbName + "OEvents;", 1);
		}

		String comment = fb.getComment();
		if (comment != null) {
			if (!comment.isEmpty())
				printer.print("/* " + comment + " */");
		}
		printer.print("typedef struct {");
		printer.indent();
		if (basic) {
			if (fb.getBasicFB() instanceof BasicHCECCFB) {
				BasicHCECCFB hceccfb = (BasicHCECCFB) fb.getBasicFB();
				LinkedList<String> eccNames = new LinkedList<String>();
				hceccfb.getHCECC().getECCNames(eccNames);
				for (String eccName : eccNames)
				{
					printer.print("UINT _" + eccName + "state;");
					printer.print("//BOOL _" + eccName + "entered;");
				}
			}
			// ROOT ecc uses these... even though PERHAPS they should be using
			// _"ecc.name"state
			if (fb.getNumOfECStates() > 1)
				printer.print("UINT _" + statePrefix + "state;");
			printer.print("//BOOL _" + statePrefix + "entered;");
		}
		if (rprinter != null) {
			rprinter.print("typedef struct {");
			rprinter.indent();
		}


		if (ieArrayLen > 0) {
			printer.print(fbName + "IEvents _input;");
			if (rprinter != null)
				rprinter.print(fbName + "IEvents _input;");

		}
		
		String blockID = fullyQualifiedInsName.isEmpty() ? fbName : fullyQualifiedInsName;

		// Print out all input data declarations and their internal registers
		if (inputData != null) {
			for (int i = 0; i < inputData.length; i++) {
				String[] str = makeDeclaration(inputData[i], blockID);
				for (int j = 0; j < str.length; j++) {
					if (!basic)
						j = 1;
					assert (str[j] != null) : "Cannot make input data declaration.\n";
					printer.print(str[j]);
				}
				if (rprinter != null)
					rprinter.print(str[1]);
				if (c) {
					byte iface = basic ? (byte)0x03 : (byte)0x02;
					str = makeInitialization(inputData[i], "me->", iface, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
			vectorSize += (inputData.length * 16);
		}

		if (oeArrayLen > 0) {
			printer.print(fbName + "OEvents _output;");
			if (rprinter != null)
				rprinter.print(fbName + "OEvents _output;");;
		}

		// Print out all output data declarations and their internal registers
		if (outputData != null) {
			for (int i = 0; i < outputData.length; i++) {
				String[] str = makeDeclaration(outputData[i], blockID);
				for (int j = 0; j < str.length; j++) {
					if (!basic)
						j = 1;
					assert (str[j] != null) : "Cannot make output data declaration.\n";
					printer.print(str[j]);
				}
				if (rprinter != null)
					rprinter.print(str[1]);
				if (c) {
					byte iface = basic ? (byte)0x03 : (byte)0x02;
					str = makeInitialization(outputData[i], "me->", iface, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
		}

		// Print out all internal variable declarations
		if (internalVars != null) {
			for (int i = 0; i < internalVars.length; i++) {
				String[] str = makeDeclaration(internalVars[i], blockID);
				assert (str[0] != null) : "Cannot make internal variable declaration.\n";
				printer.print(str[0]);

				if (c) {
					str = makeInitialization(internalVars[i], "me->", (byte)0x01, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
		}
		
		/* Kyle: 
		// Print out all method reference declarations
		if (methodReferences != null) {
			for (int i = 0; i < methodReferences.length; i++) {
				String buf = "void* " + methodReferences[i].getName() + ";";
				printer.print(buf);
			}
		}
		*/

		// Print out all sub-blocks
		if (!basic) {
			for (int i = 0; i < runs.length; i++) {
				if (!isLocalComBlock(runs[i].getType()))
					printer.print(runs[i].getType() + " " + runs[i].name + ";");
			}

		}



		printer.unindent();
		printer.print("} " + fbName + ";", 1);
		if (rprinter != null) {
			rprinter.unindent();
			rprinter.print("} " + fbName + "Reg;", 1);
		}

		if (c) {
			if (!basic) {
				//global variables for threads
				for (int i = 0; i < sortedNodes.length; i++) {
					Instance instance = getInstance(sortedNodes[i].getInstance());
					String insName = instance.name;
					String insType = instance.getType();
					
					
					printer.println(insType+"* " + insType+"_var;");
					cprinter.println(insType + "_var = &(me->"+insName+");");
				}
				cprinter.println();
				for (int i = 0; i < runs.length; i++) {
					if (!isLocalComBlock(runs[i].getType())
							&& !runs[i].getType().endsWith("_HMI")
							&& !runs[i].isPlug() && !runs[i].isSocket()) {
						// HMI Blocks inited in main function
						cprinter.print(runs[i].getType() + "init(&me->" + runs[i].name + 
								getExtraInitArgs(runs[i]) + ");");
					}
				}
				// NOW Print Params
				// Print out all Parameter initialisations
				for (int i = 0; i < runs.length; i++) {
					Set<Signal> signals = runs[i].getSignalSet();
					Iterator<Signal> j = signals.iterator();
					while (j.hasNext()) {
						Signal sig = j.next();
						if (sig.getSigType() == null) // is an event... PASS
							continue;
						if (sig.getPortType() != PortType.INPUT)
							continue;
						HashSet<Signal> bindings = runs[i].getBindings(sig);
						if (bindings.size() < 1)
							continue;
						Signal bind = bindings.iterator().next();
						
						// Print only the input ports that are attached to parameters
						if (bind.getPortType() != PortType.PARAM)
							continue;
						
						// Need special handling when compiling local communication blocks, 
						// since their parameters may have special meaning
						String type = runs[i].getType();
						if (type.startsWith("PUBL_") || type.startsWith("SUBL_")) {
							if (sig.getSignal().equals("ID"))
								continue;
						}
						else {
							printInputAssignments(runs[i], sig, bindings.iterator().next());
						}
					}
				}
				
				/* Kyle:
				// Print method connections
				HashMap<Signal, Signal> directMethodConnections = fb.compositeFB.getDirectMethodConnections();
				for (Signal src : directMethodConnections.keySet()) {
					String buf = "me->" + src.toString() + " = &(me->" + directMethodConnections.get(src).toString() +");";
					cprinter.print(buf);
				}
				*/
			}
			cprinter.unindent();
			cprinter.print("}", 1);
		}

		printer.print("/* Function block initialization function */");
		printer.print("void " + fbName + "init(" + fbName + "* me);", 1);

		printer.print("/* Function block execution function */");

		//printer.print("void " + fbName + "run(void);", 1);
		if (insName.length() == 0) {
			printer.print(/*"extern " +*/ fbName + "* " + "top_var" + ";", 1);
		}else{
			printer.print(/*"extern " +*/ fbName + "* " + fb.getCompiledType() + "_var;", 1);
		}


		if (rprinter != null) {

			rprinter.print(fbName + "Reg _sysInterface;");
			rprinter.print(fbName + " _var;");
			//rprinter.print(fbName + "* top_var;");
			if (FBtoStrl.startUpFile.length() > 0) {
				try {
					File CfileFILE = new File(FBtoStrl.startUpFile);
					InputStream inputStream = new FileInputStream(CfileFILE);
					BufferedReader Cfile = new BufferedReader(new InputStreamReader(inputStream));
					String line = Cfile.readLine();
					for(;;line = Cfile.readLine()) {
						if (line == null) {
							break;
						}
						rprinter.print(line);
					}
					Cfile.close();
				}catch(IOException e){
					e.printStackTrace();
					System.out.println("Startup file open error:" + e);
				}
			}
			rprinter.print("int main(int argc, char* argv[])");
			rprinter.print("{");
			rprinter.indent();
			if (FBtoStrl.startUpFile.length() > 0) {
				rprinter.print("startup();\n");
			}
			rprinter.print("top_var = &_var;");
			
			





			rprinter.print("memset(&_sysInterface, 0, sizeof(" + fbName + "Reg));");
			rprinter.print("memset(&_var, 0, sizeof(" + fbName + "));");
			if (inputData != null) {
				for (int i = 0; i < inputData.length; i++) {
					String[] str = makeInitialization(inputData[i], "_sysInterface.", 
							(byte)0x02, fullyQualifiedInsName);
					for (String s : str)
						rprinter.print(s);
				}
			}

			rprinter.print(fbName + "init(&_var);", 1);

			/*if (fb.inputEvents != null
					&& fb.inputEvents[0].getName().equalsIgnoreCase("INIT")) {
				// Force initing
				rprinter.print(fbName + "run();", 0);
				rprinter.print(
						"_var._input.event." + fb.inputEvents[0].getName() + " = 1;", 0);
				rprinter.print(fbName + "run();", 0);
				rprinter.print("_var._input.event." + fb.inputEvents[0].getName() + " = 0;", 0);
			}*/

			rprinter.flushBuf();


			rprinter.print("for (;;) {");
			rprinter.indent();


			if (ieArrayLen == 1)
				rprinter.print("_var._input.events = 0;");
			else {
				for (int i = 0; i < ieArrayLen; i++) {
					rprinter.print("_var._input.events["
							+ Integer.toString(i) + "] = 0;");
				}
			}
			



			rprinter.print("PAR("+fbName + "run,void);");




			rprinter.unindent();
			rprinter.print("}", 1);


			rprinter.print("return 0;");
			

			rprinter.unindent();
			rprinter.print("}");
			rprinter.indent();
			

		}


	}

	/* Create a prototype testbench */
	protected void makeTestbench() throws IOException {
		// Assign all input events
		if (inputEvents != null) {
			for (int i = 0; i < inputEvents.length; i++)
				makeTestbenchEvent(inputEvents[i].getName());
		}

		// Print out all input data declarations and their internal registers
		if (inputData != null) {
			String variable = opts.isSorted() ? "_var._" : "_sysInterface._";
			for (int i = 0; i < inputData.length; i++) {
				// TODO: Handle Array
				if (inputData[i].getArraySize() != null
						&& inputData[i].getArraySize().length() > 0
						&& Integer.valueOf(inputData[i].getArraySize()) > 0)
					continue; // SKIP (FOR NOW)
				rprinter.print(variable + inputData[i].getName()
						+ " = strtol(token, NULL, 0);");
				rprinter.print("token = strtok(NULL, \" \");");
			}
		}
	}

	/**
	 * Create the statement for setting an event in the testbench
	 * @param event event to be set
	 */
	protected void makeTestbenchEvent(String event) throws IOException {
		rprinter.print("if (*token == \'1\') {");
		rprinter.indent();

		rprinter.print("_var._input.event." + event + " = 1;");

		rprinter.unindent();
		rprinter.print("}");
		rprinter.print("token = strtok(NULL, \" \");");
	}

	/**
	 * Create the declaration for the variable.
	 * @param var variable to declare
	 * @return String(s) used for the declaration of the variable
	 */
	protected static String[] makeDeclaration(VarType var, String blockID) {
		String varName = var.getName();
		String varType = var.getType();
		if (varType.equalsIgnoreCase("ANY")) {
			// Data type is still of type ANY. This means that the port is not bound:
			// Default unbound ANY port to BOOL.
			varType = "BOOL";
		}
		
		String array = getArrayIndex(var.getArraySize(), blockID, varName);
		String[] decl = new String[2];
		StringBuilder tmp = new StringBuilder(varType + " " + varName + array + ";");
		String comment = var.getComment();
		if (comment != null)
			tmp.append(" // " + comment);
		decl[0] = tmp.toString();

		if (var.isCategory(Category.IFACE_IN) || var.isCategory(Category.IFACE_OUT))
			decl[1] = varType + " _" + varName + array + ";";
		
		return decl;
	}

	/**
	 * Create the initialization for the variable.
	 * @param var variable to initialize 
	 * @param prefix prefix to the variable 
	 * @param iface 1 to create internal initialization; 2 to create external initialization;
	 * 3 to create internal and external initialization
	 * @param fqInsName fully qualified instance name
	 * @return String(s) used for the initialization of the variable
	 */
	public static String[] makeInitialization(VarType var, String prefix, byte iface, 
			String fqInsName) {
		String initial = var.getInitial();
		if (initial != null) {
			String type = var.getType();
			String name = var.getName();
			ArrayList<String> init = new ArrayList<String>();
			String arraySize = var.getArraySize();
			if (!arraySize.isEmpty()) {
				int size = validateArraySize(arraySize);
				if (size <= 0) {
					OutputManager.printError(fqInsName, "Variable `" + name + 
							"' has an invalid array size.", OutputLevel.FATAL);
					System.exit(0);
				}
				String[] tokens = parseArrayInitializer(initial, type, name, fqInsName);		
				if (tokens.length > size) {
					OutputManager.printError(fqInsName, "Variable `" + name + 
							"' has an invalid array initializer.", OutputLevel.FATAL);
					System.exit(0);
				}
				for (int i = 0; i < tokens.length; i++) {
					if (tokens[i].equals(""))
						continue;
					String index = "[" + i + "]";
					addInitString( init, var, prefix, iface, index, parseScalarParam(type, 
							tokens[i]) );
				}
			}
			else {
				addInitString( init, var, prefix, iface, "", parseScalarParam(type, 
						parseScalarInitializer(initial, type, name)) );
			}
			
			return init.toArray(new String[0]);
		}
		return new String[0];
	}

	/**
	 * Parses and tokenizes parameters to facilitate variable initialization.
	 * @param type variable type
	 * @param name variable name
	 * @param param parameter value
	 * @param array TRUE if parameter is an array; FALSE otherwise
	 * @return List containing the tokenized parameters.
	 */
	protected String[] parseParam(String type, String name, String param, boolean array) {  
		if (array) {
			ArrayList<String> tokens = new ArrayList<String>();
			String[] inits = parseArrayInitializer(param, type, name, fullyQualifiedInsName);
			for (String init : inits) {
				if (init.equals(""))
					continue;
				tokens.add(parseScalarParam(type, init));
			}
			return tokens.toArray(new String[0]);
		}
		else {
			String tokens[] = new String[1];
			tokens[0] = parseScalarParam( type, parseScalarInitializer(param, type, name) );
			return tokens;
		}
	}
	
	/**
	 * Parses a scalar initializer.
	 * @param initial string containing the initialization value
	 * @param varType type of variable to be initialized
	 * @param varName name of variable to be initialized
	 * @return The parsed initialization value
	 */
	public static String parseScalarInitializer(String initial, String varType, String varName) {
		initial = initial.trim();
		if (varType.equalsIgnoreCase("STRING"))
			return getStringInitializers(initial, '\'', varName)[0];
		else if (varType.equalsIgnoreCase("WSTRING"))
			return getStringInitializers(initial, '\"', varName)[0];
		else
			return initial;
	}
	
	/**
	 * Parses an array initializer.
	 * @param initial string containing the initialization value
	 * @param varType type of variable to be initialized
	 * @param varName name of variable to be initialized
	 * @param fqInsName fully qualified instance name
	 * @return The list of initialization values for the array
	 */
	public static String[] parseArrayInitializer(String initial, String varType, 
			String varName, String fqInsName) {
		initial = initial.trim();
		if (initial.charAt(0) != '[') {
			OutputManager.printError(fqInsName, "Initialization of array `" + varName + 
					"\' is missing `[\'.", OutputLevel.FATAL);
			System.exit(0);
		}
		
		int lastChar = initial.length() - 1;
		if (initial.charAt(lastChar) != ']') {
			OutputManager.printError(fqInsName, "Initialization of array `" + varName + 
					"\' is missing `]\'.", OutputLevel.FATAL);
			System.exit(0);
		}
		initial = initial.substring(1, lastChar).trim();
		
		String[] tokens;
		if (varType.equalsIgnoreCase("STRING"))
			tokens = getStringInitializers(initial, '\'', varName);
		else if (varType.equalsIgnoreCase("WSTRING"))
			tokens = getStringInitializers(initial, '\"', varName);
		else
			tokens = initial.split("[\\,\\s]");
		
		ArrayList<String> usefulTokens = new ArrayList<String>(tokens.length);
		for (String token : tokens) {
			if ( !token.trim().isEmpty() )
				usefulTokens.add(token);
		}
		
		return usefulTokens.toArray(new String[0]);
	}
	
	/**
	 * Makes and adds a string to the list of initialization strings
	 * @param init list containing initialization strings
	 * @param var variable to initialize 
	 * @param prefix prefix to the variable 
	 * @param iface 1 to create internal initialization; 2 to create external initialization;
	 * 3 to create internal and external initialization
	 * @param index array index if 'var' is an array type
	 * @param initial initial value
	 */
	private static void addInitString(ArrayList<String> init, VarType var, String prefix, 
			byte iface, String index, String initial) {
		String type = var.getType();
		boolean isString = type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING");
		if ((iface & 0x01) == 0x01) {
			if (isString)
				init.add("strcpy(" + prefix + var.getName() + index + ", " + initial + ");");
			else
				init.add(prefix + var.getName() + index + " = " + initial + ";");
		}
		if ((iface & 0x02) == 0x02) {
			if (var.isCategory(Category.IFACE_IN)  
					|| var.isCategory(Category.IFACE_OUT)) {
				if (isString) {
					init.add("strcpy(" + prefix + "_" + var.getName() + index + ", " + 
							initial + ");");
				}
				else
					init.add(prefix + "_" + var.getName() + index + " = " + initial + ";");
			}
		}
	}
	
	/**
	 * Makes and adds a string to the list of initialization strings
	 * @param inits list containing initialization strings
	 * @param type type of variable to be initialized
	 * @param dst variable to be initialized
	 * @param index array index if variable is an array type
	 * @param initial initial value
	 */
	private static void addInitString(ArrayList<String> inits, String type, String dst, 
			String index, String initial) {
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			inits.add("strcpy(" + dst + index + ", " + initial + ");");
		else
			inits.add(dst + index + " = " + initial + ";");
	}
	
	/**
	 * This parses and tokenizes an array of strings given as an initial value.
	 * @param initial initialization value
	 * @param delimiter string delimiter
	 * @param varName name of the string variable
	 * @return An array containing all the initial values for C strings.
	 */
	public static String[] getStringInitializers(String initial, char delimiter, String varName) {
		if (initial.charAt(0) != delimiter || initial.charAt(initial.length()-1) != delimiter) {
			OutputManager.printError("", "Expecting `" + delimiter + 
					"\' at the beginning and end of the initialization for " + varName + 
					".", OutputLevel.FATAL);
			System.exit(0);
		}
		
		ArrayList<String> tokens = new ArrayList<String>();
		StringBuilder token = new StringBuilder();
		boolean inString = false;
		boolean escape = false;
		int length = initial.length();
		for (int i = 0; i < length; i++) {
			char character = initial.charAt(i);
			if (!inString) {
				if (character == delimiter) {
					token.append('"');	// convert to C-style string literal
					inString = true;
				}
				else {
					// We gobble up all commas and whitespace (and any other characters!) 
					// here.
				}
			}
			else {
				if (!escape) {
					if (character == '$') {
						escape = true;
					}
					else {
						if (delimiter == '\'' && character == '"')
							token.append("\\\"");
						else if (character == delimiter) {
							token.append('"');	// convert to C-style string literal
							tokens.add(token.toString());
							token.delete(0, token.length());
							inString = false;
						}
						else
							token.append(character);
					}
				}
				else {
					switch (character) {
						case '\'':
						case '"':
							token.append('\\');
							token.append(character);
							break;
						case '$':
							token.append('$');
							break;
						case 'L':
						case 'l':
						case 'N':
						case 'n':
							// $N and $n is IEC 61131's means for specifying an 
							// implementation-independent newline character. Since there
							// is no such thing in C, we simply map it to the line feed.
							token.append("\\n");
							break;
						case 'P':
						case 'p':
							token.append("\\f");
							break;
						case 'R':
						case 'r':
							token.append("\\r");
							break;
						case 'T':
						case 't':
							token.append("\\t");
							break;
						default:
							// Skip everything else! This is not actually correct, but
							// ignore for now.
							break;
					}
					escape = false;
				}				
			}
		}
		
		// Check if the last element in the array initializer has been properly terminated
		if (inString) {
			OutputManager.printError("", "Expecting `" + delimiter + 
					"\' at the end of the initialization for " + varName + ".", 
					OutputLevel.FATAL);
			System.exit(0);
		}
		
		return tokens.toArray(new String[0]);
	}

	/**
	 * Converts values entered as text in the simulator to C-type values based 
	 * on the ST data types declared in the function block description. If a 
	 * user-type is defined, a custom conversion function must be supplied by 
	 * the user in order for the simulator to compile. 
	 * @param type the data type to be matched
	 * @return The C conversion function
	 */
	public static String getIConversionFunc(String type) {
		if (type.equalsIgnoreCase("BOOL")) {
			return "(strcasecmp(c, \"false\") && strcmp(c, \"0\"));";
		} else if (type.equalsIgnoreCase("SINT")
				|| type.equalsIgnoreCase("INT")
				|| type.equalsIgnoreCase("DINT")) {
			return "strtol(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("USINT")
				|| type.equalsIgnoreCase("UINT")
				|| type.equalsIgnoreCase("UDINT")
				|| type.equalsIgnoreCase("BYTE")
				|| type.equalsIgnoreCase("WORD")
				|| type.equalsIgnoreCase("DWORD")) {
			return "strtoul(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("LINT")) {
			return "strtoll(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("ULINT")
				|| type.equalsIgnoreCase("LWORD")) {
			return "strtoull(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("REAL")) {
			return "strtof(c, NULL);";
		} else if (type.equalsIgnoreCase("LREAL")) {
			return "strtod(c, NULL);";
		} else if (type.equalsIgnoreCase("STRING")) {
			return "c";
		} else {
			return "CUSTOM_INPUT_FUNCTION(c);"; // user-defined type
		}
	}

	/**
	 * Converts output data of some ST data type to be displayed as text by the 
	 * simulator. If a user-type is defined, a custom conversion function must 
	 * be supplied by the user in order for the simulator to compile.
	 * @param type the data type to be matched 
	 * @param var the variable to display in textual form 
	 * @param text the textbox used for display 
	 * @return The function to display the text.
	 */
	public static String getOConversionFunc(String type, String var, String text) {
		if (type.equalsIgnoreCase("BOOL")) {
			return (var + " ? " + text + "(QString(\"true\")) : " + text + "(QString(\"false\"));");
		} else if (type.equalsIgnoreCase("SINT")
				|| type.equalsIgnoreCase("INT")
				|| type.equalsIgnoreCase("DINT")) {
			return (text + "(QString(\"%1\").arg((int)" + var + "));");
		} else if (type.equalsIgnoreCase("USINT")
				|| type.equalsIgnoreCase("UINT")
				|| type.equalsIgnoreCase("UDINT")
				|| type.equalsIgnoreCase("BYTE")
				|| type.equalsIgnoreCase("WORD")
				|| type.equalsIgnoreCase("DWORD")) {
			return (text + "(QString(\"%1\").arg((unsigned int)" + var + "));");
		} else if (type.equalsIgnoreCase("LINT")) {
			return (text + "(QString(\"%1\").arg((long long)" + var + "));");
		} else if (type.equalsIgnoreCase("ULINT")
				|| type.equalsIgnoreCase("LWORD")) {
			return (text + "(QString(\"%1\").arg((unsigned long long)" + var + "));");
		} else if (type.equalsIgnoreCase("REAL")
				|| type.equalsIgnoreCase("LREAL")) {
			return (text + "(QString(\"%1\").arg(" + var + ", 0, \'f\'));");
		} else if (type.equalsIgnoreCase("STRING")) {
			return (text + "(QString(" + var + "));");
		} else {
			// User-defined type
			return (text + "(QString(CUSTOM_OUTPUT_FUNCTION(" + var + ")));");
		}
	}

	/**
	 * Create the string for the procedure prototype.
	 * @param fbName name of the function block type 
	 * @param proc procedure to be declared 
	 * @return String containing the prototype for the procedure.
	 */
	protected static String getPrototype(String fbName, Procedure proc) {
		String proto = proc.getPrototype();

		if (proto == null || proto.length() == 0) {
			return ("void " + proc.getFullName() + "(" + fbName + "* me)");
		}
		return proto;
	}

	/**
	 * Prints out the code for each synchronous state.
	 * @param state the state currently being visited 
	 * @param numOfStates total number states for the ECC
	 */
	protected void printState(SyncState state, int numOfStates)
			throws IOException {
		cprinter.print("// State: " + state.getName());
		cprinter.print("//Entered");
		// Print out the action for this state
		printActions(state.actions /*Kyle: , false*/);

		// Set embedded things to entered = false;
		// And reset state #
		//mkuo005 bookmark HCECC not needed
		/*if (state.refiningECCName != null) {
			cprinter.print("//me->_" + state.refiningECCName + "entered = false;");
			cprinter.print("me->_" + state.refiningECCName + "state = 0;");
		}
		if (state.parallel != null) {
			for (Entry<String, SyncState[]> entry : state.parallel.entrySet()) {
				cprinter.print("//me->_" + entry.getKey() + "entered = false;");
				cprinter.print("me->_" + entry.getKey() + "state = 0;");
			}
		}*/

		if (state.refiningECCName == null && state.parallel == null) { //if normal ECC
			// Print out the transition conditions
			if (state.conditions != null) {
				if (state.conditions[0].equalsType(ConditionType.IMMEDIATE) == false) { //if first transistion is immediate dont need loop
					//cprinter.print("for(;;) {");
					cprinter.print("asm(\"nop\");FOR_"+statePrefix +"_"+ state.getName() + ":asm(\"nop\");");
					cprinter.indent();
				}
				if (skipSampleInput == false)
					cprinter.println(currentFbName+"_UpdateOutputAssoc(me);");
				
				//input events  = 0
				if (ieArrayLen == 1)
					cprinter.print("me->_input.events = 0;");
				else {
					for (int i = 0; i < ieArrayLen; i++)
						cprinter.print("me->_input.events[" + Integer.toString(i)
								+ "] = 0;");
				}

				cprinter.print("EOT;");
				//reset output to zero
				if (oeArrayLen == 1)
					cprinter.print("me->_output.events = 0;", 1);
				else {
					for (int i = 0; i < oeArrayLen; i++)
						cprinter.print("me->_output.events[" + Integer.toString(i)
								+ "] = 0;");
					cprinter.print("");
				}
				if (skipSampleOutput == false) 
					cprinter.println(currentFbName+"_UpdateInputAssoc(me);"); 
				printTransitions(state, numOfStates);
				
				if (state.conditions[0].equalsType(ConditionType.IMMEDIATE) == false) { //if first transistion is immediate dont need loop
					cprinter.unindent();
					//cprinter.print("}");
					cprinter.print("goto FOR_"+statePrefix +"_"+ state.getName() + ";"); //replace for loop with goto due to mbgcc optimaiing for to EOT if start of for is EOT
				}
			}
		}else{ //if HCECC
			
			if (state.refiningECCName != null && state.parallel == null) { //if only refinement
				String myPrefix = statePrefix;
				
					
				if (state.conditions != null) {
					printAbortTransistionsStart(state, numOfStates);
				}

				cprinter.print("//Refining ECC: " + state.refiningECCName );
				statePrefix += "_"+state.refiningECCName;
				printECC(state.refiningStates);
				
				
				statePrefix = myPrefix;
				if (state.conditions != null) {
					printAbortTransistionsEnd(state, numOfStates);
				}
			}else{ //has parallel regions
				String myPrefix = statePrefix;
				// If it has embedded... do something else
				if (state.conditions != null) {
					printAbortTransistionsStart(state, numOfStates);
				}
				String line = "PAR(";
				if (state.refiningECCName != null)
				{
					line += statePrefix+"_"+state.refiningECCName+"_thread";
				}
				if (state.parallel != null) {
					for (Entry<String, SyncState[]> entry : state.parallel.entrySet()) {
						line += "," + statePrefix+"_"+entry.getKey()+"_thread";
					}
				}
				line += ");";
				cprinter.print(line);
				CodePrinter temp = cprinter;
				cprinter = sprinter;
				

				//parallel region only the HC should always sample input thus
				skipSampleOutput = true;
				skipSampleInput = true; 
				
				skipSampleOutput = false;
				if (state.refiningECCName != null)
				{
					
					String t = statePrefix;
					cprinter.print("thread "+statePrefix+"_"+state.refiningECCName+"_thread() {");
					cprinter.indent();
					if (insName.length() == 0) {		
						cprinter.print(currentFbName + "* me = top_var" + ";", 0);
					}else{
						cprinter.print(currentFbName + "* me = " + fb.getCompiledType() + "_var;", 0);
					}
					statePrefix += "_"+state.refiningECCName;
					printECC(state.refiningStates);
					cprinter.unindent();
					cprinter.print("}");
					statePrefix = t;
				}
				skipSampleOutput = true;
				
				if (state.parallel != null) {
					int i = 0;
					for (Entry<String, SyncState[]> entry : state.parallel.entrySet()) {
						i++;
						if (i == state.parallel.size()) {
							skipSampleInput = false; 
						}
						String t = statePrefix;
						cprinter.print("//Parallel ECC: " + entry.getKey());
						cprinter.print("thread "+statePrefix+"_"+entry.getKey()+"_thread() {");
						cprinter.indent();
						if (insName.length() == 0) {		
							cprinter.print(currentFbName + "* me = top_var" + ";", 0);
						}else{
							cprinter.print(currentFbName + "* me = " + fb.getCompiledType() + "_var;", 0);
						}
						statePrefix += "_"+ entry.getKey();

						printECC(entry.getValue());
						cprinter.unindent();
						cprinter.print("}");
						statePrefix = t;
					}
				}
				cprinter = temp;
				statePrefix = myPrefix;
				
				skipSampleOutput = false;
				skipSampleInput = false; 
				
				if (state.conditions != null) {
					printAbortTransistionsEnd(state, numOfStates);
				}
			}
			
		}
	}

	private void printActions(Action[] actions /*Kyle:, boolean doExitActions*/) throws IOException {
		if (actions != null) {
			for (int i = 0; i < actions.length; i++) {
				/* Kyle:
				// Skip current action if it does not match doExitActions boolean select
				if((!doExitActions && (actions[i].getIsExitAction()))
						|| (doExitActions && !(actions[i].getIsExitAction())))
					continue;
				*/
					
				Procedure procedure = actions[i].getProcedure();
				if (procedure != null) {
					// Gareth Changed:
					// It makes more sense to:
					// if user has provided args... then there will also be a
					// prototype
					// then assume the action call INCLUDES theblock name in the
					// function call

					String args = actions[i].getArguments();
					// StringBuilder line = new StringBuilder();

					if (args != null) {
						// Explicit arguments are provided
						// Name is fully declared by user
						cprinter.print(procedure.getName() + "(" + args + ");");
					}
					else
						cprinter.print(procedure.getFullName() + "(me);");

				}

				Event output = actions[i].getOutput();
				if (output != null)
					cprinter.print("me->_output.event." + output.getName() + " = 1;");
			}
		}
	}

	/**
	 * Creates the test condition from the list of tokens.
	 * @param tokens list of tokens 
	 * @return A string containing the test condition.
	 */
	protected String conditionToString(LinkedList<Token> tokens) {
		StringBuilder guard = new StringBuilder();
		ListIterator<Token> i = tokens.listIterator();
		while (i.hasNext()) {
			Token tok = i.next();
			// GARETH TEMP CUZ I BROKE SUMMING
			if (tok == null)
				continue;
			TokenType type = tok.getType();
			String token = tok.getToken();
			switch (type) {
			case CPARENTHESIS:
				int len = guard.length();
				assert (len > 1) : "Unexpected `)\' in guard condition.\n";
				guard.deleteCharAt(len - 1);
				break;
			case ARITHOP:
				if (token.equalsIgnoreCase("MOD")
						|| token.equalsIgnoreCase("%"))
					token = "%";
				break;
			case LOGICOP:
				if (token.equalsIgnoreCase("NOT") || token.equals("!"))
					token = "!";
				else if (token.equalsIgnoreCase("OR") || token.equals("||"))
					token = "||";
				else if (token.equalsIgnoreCase("AND") || token.equals("&")
						|| token.equals("&&"))
					token = "&&";
				else if (token.equalsIgnoreCase("XOR"))
					token = "^";
				break;
			case COMPARISON:
				if (token.equals("="))
					token = "==";
				else if (token.equals("<>"))
					token = "!=";
				break;
			case EVENT:
				token = "me->_input.event." + token;
				break;
			case IFVAR:
			case INTVAR:
				token = "me->" + token;
				break;
			}
			guard.append(token);
			if (type != TokenType.OPARENTHESIS)
				guard.append(" ");
		}
		if (guard.length() == 0)
			return "ERROR OF SORTS";
		guard.deleteCharAt(guard.length() - 1);
		return guard.toString();
	}

	/**
	 * Pretty prints the ECC transition conditions.
	 * @param state the state currently being visited 
	 * @param numOfStates total number states for the ECC
	 */
	protected void printTransitions(SyncState state, int numOfStates) throws IOException {
		int len = state.conditions.length;
		assert (len == state.children.length) : "Conditions and children length do not match.\n";

		String line = "";
		int i = 0;
		for (;;) {
			if (state.conditions[i].equalsType(ConditionType.IMMEDIATE)) {
				if (i == 0) {
					cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");

					
					/* Kyle:
					// Print out the exit action for this state
					printActions(state.actions, true);
					// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
					if( state.conditions[i].getActions() != null )
					{
						printActions(state.conditions[i].getActions(), false);
					}
					*/
				}
				else {
					cprinter.print(line + "{");
					cprinter.indent();

					if (numOfStates > 1)
						cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");
					
					/* Kyle:
					// Print out the exit action for this state
					printActions(state.actions, true);
					// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
					if( state.conditions[i].getActions() != null )
					{
						printActions(state.conditions[i].getActions(), false);
					}
					*/
					cprinter.unindent();
					cprinter.print("}");
				}
				break;
			}
			LinkedList<Token> tokens = state.conditions[i].getConditionTokens();
			line += ("if (" + conditionToString(tokens) + ") {");
			cprinter.print(line);
			cprinter.indent();

			
			
			if (numOfStates > 1)
				cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");
			/* Kyle:
			// Print out the exit action for this state
			printActions(state.actions, true);
			// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
			if( state.conditions[i].getActions() != null )
			{
				printActions(state.conditions[i].getActions(), false);
			}
			*/
			cprinter.unindent();
			cprinter.print("}");
			i++;
			if (i >= len)
				break;
			line = "else ";
		}
	}

	protected void printAbortTransistionsStart(SyncState state, int numOfStates) throws IOException {
		int len = state.conditions.length;
		assert (len == state.children.length) : "Conditions and children length do not match.\n";
		for (int i = 0; i < len; i++) {
			cprinter.print("abort {");
			cprinter.indent();
		}
	}
	
	protected void printAbortTransistionsEnd(SyncState state, int numOfStates) throws IOException {
		int len = state.conditions.length;
		assert (len == state.children.length) : "Conditions and children length do not match.\n";

		String line = "";
		int i = len-1;
		for (;;) {
			cprinter.unindent();
			if (state.conditions[i].equalsType(ConditionType.IMMEDIATE)) {
				if (i == len-1) {

					if (numOfStates > 1)
						cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");

					

				}
				else {
					cprinter.print(line + "{");
					//cprinter.indent();

					if (numOfStates > 1)
						cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");
					

					//cprinter.unindent();
					cprinter.print("}");
				}
				break;
			}
			LinkedList<Token> tokens = state.conditions[i].getConditionTokens();
			line += ("} when (" + conditionToString(tokens) + ");");
			cprinter.print(line);
			//cprinter.indent();

			
			
			if (numOfStates > 1)
				cprinter.print("goto " + statePrefix + "_" + state.children[i].getName() + ";");

			
			//cprinter.print("}");
			i--;
			
			if (i < 0)
				break;
			line = "";
			
		}
	}
	
	/**
	 * Matches ST data types with C primitive types. If a match is not found, a
	 * user-defined type is assumed.
	 * 
	 * @param IEC 61499 type
	 * @return C equivalent type
	 */
	/*
	public static String getCDataType(String type) {
		if (type.isEmpty())
			return "void";
		else if (type.equalsIgnoreCase("ANY"))
			return "void*";
		else if (type.equalsIgnoreCase("BOOL"))
			return "bool";
		else if (type.equalsIgnoreCase("SINT"))
			return "char";
		else if (type.equalsIgnoreCase("INT"))
			return "short";
		else if (type.equalsIgnoreCase("DINT"))
			return "int";
		else if (type.equalsIgnoreCase("LINT"))
			return "long long";
		else if (type.equalsIgnoreCase("USINT"))
			return "unsigned char";
		else if (type.equalsIgnoreCase("UINT"))
			return "unsigned short";
		else if (type.equalsIgnoreCase("UDINT"))
			return "unsigned int";
		else if (type.equalsIgnoreCase("ULINT"))
			return "unsigned long long";
		else if (type.equalsIgnoreCase("REAL"))
			return "float";
		else if (type.equalsIgnoreCase("LREAL"))
			return "double";
		else if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			return "FBstring";
		// else if (type.equalsIgnoreCase("WSTRING")) return "Wstring";
		else if (type.equalsIgnoreCase("BYTE"))
			return "unsigned char";
		else if (type.equalsIgnoreCase("WORD"))
			return "unsigned short";
		else if (type.equalsIgnoreCase("DWORD"))
			return "unsigned int";
		else if (type.equalsIgnoreCase("LWORD"))
			return "unsigned long long";
		// else if (type.equalsIgnoreCase("DATE_AND_TIME")) return "struct timeval";
		else if (type.equalsIgnoreCase("TIME"))
			return "long long";
		else
			return type;
	}
	*/
	
	/**
	 * Matches ST data types with portable C primitive types. These "portable" 
	 * types need to be defined by the user for a given platform in an 
	 * appropriate header file. This header file should then be included with 
	 * the generated code during compilation. If a match is not found for a 
	 * given ST data type, a user-defined type is assumed.
	 * 
	 * @param IEC 61499 type
	 * @return C equivalent type
	 */
	public static String getPortableCType(String type) {
		if (type.isEmpty())
			return "void";
		else if (type.equalsIgnoreCase("ANY"))
			return "void*";
		/*
		else if (type.equalsIgnoreCase("BOOL"))
			return "bool";
		else if (type.equalsIgnoreCase("SINT"))
			return "sbyte1";
		else if (type.equalsIgnoreCase("INT"))
			return "sbyte2";
		else if (type.equalsIgnoreCase("DINT"))
			return "sbyte4";
		else if (type.equalsIgnoreCase("LINT"))
			return "sbyte8";
		else if (type.equalsIgnoreCase("USINT"))
			return "ubyte1";
		else if (type.equalsIgnoreCase("UINT"))
			return "ubyte2";
		else if (type.equalsIgnoreCase("UDINT"))
			return "ubyte4";
		else if (type.equalsIgnoreCase("ULINT"))
			return "ubyte8";
		else if (type.equalsIgnoreCase("REAL"))
			return "real32";
		else if (type.equalsIgnoreCase("LREAL"))
			return "real64";
		else if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			return "FBstring";
		//else if (type.equalsIgnoreCase("WSTRING")) return "Wstring";
		else if (type.equalsIgnoreCase("BYTE"))
			return "ubyte1";
		else if (type.equalsIgnoreCase("WORD"))
			return "ubyte2";
		else if (type.equalsIgnoreCase("DWORD"))
			return "ubyte4";
		else if (type.equalsIgnoreCase("LWORD"))
			return "ubyte8";
		//else if (type.equalsIgnoreCase("DATE_AND_TIME")) return "struct timeval";
		else if (type.equalsIgnoreCase("TIME"))
			return "sbyte8";
		*/
		else
			return type;
	}
	

}
