/* CGenerator.java
 * C code generator
 *
 * Written by: Li Hsien Yoong
 */

package ccode;

import java.io.*;
import java.util.*;
import java.util.Map.Entry;

import PRETCCompiler.PRETCCompiler;
import sttranslate.STtoC;

import fbtostrl.*;
import fb.*;
import ir.*;

public class CGenerator extends CodeGenerator {
	public static boolean STFunctionsUsed;
	private static final int INTSIZE = 32;
	private int ieArrayLen;
	private int oeArrayLen;
	private CodePrinter cprinter;
	private CodePrinter rprinter;
	private String filetype;
	private Block[] sortedNodes;
	private boolean isUCOStask;			// true if we are generating a uCOS task
	private boolean isTTPOStask;		// true if we are generating a TTP-OS task
	private boolean isD3task;			// true if we are generating a D3 task
	private String statePrefix = "";	// prefix for ECC name.. required for HCECCs :|
	
	// Constants to control printing of input assignments for delayed/non-delayed connections
	private static enum DelayType {
		DELAYALL,	// used when compiling without --sorted
		DELAYONLY, 	// used for the case where only delayed connections are considered 
		DELAYNONE	// used for the case where non-delayed connections are considered
	}

	public CGenerator(FunctionBlock f, Options o, LinkedList<String> files,
			String n, String pn, LinkedList<CodeGenerator> cgs, Block[] nodes) {
		super(f, o, files, n, pn, cgs);
		if (opts.isCpp())
			filetype = ".cpp";
		else
			filetype = ".c";
		sortedNodes = nodes;

		ieArrayLen = (getNumOfIEvents() + INTSIZE - 1) / INTSIZE;
		if (outputEvents != null)
			oeArrayLen = (outputEvents.length + INTSIZE - 1) / INTSIZE;
		
		// Infer that this is a resource if interface is non-existent.
		// -- Parameters are like input data, so we don't check it.
		if (inputEvents == null && outputEvents == null && outputData == null) {
			isUCOStask = opts.isGNUuCOS();
			isTTPOStask = opts.isTTPOS();
			isD3task = opts.isD3();
		}
	}

	/**
	 * DESCRIPTION: Generates code for this module
	 * 
	 * @param fileName - base name of the output file(s) produced
	 * @param top - true if this is the top-level file, otherwise false
	 * @param comBlocks - set of local communication blocks
	 * @return Null if code was generated; otherwise, the code generator itself
	 */
	public CodeGenerator generateCode(String fileName, boolean top,
			HashSet<Block> comBlocks) throws IOException {
		fileName = getParentName(fileName) + fb.getCompiledType();
		if (sifbInfo != null) {
			retrieveSIFB(fileName);
			if (top && (opts.isRunnable() || opts.isSimul() || opts.isQTSimul())) {
				OutputManager.printError(fb.getBaseType(),
						"Using an SIFB as the only file for Run or Simulation is not supported.",
						OutputLevel.ERROR);
			}
			return null;
		} 
		else {
			if (opts.isSimul())
				SimHelpers.addInstance(fullyQualifiedInsName, fb.getCompiledType());

			if (fb.getCompiledType().endsWith("_HMI")) {
				// Defines function which is then called
				// true for first instance... clear file
				// (If it gets here the block has not been generated so far)
				NXTControlHMIGenerator.printHMIStuff(fb, fullyQualifiedInsName, true);
				return null; // skip
			}

			String hname = fileName + ".h";
			printer = new CodePrinter(hname);
			fileNames.add(hname);
			String header = getFileName(hname);
			String cname = fileName + filetype;
			if (!fb.isPretC()) {
				cprinter = new CodePrinter(cname);
				fileNames.add(cname);
			}

			if (top) {
				if (opts.isRunnable()) {
					cname = fileName + "run" + filetype;
					rprinter = new CodePrinter(cname);
					fileNames.add(cname);
				}
				if (opts.isSimul()) {
					if (opts.isVerbose()) {
						OutputManager.printNotice("", 
								"Simulation code is only designed and tested for execution on Windows",
								OutputLevel.INFO);
					}
					SimHelpers.startSimFiles(fileName, fb);
				}
				else if (opts.isQTSimul()) {
					SimHelpers.startQTSimFiles(fileName, header);
				}
			}

			// String simDef = "";
			String def = makeHeaderMacro(header);
			printer.print("// This file is generated by FBC.", 1);
			printer.print("#ifndef " + def);
			printer.print("#define " + def, 1);
			/* printer.print("#include <stdbool.h>");
			 * Moved to 'custom' bool typedef in fbtypes (because Windows doesn't have it)
			 */
			printer.print("#include \"fbtypes.h\"");

			if (!fb.isPretC()) {
				cprinter.print("// This file is generated by FBC.", 1);
				cprinter.print("#include \"" + header + "\"");
				if (FBtoStrl.currentDeviceType.equals(Device.TYPE_PTARM)==false) {			
					cprinter.print("#include <string.h>");
					// cprinter.print("#include <wchar.h>");
					cprinter.print("#include <stdio.h>", 1);
				}
			}
			if (headers != null) {
				for (String head : headers) {
					if ( (head.startsWith("\"") && head.endsWith("\"")) ||
						 (head.startsWith("<") && head.endsWith(">")) ) {
						printer.print("#include " + CodeGenerator.escapeFilePaths(head));
					}
					else {
						File file = new File(head);
						//absolute
						if (file.isAbsolute()) {
							String parent = file.getParent();
							if (parent != null)
								includePaths.add(parent);
							String child = file.getName();
							if ( !child.isEmpty() ) {
								printer.print("#include \"" + 
										CodeGenerator.escapeFilePaths(child) + "\"");
							}
						}//source relative
						else if(head.startsWith("..")) {
							printer.print("#include \"" + 
									CodeGenerator.escapeFilePaths(head) + "\"");
						}//complete relative
						else {
							printer.print("#include <" + 
									CodeGenerator.escapeFilePaths(head) + ">");
						}
					}
				}
			}
			
			HashSet<String> includedUDTs = new HashSet<String>();
			
			// Include DataTypes
			if( fb.inputData != null ) {
				for(VarType v : fb.inputData) {
					String type = v.getType();
					if (!includedUDTs.contains(type) && !IEC61131Types.isIEC61131Type(type)) {
						printer.print("#include \"" + type + ".h\"");
						includedUDTs.add(type);
					}
				}
			}
			// Include DataTypes
			if( fb.outputData != null ) {
				for(VarType v : fb.outputData) {
					String type = v.getType();
					if (!includedUDTs.contains(type) && !IEC61131Types.isIEC61131Type(type)) {
						printer.print("#include \"" + type + ".h\"");
						includedUDTs.add(type);
					}
				}
			}
			
			// If there are ST functions, include STFunctions.h (and copy it)
			if (fb.getBasicFB() != null) {
				if (fb.getBasicFB().algorithms != null) {
					// Include DataTypes
					if( fb.getBasicFB().internalVars != null ) {
						for(VarDeclaration v : fb.getBasicFB().internalVars) {
							String type = v.getType();
							if (!includedUDTs.contains(type) && 
								!IEC61131Types.isIEC61131Type(type)) {
								printer.print("#include \"" + type + ".h\"");
								includedUDTs.add(type);
							}
						}
					}
				
					for (Algorithm a : fb.getBasicFB().algorithms) {
						if (a.getLanguage().equals("ST")) {
							printer.print("#include \"STFunctions.h\"");
							String stfunctions = getParentName(fileName) + "STFunctions.h";
							String resources = "resources" + File.separatorChar + "STFunctions.h";
							BufferedWriter writer = null;
							BufferedReader reader = null;
							if (!fileNames.contains(stfunctions)) {
								fileNames.add(stfunctions);
								try {
									writer = new BufferedWriter(new FileWriter(stfunctions));
									reader = new BufferedReader(new FileReader(resources));
								} catch (FileNotFoundException e) {
									OutputManager.printError("", resources + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								} catch (IOException e) {
									OutputManager.printError("", stfunctions + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								}
								plainCopyFile(writer, reader);
							}

							stfunctions = getParentName(fileName) + "STFunctions.c";
							resources = "resources" + File.separatorChar + "STFunctions.c";
							if (!fileNames.contains(stfunctions)) {
								fileNames.add(stfunctions);
								try {
									writer = new BufferedWriter(new FileWriter(stfunctions));
									reader = new BufferedReader(new FileReader(resources));
								} catch (FileNotFoundException e) {
									OutputManager.printError("", resources + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								} catch (IOException e) {
									OutputManager.printError("", stfunctions + 
											": Could not be opened.\n", OutputLevel.FATAL);
									System.exit(-1);
								}
								plainCopyFile(writer, reader);
							}
							break;
						}
					}
				}
			}

			if (opts.isSimul()) {// include extra functions
				printer.print("#include \"Simulation.h\"");
			}
			else if (opts.isQTSimul()) {
				// nothing
			}

			if (rprinter != null) {
				rprinter.print("// This file is generated by FBC.", 1);
				rprinter.print("#include \"" + header + "\"");
				rprinter.print("#include <string.h>");
				rprinter.print("#include <stdlib.h>");
				rprinter.print("#include <stdio.h>", 1);
			}

			String fbName = fb.getCompiledType();
			Composite compositeFB = fb.getCompositeFB();
			if (compositeFB == null) {
				if (opts.isTTPOS()) {
					cprinter.print("#include \"hal.h\"");
					cprinter.print("#include \"TTPos.h\"");
					cprinter.print("#include \"ttpc_msg.h\"", 1);
				}
				printer.print("");
				if (fb.getBasicFB() != null) {
					generateBasicFB(fbName);
				}
				else {
					if (fb.isPretC()) {
						// Call Matthew's Compiler
						// FullyQualifiedInsName
						// PretC = fb.getPretC()
						// PretC.interfaceCode
						// PretC.code
						// fileName+".c"
						// public static void FBCompile(String fbName, String
						// PretCCode, String outputPath, String instanceName,
						// String runXMLCode, boolean simulation) {

						String uniqueFile = fullyQualifiedInsName.replaceAll(
								"\\.", "_") + "_" + fb.getBaseType();
						PRETCCompiler.FBCompile(fb.getBaseType(), fb.getPretCCode(), 
								opts.outputpath(),
								fullyQualifiedInsName.replaceAll("[\\.]", "_"), "", opts.isSimul());

						if (opts.isSimul()) {
							// Append initXML and runXML????
							// TODO: Unique Block name (is this already defined in fb.?
							CodePrinter pretSim = new CodePrinter(opts.outputpath() + 
									uniqueFile + ".simu.h", true);

							SimHelpers.addSimFunctions(pretSim, fb);
							pretSim.close();
						}
					}
					// This prints the interface .h file for Adapters!!!! (and PretC)
					generateInterface(fbName, false, true);
				}
			}
			else {
				HashSet<String> files = new HashSet<String>();
				for (int i = 0; i < runs.length; i++) {
					String runType = runs[i].getType();

					if (!files.contains(runType) && !isLocalComBlock(runType)) {
						printer.print("#include \"" + runType + ".h\"");
						files.add(runType);
					}
				}

				if (isUCOStask) {
					printer.print("#include \"includes.h\"", 1);
					printer.print("/* BEGIN uCOS SPECIFIC CONSTANTS AND VARIABLES ********************************/");
					String stackSize = insName + "_STACK_SIZE";
					printer.print("enum {" + stackSize + " = 512};	// customize as needed", 1);
					String stack = "OS_STK " + insName + "Stack[" + stackSize + "];";
					printer.print("extern " + stack);
					printer.print("/* END uCOS SPECIFIC CONSTANTS AND VARIABLES **********************************/");
					cprinter.print(stack, 1);
				}
				printer.print("");

				// Check if global variables for local communication blocks are to be generated
				if (comBlocks != null && opts.isRunnable()) {
					HashMap<String, Variables> globalVars = CProgGenerator.createGlobalVars(comBlocks);
					String comFile = fileName + "run.h";
					CodePrinter comPrinter = new CodePrinter(comFile);
					comPrinter.print("// This file is generated by FBC.", 1);
					comFile = makeHeaderMacro(getFileName(comFile));
					comPrinter.print("#ifndef " + comFile);
					comPrinter.print("#define " + comFile, 1);
					CProgGenerator.printGlobalVars(globalVars, rprinter, comPrinter);
					comPrinter.print("#endif // " + comFile);
					comPrinter.close();
					rprinter.writeToBuf();
					rprinter.indent();
					CProgGenerator.initGlobalVars(globalVars, rprinter);
					rprinter.unindent();
					rprinter.writeToFile();
				}

				generateInterface(fbName, true, false);
				if (opts.isSorted())
					printSortedComposite(fbName);
				else
					printComposite(fbName);

				// Print out all deferred blocks
				ListIterator<CodeGenerator> cgIterator = deferredBlocks.listIterator();
				while ( cgIterator.hasNext() ) {
					CodeGenerator dcg = cgIterator.next();
					// Get instance
					Instance inst = getInstance(dcg.getName());

					// If we don't check 'receiver' only blocks... it will cause the 
					// current resource's UDPRECV to have an 'if' for DATAWIREIDS  
					// specified in linkPUBLISH blocks :|
					if (opts.isNxtControl()
							&& NXTControlInterResourceCommGenerator.interRESUsed) {
						if (inst.getType().contains("RECEIVER")) {
							Set<Signal> signals = inst.getSignalSet();

							// Needed for DATARECEIVER type working out :(
							String[] datawireidParams = null;
							for (Signal sig : signals) {
								HashSet<Signal> bindings = inst.getBindings(sig);
								if (bindings.size() < 1)
									continue;

								Signal bind = bindings.iterator().next();
								if (sig.getSignal().startsWith("DATAWIREIDS")) {
									datawireidParams = bind.getSignal().substring(1, 
											bind.getSignal().length() - 1).split(",");
								} 
								else if (sig.getSignal().startsWith("EVENTWIREIDS")) {
									NXTControlInterResourceCommGenerator.
											addEventWireIDs(bind.getSignal());
								}
							}
							// Loop through a second time to ENSURE we have DATAWIREIDS
							for (Signal sig : signals) {
								// Only want types of the data ports
								if (sig.getSignal().startsWith("RD_")) {
									if (datawireidParams == null) {
										OutputManager.printError(fb.getCompiledType(), 
												"DATAWIREIDS not parsed before a RD_",
												OutputLevel.FATAL);
										System.exit(-1);
									}
									int wireIDIndex = Integer.valueOf(sig.getSignal().substring(3)) - 1;
									NXTControlInterResourceCommGenerator.addDataWireID(
											datawireidParams[wireIDIndex], sig.getSigType());
								}
							}

							/*
							 * for(Parameter p : inst.params) { if(
							 * p.name.equals("EVENTWIREID")) {
							 * dcg.setFileName
							 * (dcg.getFileName()+"_"+p.value);
							 * dcg.setUniqueID(p.value); break; } else if(
							 * p.name.equals("EVENTWIREIDS") ||
							 * p.name.equals("DATAWIREIDS") ) { String[]
							 * values = p.value.substring(1,
							 * p.value.length()-1).split(",");
							 * dcg.setFileName
							 * (dcg.getFileName()+"_"+values[0]);
							 * dcg.setUniqueID(values[0]);
							 * NXTControlInterResourceCommGenerator
							 * .addCFile(
							 * dcg.fb.getCompiledType()+"_"+values[0]+".c");
							 * break; } }
							 */
						} 
						else if (inst.getType().contains("PUBLISHER")) {
							Set<Signal> signals = inst.getSignalSet();
							String linkPubName = "";
							for (Parameter p : inst.params) {
								if (p.name.equals("EVENTWIREID")) {
									/*
									 * dcg.setFileName(dcg.getFileName()+"_"+
									 * p.value);
									 * NXTControlInterResourceCommGenerator
									 * .addCFile
									 * (dcg.fb.getCompiledType()+"_"
									 * +p.value+".c");
									 * dcg.setUniqueID(p.value);
									 */
									linkPubName = dcg.fb.getCompiledType() + "_" + p.value;
									break;
								}
							}
							// see if we are connected to a adaptor / fb
							boolean commandSet = false;
							for (Signal sig : signals) {
								if (sig.getPortType() != PortType.INPUT)
									continue;

								HashSet<Signal> bindings = inst.getBindings(sig);
								if (bindings.size() < 1)
									continue;
								for (Signal bind : bindings) {
									if ((bind.getPortType() != PortType.LOCAL && 
											bind.getPortType() != PortType.LOCALDELAYED) ||
											bind.getSigType() == null)
										continue;
									Instance bInst = getInstance(bind.instance);
									if (FBtoStrl.isAdapter(bInst.getType())) {
										NXTControlInterResourceCommGenerator
												.addLinkPub(linkPubName, inst, true);
									}
									else {
										NXTControlInterResourceCommGenerator
												.addLinkPub(linkPubName, inst, false);
									}
									commandSet = true;
									break;
								}
								if (commandSet)
									break;
							}
						}
					}

					if (dcg.fb.isSIFB()) {
						if (dcg.sifbInfo.getIndex() < 0) {
							// try to get one
							String cntValue = FBtoStrl.varSizeMap.get(inst.getFQName() + ".CNT");
							if (cntValue != null)
								dcg.setSIFBCountValue("CNT", Integer.valueOf(cntValue));
						}
					}
					dcg.generateCode(dcg.getFileName(), false, null);
					
					// Deferred code generators should be removed once they are no longer
					// needed to avoid confusion later as to whether they are still needed. 
					cgIterator.remove();
				}

				// After Data and Event blocks handled
				if (opts.isNxtControl() && NXTControlInterResourceCommGenerator.interRESUsed) {
					// TODO: ^ 'IF' Condition is not right
					// called 3 times for 2 resources :(
					NXTControlInterResourceCommGenerator.printDynamicCommUdpReceive();
				}
			}

			if (rprinter != null)
				rprinter.close();

			if (opts.isSimul()) {
				if (!fb.isPretC())
					SimHelpers.addSimFunctions(cprinter, fb);
				printer.println("void " + fb.getCompiledType()
						+ "_initXML(mxml_node_t* node, " + fb.getCompiledType()
						+ "* me, char* instancename);");
				printer.println("void " + fb.getCompiledType() + "_runXML(" + fb.getCompiledType() + 
						"* me);");
			}

			if (top && (opts.isSimul() || opts.isQTSimul())) {
				SimHelpers.closeSimFiles();
			}

			if (!fb.isPretC()) {
				cprinter.close();
			}

			printer.print("#endif // " + def);
			printer.close();

			// Just for first file
			hname = getParentName(fileName) + "fbtypes.h";
			if (!fileNames.contains(hname)) {
				// fbtypes.h
				hname = getParentName(fileName) + "fbtypes.h";
				printer = new CodePrinter(hname);
				fileNames.add(hname);
				printer.print("// This file is generated by FBC.", 1);
				
				def = makeHeaderMacro("fbtypes.h");
				printer.print("#ifndef " + def);
				printer.print("#define " + def, 1);
				
				printer.print("/*********************************************************************");
				printer.print(" This file contains the mapping between IEC 61131 and C data types.");
				printer.print(" Since C data types are non-portable, this file MUST be customized to");
				printer.print(" match the data width assumed by the C compiler used for compiling the");
				printer.print(" generated code. This enables the generated code to be easily ported");
				printer.print(" to other platforms.");
				printer.print("*********************************************************************/", 1);
				
				printer.println("// Time data types");
				printer.println("#if _MSC_VER");
					printer.println("#include <winsock2.h>");
				printer.println("#else");
					printer.println("#include <sys/time.h>");
				printer.println("#endif");
				printer.println();
				printer.println("// bool stuff");
				printer.println("#ifndef __cplusplus");
					printer.println("typedef char bool;");
				printer.println("#endif // __cplusplus");
				printer.println();
				printer.println("#ifndef true");
					printer.println("#define true 1");
					printer.println("#define false 0");
				printer.println("#endif");
				printer.println();
				printer.println("#ifndef TRUE");
					printer.println("#define TRUE true");
				    printer.println("#define FALSE false");
				    printer.println("#endif");
				printer.println("");
				
				// DATATYPES:
				// http://en.wikipedia.org/wiki/IEC_61131-3#Data_Types
				// these defines are useless because the conversion functions need to take into account the size / max min values
				
				printer.print("#define STRING_LENGTH " + Integer.toString(Options.strlen()), 1);
				
				printer.println("// Bit strings");
				printer.println("typedef bool BOOL;");
				printer.println("typedef unsigned char BYTE;");
				printer.println("typedef unsigned short WORD;");
				printer.println("typedef unsigned int DWORD;");
				printer.println("typedef unsigned long long LWORD;");
				printer.println();
				printer.println("// Integers");
				printer.println("typedef char SINT;");
				printer.println("typedef unsigned char USINT;");
				printer.println("typedef short INT;");
				printer.println("typedef unsigned short UINT;");
				printer.println("typedef int DINT;");
				printer.println("typedef unsigned int UDINT;");
				printer.println("typedef long long LINT;");
				printer.println("typedef unsigned long long ULINT;");
				printer.println();
				printer.println("// Reals");
				printer.println("typedef float REAL;");
				printer.println("typedef double LREAL;");
				printer.println();
				printer.println("// Duration");
				printer.println("typedef long long TIME;");
				printer.println("");
				// TODO: Find a platform independent implementation for DATE and TIME etc types
				//printer.println("typedef long long TIME_OF_DAY;");
				//printer.println("typedef struct timeval DATE;");
				//printer.println("typedef struct timeval DATE_AND_TIME;");
				//printer.println("");
				printer.println("// Strings");
				// TODO: Remove FBstring and just use STRING
				printer.println("typedef char FBstring[STRING_LENGTH];");
				printer.println("typedef FBstring STRING;");
				printer.println("typedef FBstring WSTRING;");
				printer.println();
				printer.print("#endif // " +def, 1);
				printer.close();
				
				if( opts.isSimul() )
				{
					// datatypes.h
					hname = getParentName(fileName) + "datatypes.h";
					String file = "resources" + File.separator + "datatypes.h";
					BufferedWriter out = null;
					BufferedReader in = null;
					try {
						out = new BufferedWriter(new FileWriter(hname));
						fileNames.add(hname);
						in = new BufferedReader(new FileReader(file));	
					} catch (FileNotFoundException e) {
						OutputManager.printError("", file + 
								": Could not be opened.\n", OutputLevel.FATAL);
						System.exit(-1);
					} catch (IOException e) {
						OutputManager.printError("", hname + 
								": Could not be opened.\n", OutputLevel.FATAL);
						System.exit(-1);
					}
					plainCopyFile(out, in);
					
					// datatypes.c
					cname = getParentName(fileName) + "datatypes.c";
					file = "resources" + File.separator + "datatypes.c";
					try {
						out = new BufferedWriter(new FileWriter(cname));
						fileNames.add(cname);
						in = new BufferedReader(new FileReader(file));
					} catch (FileNotFoundException e) {
						OutputManager.printError("", file + 
								": Could not be opened.\n", OutputLevel.FATAL);
						System.exit(-1);
					} catch (IOException e) {
						OutputManager.printError("", cname + 
								": Could not be opened.\n", OutputLevel.FATAL);
						System.exit(-1);
					}
					plainCopyFile(out, in);
					
					srcDependencies.add("datatypes.c");
				}
			}
		}
		return null;
	}

	static String getComBlockType(String blockType) {
		if (isLocalComBlock(blockType)) {
			return blockType.substring(0, blockType.indexOf('_') + 1);
		}
		return "";
	}

	String getComPartnerType(String blockType) {
		if (blockType.equals("SEND_"))
			return "RECV_";
		else
			/* if (blockType.equals("RECV_")) */
			return "SEND_";
	}

	void clearOutputEvents(String blockType, String insName) throws IOException {
		if (blockType.startsWith("SEND_")) {
			cprinter.print("_" + insName + "._output.event.SEND_CNF = 0;");
		}
		else if (blockType.startsWith("RECV_")) {
			cprinter.print("_" + insName + "._output.event.RECV_IND = 0;");
		}
	}

	int[] getComBlockIndices(String blockType) {
		int[] indices = new int[2];
		String tail = blockType.substring(5);
		if (blockType.startsWith("SEND_") || blockType.startsWith("RECV_")) {
			int idx = tail.indexOf('_');
			if (idx > 0) {
				String qlen = tail.substring(idx + 1);
				String index = tail.substring(0, idx);
				if (SIPath.isAllDigit(qlen) && SIPath.isAllDigit(index)) {
					indices[0] = Integer.parseInt(index);
					indices[1] = Integer.parseInt(qlen);
				}
			}
		}
		else {
			if (SIPath.isAllDigit(tail))
				indices[0] = Integer.parseInt(tail);
		}

		return indices;
	}

	private String makeIFLocalDataAssignment(String instance, String sig, String blockType) {
		return "_" + instance + "._d" + sig;
	}

	private String makeLocalDataAssignment(String instance, String sig, String blockType) {
		if (blockType.startsWith("SEND_"))
			return "_" + instance + ".d" + sig + "[_" + instance + "._wrptr]";
		else /* if (blockType.startsWith("RECV_")) */
			return "_" + instance + ".d" + sig + "[_" + instance + "._rdptr]";
	}

	public static String makeLocalEvAssignment(String instance, String sig,
			String blockType, boolean io) {
		if (!io)
			return "_" + instance + "._input.event." + getComBlockType(blockType) + sig;
		else
			return "_" + instance + "._output.event." + getComBlockType(blockType) + sig;
	}

	String getComPortIndex(String portName) {
		if (portName.startsWith("SD_") || portName.startsWith("RD_"))
			return portName.substring(3);
		return portName;
	}

	boolean hasComPortIndex(String portName) {
		return SIPath.isAllDigit(getComPortIndex(portName));
	}

	/* Returns a set containing all declarations for toANY converter functions */
	protected HashSet<String> getToAnyConverterDecls() {
		HashSet<String> decls = new HashSet<String>();
		int index = sifbInfo.getIndex();
		for (int i = 0; i < index; i++) {
			String[] func = sifbInfo.getToAnyConverterDecl(i);
			decls.add("ANY " + func[0] + "(" + func[1] + ");");
		}
		return decls;
	}

	/* Returns a set containing all declarations for ANYto converter functions */
	protected HashSet<String> getAnyToConverterDecls() {
		HashSet<String> decls = new HashSet<String>();
		int index = sifbInfo.getIndex();
		for (int i = 0; i < index; i++) {
			String[] func = sifbInfo.getAnyToConverterDecl(i);
			decls.add(func[1] + " " + func[0] + "(ANY);");
		}
		return decls;
	}
	
	/**
	 * Prints the .h file for PUBL service interface function blocks.
	 * @param file name of the PUBL file
	 * @throws IOException
	 */
	protected void printPUBL_h_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		String globalType = sifbInfo.getGlobalVarType();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#ifndef PUBL" + postfix + "_H_");
		sifbPrinter.print("#define PUBL" + postfix + "_H_", 1);
		
		sifbPrinter.print("#include \"fbtypes.h\"");
		sifbPrinter.print("#include \"" + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h\"");
		ArrayList<String> userDefinedTypes = 
			sifbInfo.getUserTypesForPorts(fullyQualifiedInsName);
		for (String userType : userDefinedTypes)
			sifbPrinter.print("#include \"" + userType + ".h\"");
		sifbPrinter.println();
		
		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INIT : 1; // service initialization");
		sifbPrinter.smartPrint("UDINT REQ : 1; // service request");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} PUBL" + postfix + "IEvents;", 1);

		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INITO : 1; // initialization confirm");
		sifbPrinter.smartPrint("UDINT CNF : 1; // service confirmation");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} PUBL" + postfix + "OEvents;", 1);

		sifbPrinter.smartPrint("typedef struct {");
		sifbPrinter.smartPrint("BOOL _entered;");
		sifbPrinter.smartPrint("PUBL" + postfix + "IEvents _input;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String type = anyTypes[i-1].getType();
			if (type.equalsIgnoreCase("ANY"))
				type = "BOOL";
			String portName = "SD_" + i;
			sifbPrinter.smartPrint(type + " _" + portName + 
					getArrayIndex(anyTypes[i-1].getArraySize(), fullyQualifiedInsName, 
							portName) + ";");
		}
		sifbPrinter.smartPrint("PUBL" + postfix + "OEvents _output;");
		sifbPrinter.smartPrint(globalType + "* _globalBuf;");
		sifbPrinter.smartPrint("} PUBL" + postfix + ";", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "init(PUBL" + postfix + "* me, " + 
				globalType + "* global);", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "run(PUBL" + postfix + "* me);", 1);

		sifbPrinter.smartPrint("#endif /*PUBL" + postfix + "_H_*/");
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .c file for PUBL service interface function blocks.
	 * @param file name of the PUBL file
	 * @throws IOException
	 */
	protected void printPUBL_c_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#include \"PUBL" + postfix + ".h\"");
		sifbPrinter.print("#include <string.h>", 1);
		
		sifbPrinter.smartPrint("/* PUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "init(PUBL" + postfix + "* me, " + 
				sifbInfo.getGlobalVarType() + "* global)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_entered = false;");
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("me->_output.events = 0;");
		sifbPrinter.smartPrint("me->_globalBuf = global;");
		sifbPrinter.smartPrint("}", 1);

		sifbPrinter.smartPrint("/* PUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void PUBL" + postfix + "run(PUBL" + postfix + "* me)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_output.events = 0;", 1);
		sifbPrinter.smartPrint("if (!me->_entered) {");
		sifbPrinter.smartPrint("me->_entered = true;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else {");
		sifbPrinter.smartPrint("if (me->_input.event.INIT) {");
		sifbPrinter.smartPrint("me->_output.event.INITO = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else if (me->_input.event.REQ) {");
		sifbPrinter.smartPrint("me->_globalBuf->status = _NEW;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String index = Integer.toString(i);
			sifbPrinter.smartPrint( makeAssignment(anyTypes[i-1], 
					"me->_globalBuf->buffer.data_" + index, "me->_SD_" + index, (byte)0) );
		}
		sifbPrinter.smartPrint("me->_output.event.CNF = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("}", 1);
		
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("}");		
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .h file for SUBL service interface function blocks.
	 * @param file name of the SUBL file
	 * @throws IOException
	 */
	protected void printSUBL_h_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		String globalType = sifbInfo.getGlobalVarType();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#ifndef SUBL" + postfix + "_H_");
		sifbPrinter.print("#define SUBL" + postfix + "_H_", 1);
		
		sifbPrinter.print("#include \"fbtypes.h\"");
		sifbPrinter.print("#include \"" + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h\"");
		ArrayList<String> userDefinedTypes = 
			sifbInfo.getUserTypesForPorts(fullyQualifiedInsName);
		for (String userType : userDefinedTypes)
			sifbPrinter.print("#include \"" + userType + ".h\"");
		sifbPrinter.println();
		
		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INIT : 1; // service initialization");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} SUBL" + postfix + "IEvents;", 1);

		sifbPrinter.smartPrint("typedef union {");
		sifbPrinter.smartPrint("UDINT events;");
		sifbPrinter.smartPrint("struct {");
		sifbPrinter.smartPrint("UDINT INITO : 1; // initialization confirm");
		sifbPrinter.smartPrint("UDINT IND : 1; // service indication");
		sifbPrinter.smartPrint("} event;");
		sifbPrinter.smartPrint("} SUBL" + postfix + "OEvents;", 1);

		sifbPrinter.smartPrint("typedef struct {");
		sifbPrinter.smartPrint("BOOL _entered;");
		sifbPrinter.smartPrint("SUBL" + postfix + "IEvents _input;");
		sifbPrinter.smartPrint("SUBL" + postfix + "OEvents _output;");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String type = anyTypes[i-1].getType();
			if (type.equalsIgnoreCase("ANY"))
				type = "BOOL";
			String portName = "RD_" + i;
			sifbPrinter.smartPrint(type + " _" + portName + 
					getArrayIndex(anyTypes[i-1].getArraySize(), fullyQualifiedInsName,
							portName) + ";");
		}
		sifbPrinter.smartPrint(globalType + "* _globalBuf;");
		sifbPrinter.smartPrint("} SUBL" + postfix + ";", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "init(SUBL" + postfix + "* me, " + 
				globalType + "* global);", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "run(SUBL" + postfix + "* me);", 1);

		sifbPrinter.smartPrint("#endif /*SUBL" + postfix + "_H_*/");
		sifbPrinter.close();
	}
	
	/**
	 * Prints the .c file for SUBL service interface function blocks.
	 * @param file name of the SUBL file
	 * @throws IOException
	 */
	protected void printSUBL_c_file(String file) throws IOException {
		if (fileNames.contains(file))
			return;
		CodePrinter sifbPrinter = new CodePrinter(file);
		fileNames.add(file);
		
		String postfix = sifbInfo.getPostfix();
		sifbPrinter.print("// This file is generated by FBC.", 1);
		
		sifbPrinter.print("#include \"SUBL" + postfix + ".h\"");
		sifbPrinter.print("#include <string.h>", 1);
		
		sifbPrinter.smartPrint("/* SUBL" + postfix + " initialization function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "init(SUBL" + postfix + "* me, " + 
				sifbInfo.getGlobalVarType() + "* global)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_entered = false;");
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("me->_output.events = 0;");
		sifbPrinter.smartPrint("me->_globalBuf = global;");
		sifbPrinter.smartPrint("}", 1);

		sifbPrinter.smartPrint("/* SUBL" + postfix + " execution function */");
		sifbPrinter.smartPrint("void SUBL" + postfix + "run(SUBL" + postfix + "* me)");
		sifbPrinter.smartPrint("{");
		sifbPrinter.smartPrint("me->_output.events = 0;", 1);
		sifbPrinter.smartPrint("if (!me->_entered) {");
		sifbPrinter.smartPrint("me->_entered = true;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else {");
		sifbPrinter.smartPrint("if (me->_input.event.INIT) {");
		sifbPrinter.smartPrint("me->_output.event.INITO = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("else if (me->_globalBuf->status & _NEW) {");
		DataType[] anyTypes = sifbInfo.getAnyTypes();
		for (int i = 1; i <= anyTypes.length; i++) {
			String index = Integer.toString(i);
			sifbPrinter.smartPrint( makeAssignment(anyTypes[i-1], "me->_RD_" + index, 
					"me->_globalBuf->buffer.data_" + index, (byte)1) );
		}
		sifbPrinter.smartPrint("me->_globalBuf->status &= ~_NEW;");
		sifbPrinter.smartPrint("me->_output.event.IND = 1;");
		sifbPrinter.smartPrint("}");
		sifbPrinter.smartPrint("}", 1);
		
		sifbPrinter.smartPrint("me->_input.events = 0;");
		sifbPrinter.smartPrint("}");		
		sifbPrinter.close();
	}

	/**
	 * Retrieves the desired SIFB and produces the corresponding code.
	 * @param fileName base name of the output file(s) produced
	 */
	protected void retrieveSIFB(String fileName) throws IOException {
		String blockName = sifbInfo.getBlockName();
		if (blockName.equals("SEND") || blockName.equals("RECV") ||
			blockName.equals("SENDD3") || blockName.equals("RECVD3")) {
			return;
		}
		
		if (blockName.equals("PUBL")) {
			printPUBL_h_file(fileName + ".h");
			printPUBL_c_file(fileName + filetype);
			return;
		}
		else if (blockName.equals("SUBL")) {
			printSUBL_h_file(fileName + ".h");
			printSUBL_c_file(fileName + filetype);
			return;
		}
		else if (blockName.endsWith("_HMI")) {
			OutputManager.printNotice(blockName, "Ignoring " + fileName + " for now.", 
					OutputLevel.INFO);
			return;
		}

		String file = fileName + ".h";
		if (fileNames.contains(file))
			return;
					
		String sourcePath = sifbInfo.getPath() + blockName;
		BufferedWriter out = null;
		BufferedReader in = null;
		try {
			out = new BufferedWriter(new FileWriter(file));
			fileNames.add(file);
			file = sourcePath + ".h";
			in = new BufferedReader(new FileReader(file));
		} catch (IOException e) {
			OutputManager.printError(fileName, file + ": Could not be opened.\n", 
					OutputLevel.FATAL);
			System.exit(-1);
		}
		copyFile(out, in);

		file = fileName + filetype;
		try {
			out = new BufferedWriter(new FileWriter(file));
			fileNames.add(file);
			file = sourcePath + filetype;
			in = new BufferedReader(new FileReader(file));
		} catch (IOException e) {
			OutputManager.printError(fileName, file + ": Could not be opened.\n", 
					OutputLevel.FATAL);
			System.exit(-1);
		}
		copyFile(out, in);
	}

	/**
	 * Generates code to perform send for local communication block.
	 * @param queue queue length 
	 * @param insName instance name of the local communication block 
	 * @param index number of data elements of the communication block 
	 * @param blockType type of local communication block 
	 * @param partnerType corresponding partner type of the communcation block 
	 * @param prefix prefix for generating code
	 */
	private void generateSend(int queue, String insName, int index,
			String blockType, String partnerType, String prefix)
			throws IOException {
		if (queue > 0) {
			String count = "_" + insName + "._count";
			String wrptr = "_" + insName + "._wrptr";
			String qlen = Integer.toString(queue);
			cprinter.print("if (" + count + " < " + qlen + ") {");
			cprinter.indent();
			for (int j = 0; j < index; j++) {
				String internal = makeLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				String external = makeIFLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				DataType data = FBtoStrl.getAnyDataType(insName, blockType, j + 1);
				String varType = data.getType();
				if (varType.equalsIgnoreCase("STRING") || varType.equalsIgnoreCase("WSTRING")) {
					cprinter.print("strcpy(" + internal + ", " + external + ");");
				}
				else {
					cprinter.print(internal + " = " + external + ";");
				}
			}
			cprinter.print(count + "++;");
			cprinter.print(wrptr + "++;");
			cprinter.print("if (" + wrptr + " >= " + qlen + ") ");
			cprinter.indent();
			cprinter.print(wrptr + " = 0;");
			cprinter.unindent();
			cprinter.print(prefix + blockType + "CNF = 1;");
			// cprinter.print(prefix + partnerType + "IND = 1;");
			cprinter.unindent();
			cprinter.print("}");
		}
		else {
			for (int j = 0; j < index; j++) {
				String internal = makeLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				String external = makeIFLocalDataAssignment(insName,
						Integer.toString(j + 1), blockType);
				DataType data = FBtoStrl.getAnyDataType(insName, blockType, j + 1);
				String varType = data.getType();
				if (varType.equalsIgnoreCase("STRING") || varType.equalsIgnoreCase("WSTRING")) {
					cprinter.print("strcpy(" + internal + ", " + external + ");");
				}
				else {
					cprinter.print(internal + " = " + external + ";");
				}
			}
			cprinter.print(prefix + "SHARED = 1;");
			cprinter.print(prefix + blockType + "CNF = 1;");
		}
	}
	
	/**
	 * Looks for SENDuCOS blocks that will be rescheduled among all the subblocks 
	 * in a function block network.
	 * @return List of all SENDuCOS blocks in the network
	 */
	ArrayList<String> getReschedSENDuCOSblocks() {
		ArrayList<String> sendBlocks = new ArrayList<String>();
		for (int i = 0; i < runs.length; i++) {
			// No run function for local communication blocks and adapters
			if (!isLocalComBlock(runs[i].getType()) && !runs[i].isPlug() && !runs[i].isSocket()) {
				if (runs[i].getType().startsWith("SENDuCOS_")) {
					String msgID = runs[i].getParamValue("ID");
					if (msgID == null)
						continue;
					MsgPeriods periods = msgPeriodMap.get(msgID);
					if (periods.getSendPeriod() > periods.getRecvPeriod())
						sendBlocks.add(runs[i].getType() + "send(&me->" + runs[i].name + ");");
				}
			}
		}
		return sendBlocks;
	}

	/**
	 * Generates code to instantiate the subblocks in a composite function block.
	 * @param fbName type name of function block network
	 */
	protected void printComposite(String fbName) throws IOException {
		// Print out the function block execution function
		cprinter.print("/* Function block execution function */");
		
		if (isUCOStask)
			cprinter.print("void " + fbName + "run(void* data)");
		else if (isTTPOStask || isD3task)
			cprinter.print("void " + fbName + "run(void)");
		else
			cprinter.print("void " + fbName + "run(" + fbName + "* me)");
		cprinter.print("{");
		cprinter.indent();
		
		ArrayList<String> sendUCOSblocks = null;
		if (isUCOStask) {
			if (lateCode != null)
				cprinter.print(lateCode, 1);
			String type = fbName + "*";
			cprinter.print(type + " me = (" + type + ")data;", 1);
			sendUCOSblocks = getReschedSENDuCOSblocks();			
			cprinter.print("for (;;) {");
			cprinter.indent();
			if (opts.timeAnnotate)
				cprinter.print("asm(\"#@PRET_Bound 1\");");
			cprinter.print("INT32U _startTime = OSTimeGet();");
		}
		else if (isTTPOStask || isD3task) {
			cprinter.print(fbName + "* me = &" + insName + ";", 1);
		}

		if (opts.isSimul()) {
			cprinter.println("clearChildren(me->_simevents);");
			cprinter.println("clearChildren(me->_simvars);");
			cprinter.println("clearChildren(me->_simconnections);");
		}
		ArrayList<LocalComInfo> localComEvents = new ArrayList<LocalComInfo>();

		// Update inputs for each sub-block
		for (int i = 0; i < runs.length; i++) {
			Set<Signal> signals = runs[i].getSignalSet();
			Iterator<Signal> j = signals.iterator();

			while (j.hasNext()) {
				Signal sig = j.next();
				if (sig.getPortType() != PortType.INPUT)
					continue;
				printInputBindings(runs[i], runs[i].getType(), runs[i].name, sig, 
						localComEvents, DelayType.DELAYALL);
			}
		}
		cprinter.print("");

		// Process local communication blocks
		HashSet<String> clearedInstances = new HashSet<String>();
		Iterator<LocalComInfo> e = localComEvents.iterator();
		while (e.hasNext()) {
			LocalComInfo localCom = e.next();
			// Clear all output events
			if (!clearedInstances.contains(localCom.insName)) {
				clearOutputEvents(localCom.blockType, localCom.insName);
				clearedInstances.add(localCom.insName);
			}

			// Update input event-data associations
			cprinter.print("if (" + localCom.testEvent + ") {");
			cprinter.indent();
			String prefix = makeLocalEvAssignment(localCom.insName, "", "", true);
			if (localCom.event.equals("REQ")) {
				generateSend(localCom.qlen, localCom.insName, localCom.index,
						localCom.blockType, localCom.partnerType, prefix);
			} 
			else if (localCom.event.equals("INIT")) {
				cprinter.print(prefix + localCom.blockType + "INITO = 1;");
			}
			cprinter.unindent();
			cprinter.print("}");
		}

		// Run each sub-block
		for (int i = 0; i < runs.length; i++) {
			// No run function for local communication blocks and adapters
			if (!isLocalComBlock(runs[i].getType()) && !runs[i].isPlug() && !runs[i].isSocket())
				cprinter.print(runs[i].getType() + "run(&me->" + runs[i].name + ");");
			if (opts.isSimul())
				printCompositeConnectionsForSim(runs[i]);
			
		}
		cprinter.print("");

		printCompositeOutputs(fbName);

		if (opts.isSimul()) {
			cprinter.print(fb.getCompiledType() + "_runXML(me);"); // before events cleared
		}
		if (isUCOStask) {
			String delay = null;
			for (Parameter p : params) {
				if (p.name.equals("RATE")) {
					delay = p.value;
					break;
				}
			}
			
			String declaration;
			if (!sendUCOSblocks.isEmpty()) {
				declaration = "";
				cprinter.smartPrint("INT32U _slackTime = _BASE_PERIOD * " + delay + " - (OSTimeGet() - _startTime);");
				cprinter.smartPrint("if (_slackTime > _BASE_PERIOD)");
				cprinter.indent();
				cprinter.smartPrint("OSTimeDly( (INT16U)(_slackTime - _BASE_PERIOD) );");
				cprinter.unindent();
				for (String callSend : sendUCOSblocks)
					cprinter.print(callSend);
			}
			else
				declaration = "INT32U ";
			cprinter.print(declaration + "_slackTime = _BASE_PERIOD * " + delay + 
				" - (OSTimeGet() - _startTime); // _BASE_PERIOD is defined in " + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h");
			cprinter.print("OSTimeDly(_slackTime);");
			cprinter.unindent();
			cprinter.print("}");
		}

		cprinter.unindent();
		cprinter.print("}");
	}

	Instance getInstance(FBInstance instance) {
		for (int i = 0; i < runs.length; i++) {
			if (runs[i].equals(instance))
				return runs[i];
			if (opts.isNxtControl() && runs[i].name == instance.name)
				return runs[i];
		}
		assert (false) : "Instance " + instance.name + ":" + instance.type + " cannot be found.\n";
		return null;
	}

	/**
	 * Generates topologically sorted code to instantiate the subblocks in a 
	 * composite function block.
	 * @param fbName type name of function block network
	 */
	protected void printSortedComposite(String fbName) throws IOException {
		// Print out the function block execution function
		cprinter.print("/* Function block execution function */");
		  
		if (isUCOStask)
			cprinter.print("void " + fbName + "run(void* data)");
		else if (isTTPOStask || isD3task)
			cprinter.print("void " + fbName + "run(void)");
		else
			cprinter.print("void " + fbName + "run(" + fbName + "* me)");
		cprinter.print("{");
		cprinter.indent();
		
		ArrayList<String> sendUCOSblocks = null;
		if (isUCOStask) {
			if (lateCode != null)
				cprinter.print(lateCode, 1);
			String type = fbName + "*";
			cprinter.print(type + " me = (" + type + ")data;", 1);
			sendUCOSblocks = getReschedSENDuCOSblocks();
			cprinter.print("for (;;) {");
			cprinter.indent();
			if (opts.timeAnnotate)
				cprinter.print("asm(\"#@PRET_Bound 1\");");
			cprinter.print("INT32U _startTime = OSTimeGet();");
		}
		else if (isTTPOStask || isD3task) {
			cprinter.print(fbName + "* me = &" + insName + ";", 1);
		}
		
		if (opts.isSimul()) {
			cprinter.println("clearChildren(me->_simevents);");
			cprinter.println("clearChildren(me->_simvars);");
			cprinter.println("clearChildren(me->_simconnections);");

		}
		HashSet<String> clearedInstances = new HashSet<String>();
		ArrayList<LocalComInfo> localComEvents = new ArrayList<LocalComInfo>();

		// Update delayed inputs for each sub-block 
		for (int i = 0; i < sortedNodes.length; i++) {
			Instance instance = getInstance(sortedNodes[i].getInstance());
			for (Signal sig : instance.getSignalSet()) {
				if (sig.getPortType() != PortType.INPUT)
					continue;
				printInputBindings(instance, instance.getType(), instance.name, sig, 
						localComEvents, DelayType.DELAYONLY);
			}
		}
		cprinter.print("");
		
		for (int i = 0; i < sortedNodes.length; i++) {
			Instance instance = getInstance(sortedNodes[i].getInstance());
			String insName = instance.name;
			String insType = instance.getType();
			
			// Update inputs for the sub-block
			Event[] events = sortedNodes[i].getInputEvents();
			if (events != null) {
				for (int j = 0; j < events.length; j++) {
					Signal sig = new Signal(new PortName(insName, insType,
							events[j].getName()), PortType.LOCAL);
					printInputBindings(instance, insType, insName, sig, localComEvents, 
							DelayType.DELAYNONE);
				}
			}
			VarDeclaration[] vars = sortedNodes[i].getInputVars();
			if (vars != null) {
				for (int j = 0; j < vars.length; j++) {
					Signal sig = new Signal(insName, insType, vars[j].getName(), 
							vars[j].getType(), vars[j].getArraySize(), PortType.INPUT);
					printInputBindings(instance, insType, insName, sig, localComEvents, 
							DelayType.DELAYNONE);
				}
			}

			if (isLocalComBlock(insType)) {
				// Process local communication blocks
				// Clear all output events
				if (!clearedInstances.contains(insName)) {
					clearOutputEvents(insType, insName);
					clearedInstances.add(insName);
					if (insType.startsWith("RECV_")) {
						cprinter.print("if (_" + insName + "._count > 0) {");
						cprinter.indent();
						cprinter.print("_" + insName + "._output.event.RECV_IND = 1;");
						cprinter.unindent();
						cprinter.print("}");
					}
				}

				// Update input event-data associations
				if (events != null) {
					String prefix = makeLocalEvAssignment(insName, "", "", true);
					String blockType = getComBlockType(insType);
					String partnerType = getComPartnerType(blockType);
					int[] indices = getComBlockIndices(insType);
					for (int j = 0; j < events.length; j++) {
						String event = events[j].getName();
						cprinter.print("if (" + makeLocalEvAssignment(insName, event,
								insType, false) + ") {");
						cprinter.indent();
						if (event.equals("REQ")) {
							generateSend(indices[1], insName, indices[0], blockType, 
									partnerType, prefix);
						} 
						else if (event.equals("INIT")) {
							cprinter.print(prefix + blockType + "INITO = 1;");
						}
						cprinter.unindent();
						cprinter.print("}");
					}
				}
			}
			else {
				if (!instance.isPlug() && !instance.isSocket()) {
					// No run function for adapters
					cprinter.print(insType + "run(&me->" + insName + ");", 1);
				}
			}

			if (opts.isSimul()) {
				printCompositeConnectionsForSim(sortedNodes[i]);
			}
		}

		printCompositeOutputs(fbName);

		if (opts.isSimul()) {
			cprinter.print(fb.getCompiledType() + "_runXML(me);"); // before events cleared
		}
		if (isUCOStask) {
			String delay = null;
			for (Parameter p : params) {
				if (p.name.equals("RATE")) {
					delay = p.value;
					break;
				}
			}
			
			String declaration;
			if (!sendUCOSblocks.isEmpty()) {
				declaration = "";
				cprinter.smartPrint("INT32U _slackTime = _BASE_PERIOD * " + delay + " - (OSTimeGet() - _startTime);");
				cprinter.smartPrint("if (_slackTime > _BASE_PERIOD)");
				cprinter.indent();
				cprinter.smartPrint("OSTimeDly( (INT16U)(_slackTime - _BASE_PERIOD) );");
				cprinter.unindent();
				for (String callSend : sendUCOSblocks)
					cprinter.print(callSend);
			}
			else
				declaration = "INT32U ";
			cprinter.print(declaration + "_slackTime = _BASE_PERIOD * " + delay + 
				" - (OSTimeGet() - _startTime); // _BASE_PERIOD is defined in " + 
				CProgGenerator.getGlobalVarsFileName(FBtoStrl.currentDeviceName) + "h");
			cprinter.print("OSTimeDly(_slackTime);");
			cprinter.unindent();
			cprinter.print("}");
		}

		cprinter.unindent();
		cprinter.print("}");
	}

	/**
	 * Generates input assignments for subblocks in a composite function block.
	 * @param instance instance of the subblock 
	 * @param insType type of the subblock instance
	 * @param insName name of the subblock instance
	 * @param sig input signal to be assigned 
	 * @param localComEvents container to specially handle local communication blocks 
	 * @param delayedOnly TRUE when printing delayed input signals in --sorted mode; FALSE otherwise
	 */
	private void printInputBindings(Instance instance, String insType, String insName, 
			Signal sig, ArrayList<LocalComInfo> localComEvents, DelayType delayType)
			throws IOException {
		HashSet<Signal> bindings = instance.getBindings(sig);
		if (sig.getSignal().contains("@CNT@")) {
			// TODO: multiple COUNT names... @CNT<other stuff>@
			String baseSignal = sig.getSignal();
			// A variable sized input :|
			for (int vs = 0; vs < 20; vs++) // assume max of 20
			{
				Signal varSig = new Signal(sig.getInstance(), sig.getInsType(),
						baseSignal.replace("@CNT@", "" + vs), sig.getSigType(),
						sig.getArraySize(), sig.getPortType());
				bindings = instance.getBindings(varSig);
				if (bindings == null)
					continue; // skip
				printInputBindings(instance, insType, insName, varSig, localComEvents, 
						delayType);
			}
			return;
		}
		// TODO: use same format as nxtStudio?
		else if (sig.getSignal().contains("${CNT}")) // nxtControl format...
		{
			String baseSignal = sig.getSignal();
			// A variable sized input :|
			for (int vs = 0; vs < 20; vs++) // assume max of 20
			{
				Signal varSig = new Signal(sig.getInstance(), sig.getInsType(),
						baseSignal.replace("${CNT}", "" + vs), sig.getSigType(), 
						sig.getArraySize(), sig.getPortType());
				bindings = instance.getBindings(varSig);
				if (bindings == null)
					continue; // skip
				printInputBindings(instance, insType, insName, varSig, localComEvents, 
						delayType);
			}
			return;
		}

		if (bindings == null)
			return;
		if (bindings.size() < 1)
			return;
		
		printCompositeInputs(instance, sig, localComEvents, bindings, delayType);
	}

	/**
	 * Creates data assignments for the sources of ANY type.
	 * @param instance instance name of the subblock 
	 * @param sig input port of the subblock 
	 * @param bind parameter/port bound to "sig" (the ANY type)
	 */
	/*
	private String makeAnySrcAssignment(Signal srcSig, Signal destSig) {
		StringBuilder line = new StringBuilder();
		boolean isString = srcSig.getSigType().equalsIgnoreCase("STRING");
		boolean isWString = srcSig.getSigType().equalsIgnoreCase("WSTRING");
		String insType = destSig.getInsType();
		PortType bindType = destSig.getPortType();

		String dst;
		if (destSig.getInstance().length() > 0)
			dst = "me->" + destSig.getInstance() + "._" + destSig.getSignal();
		else
			dst = "me->_" + destSig.getSignal();

		if (isLocalComBlock(insType)) {
			if (isString)
				line.append("strcpy(");
			else if (isWString)
				line.append("strcpy(");

			String src;
			if (bindType == PortType.LOCAL || bindType == PortType.LOCALDELAYED) {
				src = makeLocalDataAssignment(srcSig.getInstance(),
						getComPortIndex(srcSig.getSignal()), insType);
			} else {
				if (srcSig.getInstance().length() > 0)
					src = "me->" + srcSig.getInstance() + "._" + srcSig.getSignal();
				else
					src = "me->_" + srcSig.getSignal();
			}

			if (isString || isWString)
				line.append(dst + ", " + src + ");");
			else
				line.append(dst + " = " + src + ";");
		} 
		else {
			if (isString)
				line.append("strcpy(");
			else if (isWString)
				line.append("strcpy(");
			else
				line.append("memcpy(&");
			line.append(dst);

			String src;
			if (srcSig.getInstance().length() > 0)
				src = "me->" + srcSig.getInstance() + "._" + srcSig.getSignal();
			else
				src = "me->_" + srcSig.getSignal();

			if (isString || isWString)
				line.append(", " + src + ".buf);");
			else
				line.append(", " + src + ".buf, " + src + ".len);");
		}

		return line.toString();
	}
	*/

	/**
	 * Generates input assignments for subblocks in a composite function block.
	 * @param run instance of subblock 
	 * @param sig input signal to be assigned 
	 * @param localComEvents container to specially handle local communication blocks 
	 * @param bindings signals to be assigned to "sig"
	 * @param delayType specifies the type of input assignment being generated
	 */
	private void printCompositeInputs(Instance run, Signal sig, 
			ArrayList<LocalComInfo> localComEvents, HashSet<Signal> bindings, DelayType delayType) 
			throws IOException {
		if (sig.getSigType() == null) {			
			// Generate the left-hand-side of the assignment
			String sigName = sig.getSignal();
			StringBuilder line;
			if (!isLocalComBlock(run.type)) {
				line = new StringBuilder("me->" + run.name + "._input.event." + sigName);
			}
			else {
				line = new StringBuilder(makeLocalEvAssignment(run.name, sigName, run.type, false));
				localComEvents.add(new LocalComInfo(sigName, line.toString(), run.name, run.type));
			}
			String lhs = line.toString();
			
			// Generate the type of assignment
			line.append(" = ");
			if (delayType == DelayType.DELAYNONE) {
				// Check if we have bindings that mix delayed and non-delayed connections
				final byte DELAYED = 0x01;
				final byte NONDELAYED = 0x02;
				final byte MIXED = 0x03;
				byte connectionType = 0;
				for (Signal bind : bindings) {
					if (bind.getPortType() == PortType.LOCALDELAYED)
						connectionType |= DELAYED;
					else
						connectionType |= NONDELAYED;
					if (connectionType == MIXED)
						break;
				}
				if (connectionType == MIXED)
					line.append(lhs + " || ");
			}

			// Generate the right-hand-side of the assignment
			boolean printed = false;
			for (Signal bind : bindings) {
				PortType bindType = bind.getPortType();
				switch (delayType) {
					case DELAYALL:
						// For compilation without --sorted
						printed = printInputValue(bind, line, printed);
						break;
					case DELAYONLY:
						// Print LOCALDELAYED ports separately from others
						if (bindType == PortType.LOCALDELAYED)
							printed = printInputValue(bind, line, printed);
						break;
					case DELAYNONE:
						// Print out connections to all other ports
						if (bindType != PortType.LOCALDELAYED)
							printed = printInputValue(bind, line, printed);
						break;
				}
			}
			if (printed) {
				line.append(";");
				cprinter.print(line.toString());
			}
		}
		else {
			assert (bindings.size() == 1) : "Multiple bindings on data port " + run.name + 
					"." + sig.getSignal() + ".\n";
			Signal bind = bindings.iterator().next();
			if (delayType == DelayType.DELAYONLY && bind.getPortType() != PortType.LOCALDELAYED)
				return; // Don't print non-delayed
			if (delayType == DelayType.DELAYNONE && bind.getPortType() == PortType.LOCALDELAYED )
				return; // Don't print delayed
			// Print only non-parameters: parameters are printed in init function
			if (bind.getPortType() != PortType.PARAM) 
				printInputAssignments(run, sig, bind);
		}
	}
	
	/**
	 * Generates values to be assigned to input ports of a subblock in a network 
	 * @param bind value to be assigned 
	 * @param line buffer to store generated values 
	 * @param printed boolean flag to indicate if buffer already contains previous content
	 * @param delayType specifies the type of input assignment being generated
	 * @return TRUE if value was generated; FALSE otherwise
	 */
	private boolean printInputValue(Signal bind, StringBuilder line, boolean printed) {
		switch (bind.getPortType()) {
			case LOCALDELAYED:
			case LOCAL:
				if (printed)
					line.append(" || ");
				String insType = bind.getInsType();
				if (isLocalComBlock(insType)) {
					line.append(makeLocalEvAssignment(bind.getInstance(), bind.getSignal(), 
							insType, true));
				}
				else {
					line.append("me->" + bind.getInstance() + "._output.event." + bind.getSignal());
				}
				return true;
			case INPUT:
				if (printed)
					line.append(" || ");
				line.append("me->_input.event." + bind.getSignal());
				return true;
			case OUTPUT:
				if (printed)
					line.append(" || ");
				line.append("me->_output.event." + bind.getSignal());
				return true;
		}
		return false;
	}

	/**
	 * Generates assignments to the outputs of a composite function block.
	 * @param fbName - type name of composite function block
	 */
	private void printCompositeOutputs(String fbName) throws IOException {
		// Update outputs for each sub-block
		PortMap outputMap = new PortMap();
		HashMap<Signal, Signal> directConnections = fb.compositeFB
				.getDirectConnections();
		for (Signal src : directConnections.keySet()) {
			outputMap.add(directConnections.get(src), src);
		}

		for (int i = 0; i < runs.length; i++) {
			Set<Signal> signals = runs[i].getSignalSet();
			Iterator<Signal> j = signals.iterator();
			while (j.hasNext()) {
				Signal sig = j.next();
				if (sig.getPortType() != PortType.OUTPUT)
					continue;
				HashSet<Signal> bindings = runs[i].getBindings(sig);
				int size = bindings.size();
				if (size < 1)
					continue;
				Iterator<Signal> k = bindings.iterator();
				while (k.hasNext()) {
					Signal bind = k.next();
					PortType bindType = bind.getPortType();
					if (bindType == PortType.OUTPUT) {
						outputMap.add(bind, sig);
					}
				}
			}
		}
		Set<Signal> signals = outputMap.getSignalSet();
		Iterator<Signal> j = signals.iterator();
		while (j.hasNext()) {
			Signal sig = j.next();
			HashSet<Signal> bindings = outputMap.getBindings(sig);
			int size = bindings.size();
			if (size < 1)
				continue;
			if (sig.getSigType() == null) {
				StringBuilder line = new StringBuilder("me->_output.event."
						+ sig.getSignal() + " = ");
				Iterator<Signal> k = bindings.iterator();
				for (;;) {
					Signal bind = k.next();
					String insType = bind.getInsType();
					if (isLocalComBlock(insType)) {
						line.append(makeLocalEvAssignment(bind.getInstance(),
								bind.getSignal(), insType, true));
					} else if (bind.getInstance().length() == 0) {
						// output = something from the composite's interface..
						// i.e. input event
						line.append("me->_input.event." + bind.getSignal());
					} else {
						line.append("me->" + bind.getInstance()
								+ "._output.event." + bind.getSignal());
					}
					if (!k.hasNext())
						break;
					line.append(" || ");
				}
				line.append(";");
				cprinter.print(line.toString());
				if (opts.isSimul()) {
					// with an if event around it
					printEventOForSim(sig.getSignal(), true); 
				}
			} else {
				assert (size == 1) : "Multiple bindings on data port " + fbName
						+ "." + sig.getSignal() + ".\n";
				Signal bind = bindings.iterator().next();
				printOutputAssignments(sig, bind);
			}
		}

		// TODO: Composite block ignores Event-Data associtations
	}

	private void printECC(SyncState[] states) throws IOException {
		if (opts.isSimul()) {
			cprinter.print("me->_" + statePrefix
					+ "simstate = mxmlNewElement(me->_simstates,\"ECState\");");
		}

		if (opts.timeAnnotate) {
			cprinter.print("for (_PRET_BOUND_i = 0; _PRET_BOUND_i < 2; _PRET_BOUND_i++) {");
			cprinter.print("asm(\"#@PRET_Bound 2\");");
		} else
			cprinter.print("for (;;) {");

		cprinter.indent();
		cprinter.print("switch (me->_" + statePrefix + "state) {");

		if (opts.timeAnnotate) {
			cprinter.print("asm(\"#@PRET_switch_start 1\");");
		}

		cprinter.indent();
		for (int s = 0; s < states.length; s++) {
			cprinter.print("case " + Integer.toString(s) + ":");
			cprinter.indent();
			printState(states[s], states.length);
			cprinter.print("break;");
			cprinter.unindent();
		}
		cprinter.unindent();
		cprinter.print("}");
		cprinter.print("break;");
		cprinter.unindent();

		if (opts.timeAnnotate) {
			cprinter.print("asm(\"#@PRET_switch_end 1\");");
		}

		cprinter.print("}");
	}

	/**
	 * Prints the input assignments for a given subblock in a composite function block 
	 * @param instance instance of the subblock
	 * @param sig input port of the subblock 
	 * @param bind parameter/port bound to "sig"
	 */
	protected void printInputAssignments(Instance instance, Signal sig, Signal bind) 
			throws IOException {
		String sigName = sig.getSignal();
		String sigType = sig.getSigType();
		if (bind.getSigType() == null) { // bound to an Event !?!?
			OutputManager.printError(fb.getCompiledType() + "." + instance.name,
					"Port `" + sigName + "' is bound to event: " + bind.getFullName(), 
					OutputLevel.FATAL);
			System.exit(0);
		}
		if (bind.getSigType().equalsIgnoreCase("ANY")) {
			bind.setSigType(sigType);
		}
		else if (sigType.equalsIgnoreCase("ANY")) {
			// Ideally, it shouldn't get here :(
			// but it does because we create a new Signal from the VarDeclarations
			// Set sigType to be same as bind
			sig.setSigType(bind.getSigType());
		}

		boolean array;
		int size;
		String arraySize = sig.getArraySize();
		if (!arraySize.isEmpty()) {
			array = true;
			if (arraySize.equals("@CNT@") || arraySize.equals("${CNT}") /* nxtStudio format */) {
				// Just get size of binding
				if (bind.getPortType() == PortType.PARAM) {
					// Get array size from string
					size = 1; // always at least 1
					String source = bind.getSignal();
					while (source.indexOf(',') >= 0) {
						size++;
						source = source.replaceFirst(",", "");
					}
				}
				else {
					size = validateArraySize(bind.getArraySize());
					if (size <= 0) {
						OutputManager.printError(bind.getInsType(),
								"Port `" + bind.getSignal() + "' has an invalid array size.", 
								OutputLevel.FATAL);
						System.exit(0);
					}
				}
			}
			else {
				size = validateArraySize(arraySize);
				if (size <= 0) {
					OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
							"' has an invalid array size.", OutputLevel.FATAL);
					System.exit(0);
				}
			}
		}
		else {
			array = false;
			size = -1;
		}
		
		String[] lines;
		String dst = makeDataPortVarName(instance, sigName, "");
		PortType bindType = bind.getPortType();
		switch (bindType) {
			case PARAM:
				String[] params = parseParam(bind.getSigType(), sigName, bind.getSignal(), array);
				if (array && params.length > size) {
					OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
							"' has an invalid array initializer.", OutputLevel.FATAL);
					System.exit(0);
				}
				ArrayList<String> inits = new ArrayList<String>(params.length);
				if (array) {
					for (int i = 0; i < params.length; i++) {
						String index = "[" + i + "]";
						addInitString(inits, sigType, dst, index, params[i]);
					}
				}
				else
					addInitString(inits, sigType, dst, "", params[0]);
				lines = inits.toArray(new String[0]);
				break;
			case LOCAL:
			case LOCALDELAYED:
				lines = makeAssignment(size, sigType, dst, 
						makeDataPortVarName( getInstance(bind.getInstance()), 
								bind.getSignal(), "") );
				break;
			default:
				lines = makeAssignment(size, sigType, dst, "me->_" + bind.getSignal());
				break;
		}
		for (String line : lines)
			cprinter.smartPrint(line);
	}

	/**
	 * Prints the output assignments for a composite function block.
	 * @param sig output port of the composite function block 
	 * @param bind port bound to "sig"
	 */
	protected void printOutputAssignments(Signal sig, Signal bind) throws IOException {
		String sigName = sig.getSignal();
		String sigType = sig.getSigType();
		if (bind.getSigType().equalsIgnoreCase("ANY")) {
			bind.setSigType(sigType);
		}
		else if (sigType.equalsIgnoreCase("ANY")) {
			sig.setSigType(bind.getSigType());
		}
		
		int size;
		String arraySize = sig.getArraySize();
		if (!arraySize.isEmpty()) {
			size = validateArraySize(arraySize);
			if (size <= 0) {
				OutputManager.printError(sig.getInsType(), "Port `" + sigName + 
						"' has an invalid array size.", OutputLevel.FATAL);
				System.exit(0);
			}
		}
		else {
			size = -1;
		}
		
		String src;
		if (bind.getInstance().isEmpty()) {
			// output = something from the composite's interface..
			// i.e. input variable
			src = "me->_" + bind.getSignal();
		}
		else {
			src = makeDataPortVarName(getInstance(bind.getInstance()), bind.getSignal(), "");
		}
		String dst = "me->_" + sigName;
		
		String[] lines = makeAssignment(size, sigType, dst, src);
		for (String line : lines)
			cprinter.smartPrint(line);
	}
	
	public static final String getArrayIndex(boolean array, int index) {
		if (array)
			return "[" + Integer.toString(index) + "]";
		return "";
	}
	
	/**
	 * Creates the C variable name for a particular data port of a function block
	 * @param instance instance of the function block
	 * @param signal name of the data port
	 * @param index array index
	 * @return The string containing the C variable name
	 */
	private static String makeDataPortVarName(Instance instance, String signal, 
			String index) {
		if (instance.type.startsWith("SENDD3_") || instance.type.startsWith("RECVD3_")) {
			return "_" + instance.getGlobalVarName() + "_" + signal.substring(1) + index;
		}
		return "me->" + instance.getName() + "._" + signal + index;
	}
	
	/**
	 * Creates one or more assignment strings (for the case where the variable is an array).
	 * @param arrayIndex size of the array (-1 for non-array types)
	 * @param type type of variable in the assignment
	 * @param dst destination variable
	 * @param src source variable
	 * @return Returns the assignment string(s) created
	 */
	private String[] makeAssignment(int arrayIndex, String type, String dst, String src) {
		String[] assignments;
		String index;
		int k = 0;
		if (arrayIndex <= 0) {
			// This is not an array type
			assignments = new String[1];
			index = "";
		}
		else if (arrayIndex == 1) {
			// This is a degenerate array
			assignments = new String[1];
			index = "[0]";
		}
		else {
			assignments = new String[6];
			assignments[0] = "{";
			assignments[1] = "int i;";
			assignments[2] = "for (i = 0; i < " + arrayIndex + "; i++) {";
			assignments[4] = "}";
			assignments[5] = "}";
			k = 3;
			index = "[i]";
		}
		
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING")) {
			assignments[k] = "strcpy(" + dst + index + ", " + src + index + ");";
		}
		else {
			assignments[k] = dst + index + " = " + src + index + ";";
		}
		return assignments;
	}
	
	/**
	 * Creates one or more assignment strings (for the case where the variable is an array).
	 * @param var variable for assignment
	 * @param dstPrefix prefix for the destination variable
	 * @param srcPrefix prefix for the source variable
	 * @return Returns the assignment string(s) created
	 */
	private String[] makeAssignment(VarDeclaration var, String dstPrefix, 
			String srcPrefix) {		
		int k = 0;
		String index = null;
		String[] assignments = null;
		String name = var.getName();
		String arraySize = var.getArraySize();
		if (!arraySize.isEmpty()) {
			int arrayIndex = validateArraySize(arraySize);
			if (arrayIndex <= 0) {
				OutputManager.printError(insName, "Variable `" + name + 
						"\' has an invalid array size.", OutputLevel.FATAL);
				System.exit(0);
			}
			else if (arrayIndex == 1) {
				assignments = new String[1];
				index = "[0]";
			}
			else {
				assignments = new String[6];
				assignments[0] = "{";
				assignments[1] = "int i;";
				assignments[2] = "for (i = 0; i < " + arraySize + "; i++) {";
				assignments[4] = "}";
				assignments[5] = "}";
				k = 3;
				index = "[i]";
			}
		}
		else {
			assignments = new String[1];
			index = "";
		}
		
		String type = var.getType();
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING")) {
			assignments[k] = "strcpy(" + dstPrefix + name + index + ", " + srcPrefix +
					name + index + ");";
		}
		else {
			assignments[k] = dstPrefix + name + index + " = " + srcPrefix + name + index + ";";
		}
		return assignments;
	}
	
	/**
	 * Creates an assignment string for the case where one of the variables in the 
	 * assignment is a raw buffer.
	 * @param data data type of the variable used in the assigment
	 * @param dstVar destination variable
	 * @param srcVar source variable
	 * @param sizeofChoice 0 if the length of bytes to be assigned is determined by the
	 * source variable; otherwise, any other value if it is to be determined by the 
	 * destnation variable
	 * @return The assignment string created
	 */
	private static String makeAssignment(DataType data, String dstVar, String srcVar, 
			byte sizeofChoice) {
		String type = data.getType();
		boolean array = type.equalsIgnoreCase("STRING") || 
				type.equalsIgnoreCase("WSTRING") || !data.getArraySize().isEmpty();
		StringBuilder assignment = new StringBuilder();
		
		if (sizeofChoice == 0) {
			// Sizeof assignment is determined by srvVar
			assignment.append("memmove(&" + dstVar + ", ");
			if (!array)
				assignment.append("&");
			assignment.append(srcVar + ", sizeof(" + srcVar + "));");
		}
		else {
			// Sizeof assignment is determined by dstVar
			assignment.append("memmove(");
			if (!array)
				assignment.append("&");
			assignment.append(dstVar + ", &" + srcVar + ", sizeof(" + dstVar + "));");
		}
		
		return assignment.toString();
	}

	/* Generates the code for a basic function block */
	protected void generateBasicFB(String fbName) throws IOException {
		generateInterface(fbName, true, true);
		if (fb.getBasicFB() instanceof BasicHCECCFB) {
			formatHCECCStateTree(rootState); // Set childConditions for everything...
			stateIndex = 0;
			visited.clear();
			
			// TODO: NOTE:
			// HCECC relies on formatStateTree to set goto states JUST for the top ECC.
			// BUG: as a result however, states in top ECC will have duplicates of .childConditions...
		}

		formatStateTree(rootState);

		// Print out all procedure declarations
		if (procedures != null) {
			printer.print("/* ECC algorithms */");
			cprinter.print("/* ECC algorithms */");
			for (int i = 0; i < procedures.length; i++) {
				String proto = getPrototype(fbName, procedures[i]);
				printer.print(proto + ";");
				String comment = procedures[i].getComment();
				if (comment != null) {
					if (!comment.isEmpty())
						cprinter.print("/* " + comment + " */");
				}
				boolean noProto = (procedures[i].getPrototype() == null || procedures[i]
						.getPrototype().length() == 0);
				String algText = procedures[i].getText();
				if (algText != null && procedures[i].getLanguage().equalsIgnoreCase("ST")) {
					STFunctionsUsed = true;
					ByteArrayInputStream st = new ByteArrayInputStream(
							algText.getBytes());
					STtoC converter = new STtoC(st, true);
					algText = converter.getC();
					// TODO: ST will never have a prototype right?????
					// else convert that too...
				}
				if (algText != null && opts.timeAnnotate) {
					algText.replaceAll("printf", "//printf");
				}
				if (noProto) {
					cprinter.print(proto);
					cprinter.print("{");
					if (algText != null)
						cprinter.print(algText);
					cprinter.print("}", 1);
				}
				else if (algText != null)
					cprinter.print(algText, 1);
			}
			printer.print("");
		}

		// Print out the function block execution function
		cprinter.print("/* Function block execution function */");
		cprinter.print("void " + fbName + "run(" + fbName + "* me)");
		cprinter.print("{");
		cprinter.indent();
		if (opts.timeAnnotate) {
			cprinter.print("int _PRET_BOUND_i = 0;");
		}

		// Note: temp just to see how often we miss events due to simultaneous-ness
		// Counting bits set, Brian Kernighan's way

		/*
		 * cprinter.print(
		 * "unsigned int v = me->_input.events; // count the number of bits set in v"
		 * );
		 * cprinter.print("unsigned int c; // c accumulates the total bits set in v"
		 * ); cprinter.print("for (c = 0; v; c++)"); cprinter.print("{");
		 * cprinter
		 * .print("  v &= v - 1; // clear the least significant bit set");
		 * cprinter.print("}");
		 * 
		 * cprinter.print("if( c > 1 )"); cprinter.print(
		 * "    printf(\"**********WARNING MULTIPLE EVENTS PRESENT!!\\n\");",1);
		 */

		if (opts.isSimul()) {
			cprinter.println("clearChildren(me->_simevents);");
			cprinter.println("clearChildren(me->_simvars);");
			// Don't delete the _simstate node.. just peers.
			// Cclear embedded ECC states (create node each tick)
			cprinter.println("deleteNexts(me->_simstate);"); 
			cprinter.println("clearChildren(me->_simtransitions);");
		}

		if (oeArrayLen == 1)
			cprinter.print("me->_output.events = 0;", 1);
		else {
			for (int i = 0; i < oeArrayLen; i++)
				cprinter.print("me->_output.events[" + Integer.toString(i)
						+ "] = 0;");
			cprinter.print("");
		}

		// Update all input event-data associations
		if (inputData != null && inputEvents != null) {
			if (inputData.length > 0) {
				if (inputEvents.length > 1) {
					if (ieArrayLen < 2)
						cprinter.print("if (me->_input.events) {");
					else {
						StringBuilder buf = new StringBuilder("if (");
						int l = 0;
						for (;;) {
							buf.append("me->_input.events["
									+ Integer.toString(l) + "]");
							l++;
							if (l >= ieArrayLen)
								break;
							buf.append(" || ");
						}
						buf.append(") {");
						cprinter.print(buf.toString());
					}
					cprinter.indent();
				}
				for (int i = 0; i < inputEvents.length; i++) {
					if (inputEvents[i].withVar != null) {
						cprinter.print("if (me->_input.event."
								+ inputEvents[i].getName() + ") {");
						cprinter.indent();

						for (int j = 0; j < inputEvents[i].withVar.length; j++) {
							VarDeclaration var = inputEvents[i].withVar[j];
							if (var == null) {
								OutputManager.printNotice(insName,
										inputEvents[i].getName() + " is missing a withVar",
										OutputLevel.WARNING);
								continue;
							}

							String[] assignments = makeAssignment(var, "me->", "me->_");
							for (String assign : assignments)
								cprinter.smartPrint(assign);
						}
						cprinter.unindent();
						cprinter.print("}");
					}
				}
				if (inputEvents.length > 1) {
					cprinter.unindent();
					cprinter.print("}");
				}
			}
		}

		int numOfStates = gotoStates.size();
		if (numOfStates < 2) {
			if (rootState.conditions == null)
				printState(rootState, 1);
			else {
				cprinter.print("for (;;) {");
				cprinter.indent();
				printState(rootState, 1);
				cprinter.print("break;");
				cprinter.unindent();
				cprinter.print("}");
			}
		}
		else if (numOfStates == 2) {
			if (opts.timeAnnotate) {
				cprinter.print("for (_PRET_BOUND_i = 0; _PRET_BOUND_i < 2; _PRET_BOUND_i++) {");
				cprinter.print("asm(\"#@PRET_Bound 2\");");
			}
			else
				cprinter.print("for (;;) {");

			cprinter.indent();
			cprinter.print("if (me->_" + statePrefix + "state == 0) {");
			cprinter.indent();
			printState(rootState, 2);
			cprinter.unindent();
			cprinter.print("}");
			cprinter.print("else {");
			cprinter.indent();
			printState(gotoStates.getLast(), 2);
			cprinter.unindent();
			cprinter.print("}");
			cprinter.print("break;");
			cprinter.unindent();
			cprinter.print("}");
		} 
		else {
			if (opts.timeAnnotate) {
				cprinter.print("for (_PRET_BOUND_i = 0; _PRET_BOUND_i < 2; _PRET_BOUND_i++) {");
				cprinter.print("asm(\"#@PRET_Bound 2\");");
			} else
				cprinter.print("for (;;) {");

			cprinter.indent();
			cprinter.print("switch (me->_" + statePrefix + "state) {");

			if (opts.timeAnnotate)
				cprinter.print("asm(\"#@PRET_switch_start 1\");");

			cprinter.indent();
			for (int i = 0; i < numOfStates; i++) {
				cprinter.print("case " + Integer.toString(i) + ":");
				cprinter.indent();
				printState(gotoStates.get(i), numOfStates);
				cprinter.print("break;");
				cprinter.unindent();
			}
			cprinter.unindent();
			cprinter.print("}");
			cprinter.print("break;");
			cprinter.unindent();

			if (opts.timeAnnotate)
				cprinter.print("asm(\"#@PRET_switch_end 1\");");

			cprinter.print("}");
		}

		// Update all output event-data associations
		if (outputEvents != null) {
			for (int i = 0; i < outputEvents.length; i++) {
				if (outputEvents[i].withVar != null) {
					cprinter.print("if (me->_output.event." + 
							outputEvents[i].getName() + ") {");
					cprinter.indent();

					if (opts.isSimul()) {
						// no if event around it
						printEventOForSim(outputEvents[i].getName(), false); 
					}

					for (int j = 0; j < outputEvents[i].withVar.length; j++) {
						VarDeclaration var = outputEvents[i].withVar[j];
						String[] assignments = makeAssignment(var, "me->_", "me->");
						for (String assign : assignments)
							cprinter.smartPrint(assign);
					}
					cprinter.unindent();
					cprinter.print("}");
				} 
				else {
					if (opts.isSimul()) {
						// with if event around it
						printEventOForSim(outputEvents[i].getName(), true);
					}
				}
			}
			cprinter.println();
		}

		if (opts.isSimul()) {
			// before events cleared
			cprinter.print(fb.getCompiledType() + "_runXML(me);"); 
		}

		if (ieArrayLen == 1)
			cprinter.print("me->_input.events = 0;");
		else {
			for (int i = 0; i < ieArrayLen; i++)
				cprinter.print("me->_input.events[" + Integer.toString(i)
						+ "] = 0;");
		}

		cprinter.unindent();
		cprinter.print("}", 1);
	}

	/**
	 * Creates additional initialization arguments for service interface function
	 * blocks with global variables.
	 * @param ins function block instance
	 * @return String containing the additional initialization arguments.
	 */
	private String getExtraInitArgs(Instance ins) {
		GlobalVar global = ins.getGlobalVarForSIFB();
		if (global == null)
			return "";
		
		if (ins.getType().startsWith("SENDuCOS_")) {
			return ", " + global.getWriteMethod().getName() + ", " + 
					global.getWriteNullMethod().getName();
		}
		else if (ins.getType().startsWith("RECVuCOS_"))
			return ", " + global.getReadMethod().getName();
		else if (ins.getType().startsWith("PUBL_") || ins.getType().startsWith("SUBL_"))
			return ", &" + global.getRawTypeName();
		else
			return "";
	}

	/**
	 * Generates code for Structured Data types
	 * @param name
	 * 		- type name
	 * @param vars
	 * 		- variable in struct
	 * @throws IOException 
	 */
	public static void generateDataType(String name, VarDeclaration[] vars) throws IOException
	{
		CodePrinter dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".h");
		dprinter.print("// This file is generated by FBC.", 1);
		String def = makeHeaderMacro(name);
		dprinter.println("#ifndef " + def);
		dprinter.println("#define " + def);
		dprinter.println();
		dprinter.print("#include \"fbtypes.h\"", 1);
		dprinter.println("typedef struct {");
		dprinter.indent();
		if( vars != null )
		for(int v = 0; v < vars.length; v++)
		{
			String[] declaration = makeDeclaration(new VarType(Category.INTERNAL, vars[v]), "");
			for(String dec : declaration)
				if( dec != null )
					dprinter.println( dec );
		}
		dprinter.unindent();
		dprinter.println("} " + name + ";");
		
		// declare to / from string functions
		dprinter.println();
		dprinter.println("int "+name+"toString(char* str, "+name+"* value);");
		dprinter.println("bool valueOf"+name+"("+name+"* value, char* str);");
		dprinter.println();
		
		dprinter.println("#endif // " + def);
		dprinter.close();
		
		// DEFINE UDT to/from string functions
		dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".c");
		dprinter.println("#include \""+name+".h\"");
		dprinter.println("#include \"datatypes.h\"");
		dprinter.println();
		dprinter.println("int "+name+"toString(char* str, "+name+"* value){");
		dprinter.indent();
			dprinter.println("int offset = 0, sublength;");
			dprinter.print("str[offset++] = '{';");
			if( vars != null )
			for(int v = 0; v < vars.length; v++)
			{
				if( vars[v].getArrayLength() > 1 )
				{
					dprinter.print("str[offset++] = '[';");
					for(int index = 0; index < vars[v].getArrayLength(); index++)
					{
						dprinter.println("sublength = "+vars[v].getType()+"toString(str+offset,&(value->"+vars[v].getName()+"["+index+"]));");
						dprinter.println("offset += sublength;");
						if( index < (vars[v].getArrayLength()-1) )
							dprinter.print("str[offset++] = ',';");
					}
					dprinter.print("str[offset++] = ']';");
				}
				else
				{
					dprinter.println("sublength = "+vars[v].getType()+"toString(str+offset, &value->"+vars[v].getName()+");");
					dprinter.println("offset += sublength;");
				}
				if( v < (vars.length-1) )
					dprinter.print("str[offset++] = ',';");
			}
			dprinter.print("str[offset++] = '}';");
			dprinter.println("return offset; // i.e. Length");
		dprinter.unindent();
		dprinter.println("}");
		dprinter.println();
		dprinter.println("bool valueOf"+name+"("+name+"* value, char* str){");
		dprinter.indent();
			dprinter.println("bool success;");
			dprinter.println("char* substrofStr = str;");
			if( vars != null )
			for(int v = 0; v < vars.length; v++)
			{
				if( vars[v].getArrayLength() > 1 )
				{
					// TODO:
					dprinter.println("return FALSE;");
				}
				else
				{
					dprinter.println("success = valueOf"+vars[v].getType()+"(&value->"+vars[v].getName()+", substrofStr);");
					dprinter.println("if( !success ) return FALSE;");
				}
			}
			dprinter.println("return TRUE;");
		dprinter.unindent();
		dprinter.println("}");
		dprinter.close();
	}
	
	/**
	 * Generates code for Enumerated Data types
	 * @param name
	 * 		- type name
	 * @param values
	 * 		- valuesin enum
	 * @throws IOException 
	 */
	public static void generateDataType(String name, EnumeratedValue[] values) throws IOException
	{
		CodePrinter dprinter = new CodePrinter(FBtoStrl.opts.outputpath() + name + ".h");
		dprinter.println("// This file is generated by FBC.");
		String def = makeHeaderMacro(name);
		dprinter.println("#ifndef " + def);
		dprinter.println("#define " + def);
		dprinter.println();
		dprinter.println("typedef enum {");
		dprinter.indent();
		if( values != null )
		for(int v = 0; v < values.length; v++)
		{
			dprinter.println( values[v].getName() + (v<(values.length-1)?",":""));
		}
		dprinter.unindent();
		dprinter.println("} "+name+";");
		dprinter.println("#endif // " + def);
		dprinter.close();
	}
	
	
	
	/**
	 * Generates the function block's interface related code if( simulation )
	 * creates the block's own "Instance" node me->_simdata;
	 * 
	 * @param fbName
	 *            - name of the function block type
	 * @param c
	 *            - true if definition file is to be generated; otherwise false
	 * @param basic
	 *            - true if interface to be generated is for a basic FB
	 */
	protected void generateInterface(String fbName, boolean c, boolean basic)
			throws IOException {
		int vectorSize = getNumOfIEvents() * 2;

		if (c) {
			cprinter.print("/* Function block initialization function */");
			cprinter.print("void " + fbName + "init(" + fbName + "* me)");
			cprinter.print("{");
			cprinter.indent();
			if (rootState != null) {
				if (fb.getNumOfECStates() > 1)
					cprinter.print("me->_" + statePrefix + "state = 0;");
				cprinter.print("me->_" + statePrefix + "entered = false;");
			}
			if (ieArrayLen == 1)
				cprinter.print("me->_input.events = 0;");
			else {
				for (int i = 0; i < ieArrayLen; i++)
					cprinter.print("me->_input.events[" + Integer.toString(i)
							+ "] = 0;");
			}
			if (oeArrayLen == 1)
				cprinter.print("me->_output.events = 0;");
			else {
				for (int i = 0; i < oeArrayLen; i++)
					cprinter.print("me->_output.events[" + Integer.toString(i)
							+ "] = 0;");
			}
			if (opts.isSimul()) {
				cprinter.println("me->_simdata = mxmlNewElement( MXML_NO_PARENT, \"Instance\"); // inited to main's tree later.. but make sure it's usable without");
			}
		}

		if (ieArrayLen > 0) {
			printer.print("typedef union {");
			printer.indent();
			if (ieArrayLen == 1)
				printer.print("UDINT events;");
			else
				printer.print("UDINT events["
						+ Integer.toString(ieArrayLen) + "];");
			printer.print("struct {");
			printer.indent();

			// Print out all input event declarations
			if (inputEvents != null) {
				for (int i = 0; i < inputEvents.length; i++) {
					String buf = "UDINT " + inputEvents[i].getName()
							+ " : 1;";
					if (inputEvents[i].getComment() != null)
						buf = buf + " // " + inputEvents[i].getComment();
					printer.print(buf);
				}
			}
			printer.unindent();
			printer.print("} event;");
			printer.unindent();
			printer.print("} " + fbName + "IEvents;", 1);
		}

		// Print out all output event declarations
		if (outputEvents != null) {
			printer.print("typedef union {");
			printer.indent();
			if (oeArrayLen == 1)
				printer.print("UDINT events;");
			else
				printer.print("UDINT events["
						+ Integer.toString(oeArrayLen) + "];");
			printer.print("struct {");
			printer.indent();
			for (int i = 0; i < outputEvents.length; i++) {
				String buf = "UDINT " + outputEvents[i].getName()
						+ " : 1;";
				if (outputEvents[i].getComment() != null)
					buf = buf + " // " + outputEvents[i].getComment();
				printer.print(buf);
			}
			printer.unindent();
			printer.print("} event;");
			printer.unindent();
			printer.print("} " + fbName + "OEvents;", 1);
		}

		String comment = fb.getComment();
		if (comment != null) {
			if (!comment.isEmpty())
				printer.print("/* " + comment + " */");
		}
		printer.print("typedef struct {");
		printer.indent();
		if (basic) {
			if (fb.getBasicFB() instanceof BasicHCECCFB) {
				BasicHCECCFB hceccfb = (BasicHCECCFB) fb.getBasicFB();
				LinkedList<String> eccNames = new LinkedList<String>();
				hceccfb.getHCECC().getECCNames(eccNames);
				for (String eccName : eccNames)
				{
					printer.print("UINT _" + eccName + "state;");
					printer.print("BOOL _" + eccName + "entered;");
				}
			}
			// ROOT ecc uses these... even though PERHAPS they should be using
			// _"ecc.name"state
			if (fb.getNumOfECStates() > 1)
				printer.print("UINT _" + statePrefix + "state;");
			printer.print("BOOL _" + statePrefix + "entered;");
		}
		if (rprinter != null) {
			rprinter.print("typedef struct {");
			rprinter.indent();
		}
		if (opts.isQTSimul())
			SimHelpers.startQTInterface();

		if (ieArrayLen > 0) {
			printer.print(fbName + "IEvents _input;");
			if (rprinter != null)
				rprinter.print(fbName + "IEvents _input;");
			if (opts.isQTSimul())
				SimHelpers.printQTEvents(fbName, true);
		}
		
		String blockID = fullyQualifiedInsName.isEmpty() ? fbName : fullyQualifiedInsName;

		// Print out all input data declarations and their internal registers
		if (inputData != null) {
			for (int i = 0; i < inputData.length; i++) {
				if (isUCOStask) {
					String varName = inputData[i].getName();
					if (varName.equals("RATE") || varName.equals("PRIO"))
						continue;
				}
				String[] str = makeDeclaration(inputData[i], blockID);
				for (int j = 0; j < str.length; j++) {
					if (!basic)
						j = 1;
					assert (str[j] != null) : "Cannot make input data declaration.\n";
					printer.print(str[j]);
				}
				if (rprinter != null)
					rprinter.print(str[1]);
				if (opts.isQTSimul())
					SimHelpers.printQTData(str[1]);
				if (c) {
					byte iface = basic ? (byte)0x03 : (byte)0x02;
					str = makeInitialization(inputData[i], "me->", iface, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
			vectorSize += (inputData.length * 16);
		}

		if (oeArrayLen > 0) {
			printer.print(fbName + "OEvents _output;");
			if (rprinter != null)
				rprinter.print(fbName + "OEvents _output;");
			if (opts.isQTSimul())
				SimHelpers.printQTEvents(fbName, false);
		}

		// Print out all output data declarations and their internal registers
		if (outputData != null) {
			for (int i = 0; i < outputData.length; i++) {
				String[] str = makeDeclaration(outputData[i], blockID);
				for (int j = 0; j < str.length; j++) {
					if (!basic)
						j = 1;
					assert (str[j] != null) : "Cannot make output data declaration.\n";
					printer.print(str[j]);
				}
				if (rprinter != null)
					rprinter.print(str[1]);
				if (opts.isQTSimul())
					SimHelpers.printQTData(str[1]);
				if (c) {
					byte iface = basic ? (byte)0x03 : (byte)0x02;
					str = makeInitialization(outputData[i], "me->", iface, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
		}

		// Print out all internal variable declarations
		if (internalVars != null) {
			for (int i = 0; i < internalVars.length; i++) {
				String[] str = makeDeclaration(internalVars[i], blockID);
				assert (str[0] != null) : "Cannot make internal variable declaration.\n";
				printer.print(str[0]);

				if (c) {
					str = makeInitialization(internalVars[i], "me->", (byte)0x01, 
							fullyQualifiedInsName);
					for (String s : str)
						cprinter.print(s);
				}
			}
		}
		
		/* Kyle: 
		// Print out all method reference declarations
		if (methodReferences != null) {
			for (int i = 0; i < methodReferences.length; i++) {
				String buf = "void* " + methodReferences[i].getName() + ";";
				printer.print(buf);
			}
		}
		*/

		// Print out all sub-blocks
		if (!basic) {
			for (int i = 0; i < runs.length; i++) {
				if (!isLocalComBlock(runs[i].getType()))
					printer.print(runs[i].getType() + " " + runs[i].name + ";");
			}

		}

		if (opts.isSimul()) {
			printer.println("mxml_node_t *_simdata, *_simevents, *_simvars;");

			if (fb.getBasicFB() != null) {
				printer.println("mxml_node_t *_simstates, *_simtransitions;");
				printer.println("mxml_node_t *_simstate;");
				if (fb.getBasicFB() instanceof BasicHCECCFB) {
					LinkedList<String> eccNames = new LinkedList<String>();
					((BasicHCECCFB) fb.getBasicFB()).getHCECC().getECCNames(eccNames);
					for (String eccName : eccNames)
						printer.println("mxml_node_t *_" + eccName
								+ "simstate;");
				}
			}

			if (fb.getCompositeFB() != null) {
				printer.println("mxml_node_t *_siminstances, *_simconnections;");
			}

			if (fb.isPretC()) {
				printer.println("mxml_node_t *_simlines;");
				printer.println("mxml_node_t *_simstate;");
			}
		}

		printer.unindent();
		printer.print("} " + fbName + ";", 1);
		if (rprinter != null) {
			rprinter.unindent();
			rprinter.print("} " + fbName + "Reg;", 1);
		}
		if (opts.isQTSimul())
			SimHelpers.endQTInterface(fbName);

		if (c) {
			if (!basic) {
				for (int i = 0; i < runs.length; i++) {
					if (!isLocalComBlock(runs[i].getType())
							&& !runs[i].getType().endsWith("_HMI")
							&& !runs[i].isPlug() && !runs[i].isSocket()) {
						// HMI Blocks inited in main function
						cprinter.print(runs[i].getType() + "init(&me->" + runs[i].name + 
								getExtraInitArgs(runs[i]) + ");");
					}
				}
				// NOW Print Params
				// Print out all Parameter initialisations
				for (int i = 0; i < runs.length; i++) {
					Set<Signal> signals = runs[i].getSignalSet();
					Iterator<Signal> j = signals.iterator();
					while (j.hasNext()) {
						Signal sig = j.next();
						if (sig.getSigType() == null) // is an event... PASS
							continue;
						if (sig.getPortType() != PortType.INPUT)
							continue;
						HashSet<Signal> bindings = runs[i].getBindings(sig);
						if (bindings.size() < 1)
							continue;
						Signal bind = bindings.iterator().next();
						
						// Print only the input ports that are attached to parameters
						if (bind.getPortType() != PortType.PARAM)
							continue;
						
						// Need special handling when compiling local communication blocks, 
						// since their parameters may have special meaning
						String type = runs[i].getType();
						if (type.startsWith("PUBL_") || type.startsWith("SUBL_")) {
							if (sig.getSignal().equals("ID"))
								continue;
						}
						else if (opts.isGNUuCOS()) {
							// Need special handling when compiling for uCOS, since
							// the parameters of communication blocks may have 
							// special meaning
							if (type.startsWith("SENDuCOS_") || type.startsWith("RECVuCOS_")) {
								if (sig.getSignal().equals("ID"))
									continue;
							}
						}
						else if (opts.isD3()) {
							// Need special handling when compiling for D3, since
							// the parameters of communication blocks may have 
							// special meaning
							if (type.startsWith("SENDD3_") || type.startsWith("RECVD3_")) {
								if (sig.getSignal().equals("ID"))
									continue;
							}
						}
						else {
							printInputAssignments(runs[i], sig, bindings.iterator().next());
						}
					}
				}
				
				/* Kyle:
				// Print method connections
				HashMap<Signal, Signal> directMethodConnections = fb.compositeFB.getDirectMethodConnections();
				for (Signal src : directMethodConnections.keySet()) {
					String buf = "me->" + src.toString() + " = &(me->" + directMethodConnections.get(src).toString() +");";
					cprinter.print(buf);
				}
				*/
			}
			cprinter.unindent();
			cprinter.print("}", 1);
		}

		printer.print("/* Function block initialization function */");
		printer.print("void " + fbName + "init(" + fbName + "* me);", 1);

		printer.print("/* Function block execution function */");
		if (isUCOStask)
			printer.print("void " + fbName + "run(void* data);", 1);
		else if (isTTPOStask || isD3task) {
			printer.print("void " + fbName + "run(void);", 1);
			printer.print("extern " + fbName + " " + insName + ";", 1);
		}
		else
			printer.print("void " + fbName + "run(" + fbName + "* me);", 1);

		if (rprinter != null) {
			// Extra functions for windows
			rprinter.print("#ifdef _MSC_VER");
			rprinter.print("#include <windows.h>");
			rprinter.print("#include <time.h>");
			rprinter.print("int gettimeofday(struct timeval* tp, void* tzp)");
			rprinter.print("{ ");
			rprinter.print("    DWORD t;");
			rprinter.print("    t = GetTickCount();");
			rprinter.print("    tp->tv_sec = t / 1000;");
			rprinter.print("    tp->tv_usec = (t % 1000) * 1000; ");
			rprinter.print("    return 0; // 0 indicates that the call succeeded.");
			rprinter.print("}", 1);
			rprinter.print("void timersub( const struct timeval * tvp, const struct timeval * uvp, struct timeval* vvp )");
			rprinter.print("{ ");
			rprinter.print("    vvp->tv_sec = tvp->tv_sec - uvp->tv_sec;");
			rprinter.print("    vvp->tv_usec = tvp->tv_usec - uvp->tv_usec;");
			rprinter.print("    if( vvp->tv_usec < 0 )");
			rprinter.print("    { ");
			rprinter.print("       --vvp->tv_sec;");
			rprinter.print("       vvp->tv_usec += 1000000;");
			rprinter.print("    }");
			rprinter.print("}");
			rprinter.print("#endif // _MSC_VER", 1);

			if (FBtoStrl.startUpFile.length() > 0) {
				try {
					File CfileFILE = new File(FBtoStrl.startUpFile);
					InputStream inputStream = new FileInputStream(CfileFILE);
					BufferedReader Cfile = new BufferedReader(new InputStreamReader(inputStream));
					String line = Cfile.readLine();
					for(;;line = Cfile.readLine()) {
						if (line == null) {
							break;
						}
						rprinter.print(line);
					}
					Cfile.close();
				}catch(IOException e){
					e.printStackTrace();
					System.out.println("Startup file open error:" + e);
				}
			}
			
			rprinter.print("int main(int argc, char* argv[])");
			rprinter.print("{");
			rprinter.indent();
			if (FBtoStrl.startUpFile.length() > 0) {
				rprinter.print("startup();\n");
			}
			rprinter.print(fbName + "Reg _sysInterface;");
			rprinter.print(fbName + " _var;");

			String arraySize = ""; // only used for testBench
			arraySize = Integer.toString(vectorSize + 3);

			if (opts.isTestBench()) {
				rprinter.print("FILE* vectorFile;");
				// rprinter.print("if ((vectorFile = fopen(argv[1], \"rb\")) == NULL) {");
				rprinter.print("char vector[" + arraySize + "];");
				rprinter.print("char* token;");
				rprinter.print("struct timeval _startTime, _endTime, _result;");
				rprinter.print("int repeatLoop = 0;");
				rprinter.print("bool testBenchOnly = false;");
				rprinter.print("long long loopTime = 0;");
				rprinter.print("long long totalTime = 0;");
				rprinter.print("long long avgFull = 0;");
			}

			rprinter.print("memset(&_sysInterface, 0, sizeof(" + fbName + "Reg));");
			rprinter.print("memset(&_var, 0, sizeof(" + fbName + "));");
			if (inputData != null) {
				for (int i = 0; i < inputData.length; i++) {
					String[] str = makeInitialization(inputData[i], "_sysInterface.", 
							(byte)0x02, fullyQualifiedInsName);
					for (String s : str)
						rprinter.print(s);
				}
			}

			rprinter.print(fbName + "init(&_var);", 1);

			if (!opts.isTestBench() && fb.inputEvents != null
					&& fb.inputEvents[0].getName().equalsIgnoreCase("INIT")) {
				// Force initing
				rprinter.print(fbName + "run(&_var);", 0);
				rprinter.print(
						"_var._input.event." + fb.inputEvents[0].getName() + " = 1;", 0);
				rprinter.print(fbName + "run(&_var);", 0);
				rprinter.print("_var._input.event." + fb.inputEvents[0].getName() + " = 0;", 0);
			}

			rprinter.flushBuf();

			if (opts.isTestBench()) {
				rprinter.print("/*************************************************/");
				rprinter.print("// If this is a simulation, open test vector file here");
				/*
				 * rprinter.print("if (argc < 2) {"); rprinter.print(
				 * "    printf(\"Missing arguments for input vector file.\\n\");"
				 * ); rprinter.print("    return 1;"); rprinter.print("}");
				 */
				rprinter.print("printf(\"Full:\\n\");");

				rprinter.print("for(;repeatLoop < 30; repeatLoop++){");
				rprinter.indent();
				rprinter.print("if( repeatLoop == 15 ){");
				rprinter.print("testBenchOnly = true; // TESTBENCHONLYMODE");
				rprinter.print("// Get Average for Full");
				rprinter.print("avgFull = totalTime/(long long)15;");
				rprinter.print("printf(\"Average: %lld us.\\n\\n\",avgFull);");

				rprinter.print("printf(\"TestBenchOnly:\\n\");");
				rprinter.print(fbName + "init(&_var);", 1);
				rprinter.print("totalTime = 0;");
				rprinter.unindent();
				rprinter.print("}");

				rprinter.print("if ((vectorFile = fopen(\"../Vectors/" + fbName
						+ "_Vector.txt\", \"rb\")) == NULL) {");
				rprinter.print("    printf(\"Cannot open file \\\"../Vectors/"
						+ fbName + "_Vector.txt\\\"\\n\");");
				rprinter.print("    return 1;");
				rprinter.print("}", 1);
				rprinter.print("// Read inputs here");
				rprinter.print("gettimeofday(&_startTime, NULL);");

				rprinter.print("/************************************************* -- Gareth thinks this is wrong...	");
				if (!opts.isSorted()) {
					rprinter.print("fgets(vector, " + arraySize
							+ ", vectorFile);");
					rprinter.print("token = strtok(vector, \" \");");
					makeTestbench();
				}

				rprinter.print("while (fgets(vector, " + arraySize
						+ ", vectorFile)) {");
				rprinter.indent();
				rprinter.print("token = strtok(vector, \" \");");
				rprinter.unindent();
				rprinter.print("}");
				rprinter.print("*************************************************/");

				// TODO: Temp add init event
				/*
				 * rprinter.print(fbName + "run(&_var);", 1);
				 * rprinter.print("_var._input.event.INIT = 1;",1);
				 * rprinter.print(fbName + "run(&_var);", 1);
				 * rprinter.print("_var._input.event.INIT = 0;",1);
				 */
			}
			
			if (opts.timeAnnotate) {
				rprinter.print("asm(\"#@PRET_Parse start\");");
				rprinter.print("asm(\"#@PRET_Thread start PRET_Node_main_ID_0\");");
			}
			rprinter.print("for (;;) {");
			rprinter.indent();

			if (!opts.isSorted()) {
				if (ieArrayLen > 0)
					rprinter.print("_var._input = _sysInterface._input;");
				if (inputData != null) {
					for (int i = 0; i < inputData.length; i++) {
						String[] assignments = makeAssignment(inputData[i], "_var._", 
								"_sysInterface._");
						for (String assign : assignments)
							rprinter.smartPrint(assign);
					}
				}
				if (ieArrayLen == 1)
					rprinter.print("_sysInterface._input.events = 0;");
				else {
					for (int i = 0; i < ieArrayLen; i++) {
						rprinter.print("_sysInterface._input.events["
								+ Integer.toString(i) + "] = 0;");
					}
				}
			}
			else {
				if (ieArrayLen == 1)
					rprinter.print("_var._input.events = 0;");
				else {
					for (int i = 0; i < ieArrayLen; i++) {
						rprinter.print("_var._input.events["
								+ Integer.toString(i) + "] = 0;");
					}
				}
			}

			if (opts.isTestBench()) {
				rprinter.print("/*************************************************/");
				rprinter.print("// Read inputs here");
				rprinter.print("if( !fgets(vector, " + arraySize
						+ ", vectorFile) ) break;");
				rprinter.print("token = strtok(vector, \" \");");

				makeTestbench();
				rprinter.print("/*************************************************/");
				/*
				 * rprinter.unindent(); rprinter.unindent();
				 * rprinter.print("#ifndef TESTBENCHONLY"); rprinter.indent();
				 * rprinter.indent();
				 */
				rprinter.print("if( !testBenchOnly )");
				rprinter.indent();
			}

			rprinter.print(fbName + "run(&_var);");

			if (opts.isTestBench()) {
				rprinter.unindent();

				/*
				 * rprinter.unindent(); rprinter.unindent();
				 * rprinter.print("#else");
				 * rprinter.print("#warning TESTBENCHONLY MODE");
				 * rprinter.print("#endif"); rprinter.indent();
				 * rprinter.indent();
				 */
			}

			if (!opts.isSorted()) {
				if (oeArrayLen > 0)
					rprinter.print("_sysInterface._output = _var._output;");
				if (outputData != null) {
					for (int i = 0; i < outputData.length; i++) {
						String[] assignments = makeAssignment(outputData[i], "_sysInterface._", 
								"_var._");
						for (String assign : assignments)
							rprinter.smartPrint(assign);
					}
				}
			}
			if (opts.timeAnnotate) {
				rprinter.print("asm(\"#@PRET_EOT start\");");
				rprinter.print("asm(\"#@PRET_EOT end\");");
			}
			rprinter.unindent();
			rprinter.print("}", 1);

			if (opts.isTestBench()) {
				rprinter.print("/*************************************************/");
				rprinter.print("// If this is a simulation, print out simulation time here");
				rprinter.print("gettimeofday(&_endTime, NULL);");
				rprinter.print("timersub(&_endTime, &_startTime, &_result);");
				rprinter.print("loopTime = (long long)(_result.tv_sec) * 1000000 + _result.tv_usec;");
				rprinter.print("totalTime += loopTime;");
				rprinter.print("printf(\"Time taken: %lld us.\\n\", loopTime);");
				rprinter.print(
						"/*************************************************/",
						1);
			} else {
				rprinter.print("return 0;");
			}

			rprinter.unindent();
			rprinter.print("}");
			rprinter.indent();

			if (opts.isTestBench()) {
				rprinter.print("// Get Average: ");
				rprinter.print("printf(\"Average: %lld us.\\n\\n\", totalTime/(long long)15);");
				rprinter.print("printf(\"Final Time: %lld us.\\n\\n\", avgFull - (totalTime/(long long)15));");
				rprinter.print("return 0;");
				rprinter.unindent();
				rprinter.print("}", 1); // extra loop to close
			}
		}

		if (opts.isSimul()) {
			// nothing
			SimHelpers.addInterface(fb);
			// printer.println("void "+fb.getName()+
			// "PrintStatuses("+fb.getName()+"* me, char* instancename, char* outbuf, int offset);");

		}
		else if (opts.isQTSimul()) {
			SimHelpers.setQTInterface(fb);
		}
	}

	/* Create a prototype testbench */
	protected void makeTestbench() throws IOException {
		// Assign all input events
		if (inputEvents != null) {
			for (int i = 0; i < inputEvents.length; i++)
				makeTestbenchEvent(inputEvents[i].getName());
		}

		// Print out all input data declarations and their internal registers
		if (inputData != null) {
			String variable = opts.isSorted() ? "_var._" : "_sysInterface._";
			for (int i = 0; i < inputData.length; i++) {
				// TODO: Handle Array
				if (inputData[i].getArraySize() != null
						&& inputData[i].getArraySize().length() > 0
						&& Integer.valueOf(inputData[i].getArraySize()) > 0)
					continue; // SKIP (FOR NOW)
				rprinter.print(variable + inputData[i].getName()
						+ " = strtol(token, NULL, 0);");
				rprinter.print("token = strtok(NULL, \" \");");
			}
		}
	}

	/**
	 * Create the statement for setting an event in the testbench
	 * @param event event to be set
	 */
	protected void makeTestbenchEvent(String event) throws IOException {
		rprinter.print("if (*token == \'1\') {");
		rprinter.indent();
		if (opts.isSorted())
			rprinter.print("_var._input.event." + event + " = 1;");
		else
			rprinter.print("_sysInterface._input.event." + event + " = 1;");
		rprinter.unindent();
		rprinter.print("}");
		rprinter.print("token = strtok(NULL, \" \");");
	}

	/**
	 * Create the declaration for the variable.
	 * @param var variable to declare
	 * @return String(s) used for the declaration of the variable
	 */
	protected static String[] makeDeclaration(VarType var, String blockID) {
		String varName = var.getName();
		String varType = var.getType();
		if (varType.equalsIgnoreCase("ANY")) {
			// Data type is still of type ANY. This means that the port is not bound:
			// Default unbound ANY port to BOOL.
			varType = "BOOL";
		}
		
		String array = getArrayIndex(var.getArraySize(), blockID, varName);
		String[] decl = new String[2];
		StringBuilder tmp = new StringBuilder(varType + " " + varName + array + ";");
		String comment = var.getComment();
		if (comment != null)
			tmp.append(" // " + comment);
		decl[0] = tmp.toString();

		if (var.isCategory(Category.IFACE_IN) || var.isCategory(Category.IFACE_OUT))
			decl[1] = varType + " _" + varName + array + ";";
		
		return decl;
	}

	/**
	 * Create the initialization for the variable.
	 * @param var variable to initialize 
	 * @param prefix prefix to the variable 
	 * @param iface 1 to create internal initialization; 2 to create external initialization;
	 * 3 to create internal and external initialization
	 * @param fqInsName fully qualified instance name
	 * @return String(s) used for the initialization of the variable
	 */
	public static String[] makeInitialization(VarType var, String prefix, byte iface, 
			String fqInsName) {
		String initial = var.getInitial();
		if (initial != null) {
			String type = var.getType();
			String name = var.getName();
			ArrayList<String> init = new ArrayList<String>();
			String arraySize = var.getArraySize();
			if (!arraySize.isEmpty()) {
				int size = validateArraySize(arraySize);
				if (size <= 0) {
					OutputManager.printError(fqInsName, "Variable `" + name + 
							"' has an invalid array size.", OutputLevel.FATAL);
					System.exit(0);
				}
				String[] tokens = parseArrayInitializer(initial, type, name, fqInsName);		
				if (tokens.length > size) {
					OutputManager.printError(fqInsName, "Variable `" + name + 
							"' has an invalid array initializer.", OutputLevel.FATAL);
					System.exit(0);
				}
				for (int i = 0; i < tokens.length; i++) {
					if (tokens[i].equals(""))
						continue;
					String index = "[" + i + "]";
					addInitString( init, var, prefix, iface, index, parseScalarParam(type, 
							tokens[i]) );
				}
			}
			else {
				addInitString( init, var, prefix, iface, "", parseScalarParam(type, 
						parseScalarInitializer(initial, type, name)) );
			}
			
			return init.toArray(new String[0]);
		}
		return new String[0];
	}

	/**
	 * Parses and tokenizes parameters to facilitate variable initialization.
	 * @param type variable type
	 * @param name variable name
	 * @param param parameter value
	 * @param array TRUE if parameter is an array; FALSE otherwise
	 * @return List containing the tokenized parameters.
	 */
	protected String[] parseParam(String type, String name, String param, boolean array) {  
		if (array) {
			ArrayList<String> tokens = new ArrayList<String>();
			String[] inits = parseArrayInitializer(param, type, name, fullyQualifiedInsName);
			for (String init : inits) {
				if (init.equals(""))
					continue;
				tokens.add(parseScalarParam(type, init));
			}
			return tokens.toArray(new String[0]);
		}
		else {
			String tokens[] = new String[1];
			tokens[0] = parseScalarParam( type, parseScalarInitializer(param, type, name) );
			return tokens;
		}
	}
	
	/**
	 * Parses a scalar initializer.
	 * @param initial string containing the initialization value
	 * @param varType type of variable to be initialized
	 * @param varName name of variable to be initialized
	 * @return The parsed initialization value
	 */
	public static String parseScalarInitializer(String initial, String varType, String varName) {
		initial = initial.trim();
		if (varType.equalsIgnoreCase("STRING"))
			return getStringInitializers(initial, '\'', varName)[0];
		else if (varType.equalsIgnoreCase("WSTRING"))
			return getStringInitializers(initial, '\"', varName)[0];
		else
			return initial;
	}
	
	/**
	 * Parses an array initializer.
	 * @param initial string containing the initialization value
	 * @param varType type of variable to be initialized
	 * @param varName name of variable to be initialized
	 * @param fqInsName fully qualified instance name
	 * @return The list of initialization values for the array
	 */
	public static String[] parseArrayInitializer(String initial, String varType, 
			String varName, String fqInsName) {
		initial = initial.trim();
		if (initial.charAt(0) != '[') {
			OutputManager.printError(fqInsName, "Initialization of array `" + varName + 
					"\' is missing `[\'.", OutputLevel.FATAL);
			System.exit(0);
		}
		
		int lastChar = initial.length() - 1;
		if (initial.charAt(lastChar) != ']') {
			OutputManager.printError(fqInsName, "Initialization of array `" + varName + 
					"\' is missing `]\'.", OutputLevel.FATAL);
			System.exit(0);
		}
		initial = initial.substring(1, lastChar).trim();
		
		String[] tokens;
		if (varType.equalsIgnoreCase("STRING"))
			tokens = getStringInitializers(initial, '\'', varName);
		else if (varType.equalsIgnoreCase("WSTRING"))
			tokens = getStringInitializers(initial, '\"', varName);
		else
			tokens = initial.split("[\\,\\s]");
		
		ArrayList<String> usefulTokens = new ArrayList<String>(tokens.length);
		for (String token : tokens) {
			if ( !token.trim().isEmpty() )
				usefulTokens.add(token);
		}
		
		return usefulTokens.toArray(new String[0]);
	}
	
	/**
	 * Makes and adds a string to the list of initialization strings
	 * @param init list containing initialization strings
	 * @param var variable to initialize 
	 * @param prefix prefix to the variable 
	 * @param iface 1 to create internal initialization; 2 to create external initialization;
	 * 3 to create internal and external initialization
	 * @param index array index if 'var' is an array type
	 * @param initial initial value
	 */
	private static void addInitString(ArrayList<String> init, VarType var, String prefix, 
			byte iface, String index, String initial) {
		String type = var.getType();
		boolean isString = type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING");
		if ((iface & 0x01) == 0x01) {
			if (isString)
				init.add("strcpy(" + prefix + var.getName() + index + ", " + initial + ");");
			else
				init.add(prefix + var.getName() + index + " = " + initial + ";");
		}
		if ((iface & 0x02) == 0x02) {
			if (var.isCategory(Category.IFACE_IN)  
					|| var.isCategory(Category.IFACE_OUT)) {
				if (isString) {
					init.add("strcpy(" + prefix + "_" + var.getName() + index + ", " + 
							initial + ");");
				}
				else
					init.add(prefix + "_" + var.getName() + index + " = " + initial + ";");
			}
		}
	}
	
	/**
	 * Makes and adds a string to the list of initialization strings
	 * @param inits list containing initialization strings
	 * @param type type of variable to be initialized
	 * @param dst variable to be initialized
	 * @param index array index if variable is an array type
	 * @param initial initial value
	 */
	private static void addInitString(ArrayList<String> inits, String type, String dst, 
			String index, String initial) {
		if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			inits.add("strcpy(" + dst + index + ", " + initial + ");");
		else
			inits.add(dst + index + " = " + initial + ";");
	}
	
	/**
	 * This parses and tokenizes an array of strings given as an initial value.
	 * @param initial initialization value
	 * @param delimiter string delimiter
	 * @param varName name of the string variable
	 * @return An array containing all the initial values for C strings.
	 */
	public static String[] getStringInitializers(String initial, char delimiter, String varName) {
		if (initial.charAt(0) != delimiter || initial.charAt(initial.length()-1) != delimiter) {
			OutputManager.printError("", "Expecting `" + delimiter + 
					"\' at the beginning and end of the initialization for " + varName + 
					".", OutputLevel.FATAL);
			System.exit(0);
		}
		
		ArrayList<String> tokens = new ArrayList<String>();
		StringBuilder token = new StringBuilder();
		boolean inString = false;
		boolean escape = false;
		int length = initial.length();
		for (int i = 0; i < length; i++) {
			char character = initial.charAt(i);
			if (!inString) {
				if (character == delimiter) {
					token.append('"');	// convert to C-style string literal
					inString = true;
				}
				else {
					// We gobble up all commas and whitespace (and any other characters!) 
					// here.
				}
			}
			else {
				if (!escape) {
					if (character == '$') {
						escape = true;
					}
					else {
						if (delimiter == '\'' && character == '"')
							token.append("\\\"");
						else if (character == delimiter) {
							token.append('"');	// convert to C-style string literal
							tokens.add(token.toString());
							token.delete(0, token.length());
							inString = false;
						}
						else
							token.append(character);
					}
				}
				else {
					switch (character) {
						case '\'':
						case '"':
							token.append('\\');
							token.append(character);
							break;
						case '$':
							token.append('$');
							break;
						case 'L':
						case 'l':
						case 'N':
						case 'n':
							// $N and $n is IEC 61131's means for specifying an 
							// implementation-independent newline character. Since there
							// is no such thing in C, we simply map it to the line feed.
							token.append("\\n");
							break;
						case 'P':
						case 'p':
							token.append("\\f");
							break;
						case 'R':
						case 'r':
							token.append("\\r");
							break;
						case 'T':
						case 't':
							token.append("\\t");
							break;
						default:
							// Skip everything else! This is not actually correct, but
							// ignore for now.
							break;
					}
					escape = false;
				}				
			}
		}
		
		// Check if the last element in the array initializer has been properly terminated
		if (inString) {
			OutputManager.printError("", "Expecting `" + delimiter + 
					"\' at the end of the initialization for " + varName + ".", 
					OutputLevel.FATAL);
			System.exit(0);
		}
		
		return tokens.toArray(new String[0]);
	}

	/**
	 * Converts values entered as text in the simulator to C-type values based 
	 * on the ST data types declared in the function block description. If a 
	 * user-type is defined, a custom conversion function must be supplied by 
	 * the user in order for the simulator to compile. 
	 * @param type the data type to be matched
	 * @return The C conversion function
	 */
	public static String getIConversionFunc(String type) {
		if (type.equalsIgnoreCase("BOOL")) {
			return "(strcasecmp(c, \"false\") && strcmp(c, \"0\"));";
		} else if (type.equalsIgnoreCase("SINT")
				|| type.equalsIgnoreCase("INT")
				|| type.equalsIgnoreCase("DINT")) {
			return "strtol(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("USINT")
				|| type.equalsIgnoreCase("UINT")
				|| type.equalsIgnoreCase("UDINT")
				|| type.equalsIgnoreCase("BYTE")
				|| type.equalsIgnoreCase("WORD")
				|| type.equalsIgnoreCase("DWORD")) {
			return "strtoul(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("LINT")) {
			return "strtoll(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("ULINT")
				|| type.equalsIgnoreCase("LWORD")) {
			return "strtoull(c, NULL, 0);";
		} else if (type.equalsIgnoreCase("REAL")) {
			return "strtof(c, NULL);";
		} else if (type.equalsIgnoreCase("LREAL")) {
			return "strtod(c, NULL);";
		} else if (type.equalsIgnoreCase("STRING")) {
			return "c";
		} else {
			return "CUSTOM_INPUT_FUNCTION(c);"; // user-defined type
		}
	}

	/**
	 * Converts output data of some ST data type to be displayed as text by the 
	 * simulator. If a user-type is defined, a custom conversion function must 
	 * be supplied by the user in order for the simulator to compile.
	 * @param type the data type to be matched 
	 * @param var the variable to display in textual form 
	 * @param text the textbox used for display 
	 * @return The function to display the text.
	 */
	public static String getOConversionFunc(String type, String var, String text) {
		if (type.equalsIgnoreCase("BOOL")) {
			return (var + " ? " + text + "(QString(\"true\")) : " + text + "(QString(\"false\"));");
		} else if (type.equalsIgnoreCase("SINT")
				|| type.equalsIgnoreCase("INT")
				|| type.equalsIgnoreCase("DINT")) {
			return (text + "(QString(\"%1\").arg((int)" + var + "));");
		} else if (type.equalsIgnoreCase("USINT")
				|| type.equalsIgnoreCase("UINT")
				|| type.equalsIgnoreCase("UDINT")
				|| type.equalsIgnoreCase("BYTE")
				|| type.equalsIgnoreCase("WORD")
				|| type.equalsIgnoreCase("DWORD")) {
			return (text + "(QString(\"%1\").arg((unsigned int)" + var + "));");
		} else if (type.equalsIgnoreCase("LINT")) {
			return (text + "(QString(\"%1\").arg((long long)" + var + "));");
		} else if (type.equalsIgnoreCase("ULINT")
				|| type.equalsIgnoreCase("LWORD")) {
			return (text + "(QString(\"%1\").arg((unsigned long long)" + var + "));");
		} else if (type.equalsIgnoreCase("REAL")
				|| type.equalsIgnoreCase("LREAL")) {
			return (text + "(QString(\"%1\").arg(" + var + ", 0, \'f\'));");
		} else if (type.equalsIgnoreCase("STRING")) {
			return (text + "(QString(" + var + "));");
		} else {
			// User-defined type
			return (text + "(QString(CUSTOM_OUTPUT_FUNCTION(" + var + ")));");
		}
	}

	/**
	 * Create the string for the procedure prototype.
	 * @param fbName name of the function block type 
	 * @param proc procedure to be declared 
	 * @return String containing the prototype for the procedure.
	 */
	protected static String getPrototype(String fbName, Procedure proc) {
		String proto = proc.getPrototype();

		if (proto == null || proto.length() == 0) {
			return ("void " + proc.getFullName() + "(" + fbName + "* me)");
		}
		return proto;
	}

	/**
	 * Prints out the code for each synchronous state.
	 * @param state the state currently being visited 
	 * @param numOfStates total number states for the ECC
	 */
	protected void printState(SyncState state, int numOfStates)
			throws IOException {
		cprinter.print("// State: " + state.getName());
		if (opts.isSimul()) {
			if (statePrefix.length() > 0)
				cprinter.print("mxmlElementSetAttr(me->_" + statePrefix
						+ "simstate, \"Name\", \"" + statePrefix + "."
						+ state.getName() + "\");");
			else
				cprinter.print("mxmlElementSetAttr(me->_simstate, \"Name\", \""
						+ state.getName() + "\");");
		}
		cprinter.print("if (!me->_" + statePrefix + "entered) {");
		cprinter.indent();

		// Print out the action for this state
		printActions(state.actions /*Kyle: , false*/);

		// Set embedded things to entered = false;
		// And reset state #
		if (state.refiningECCName != null) {
			cprinter.print("me->_" + state.refiningECCName + "entered = false;");
			cprinter.print("me->_" + state.refiningECCName + "state = 0;");
		}
		if (state.parallel != null) {
			for (Entry<String, SyncState[]> entry : state.parallel.entrySet()) {
				cprinter.print("me->_" + entry.getKey() + "entered = false;");
				cprinter.print("me->_" + entry.getKey() + "state = 0;");
			}
		}
		cprinter.print("me->_" + statePrefix + "entered = true;");
		if (opts.timeAnnotate && state.parents != null
				&& state.children != null) {
			// Something about GCC being lame (ask Matthew why we need breaks
			// INSIDE the IF)
			if (state.refiningECCName == null) {
				cprinter.print("break;");
			}
		}
		cprinter.unindent();
		cprinter.print("}");

		// Print out the transition conditions
		if (state.conditions != null) {
			cprinter.print("else {");
			cprinter.indent();
			printTransitions(state, numOfStates);
			if (opts.timeAnnotate) {
				// Something about GCC being lame (ask Matthew why we need
				// breaks INSIDE the IF)
				//do this only if not HCECC
				if (state.refiningECCName == null) {
					cprinter.print("break;");
				}
			}
			cprinter.unindent();
			cprinter.print("}");
		}

		// If it has embedded... do something else
		String myPrefix = statePrefix;
		if (state.refiningECCName != null)
		{
			cprinter.print("//Refining ECC: " + state.refiningECCName );
			statePrefix = state.refiningECCName;
			printECC(state.refiningStates);
		}
		
		if (state.parallel != null)
			for (Entry<String, SyncState[]> entry : state.parallel.entrySet()) {
				cprinter.print("//Parallel ECC: " + entry.getKey());
				statePrefix = entry.getKey();

				printECC(entry.getValue());

			}
		statePrefix = myPrefix;
	}

	private void printActions(Action[] actions /*Kyle:, boolean doExitActions*/) throws IOException {
		if (actions != null) {
			for (int i = 0; i < actions.length; i++) {
				/* Kyle:
				// Skip current action if it does not match doExitActions boolean select
				if((!doExitActions && (actions[i].getIsExitAction()))
						|| (doExitActions && !(actions[i].getIsExitAction())))
					continue;
				*/
					
				Procedure procedure = actions[i].getProcedure();
				if (procedure != null) {
					// Gareth Changed:
					// It makes more sense to:
					// if user has provided args... then there will also be a
					// prototype
					// then assume the action call INCLUDES theblock name in the
					// function call

					String args = actions[i].getArguments();
					// StringBuilder line = new StringBuilder();

					if (args != null) {
						// Explicit arguments are provided
						// Name is fully declared by user
						cprinter.print(procedure.getName() + "(" + args + ");");
					}
					else
						cprinter.print(procedure.getFullName() + "(me);");

				}

				Event output = actions[i].getOutput();
				if (output != null)
					cprinter.print("me->_output.event." + output.getName() + " = 1;");
			}
		}
	}

	/**
	 * Creates the test condition from the list of tokens.
	 * @param tokens list of tokens 
	 * @return A string containing the test condition.
	 */
	protected String conditionToString(LinkedList<Token> tokens) {
		StringBuilder guard = new StringBuilder();
		ListIterator<Token> i = tokens.listIterator();
		while (i.hasNext()) {
			Token tok = i.next();
			// GARETH TEMP CUZ I BROKE SUMMING
			if (tok == null)
				continue;
			TokenType type = tok.getType();
			String token = tok.getToken();
			switch (type) {
			case CPARENTHESIS:
				int len = guard.length();
				assert (len > 1) : "Unexpected `)\' in guard condition.\n";
				guard.deleteCharAt(len - 1);
				break;
			case ARITHOP:
				if (token.equalsIgnoreCase("MOD")
						|| token.equalsIgnoreCase("%"))
					token = "%";
				break;
			case LOGICOP:
				if (token.equalsIgnoreCase("NOT") || token.equals("!"))
					token = "!";
				else if (token.equalsIgnoreCase("OR") || token.equals("||"))
					token = "||";
				else if (token.equalsIgnoreCase("AND") || token.equals("&")
						|| token.equals("&&"))
					token = "&&";
				else if (token.equalsIgnoreCase("XOR"))
					token = "^";
				break;
			case COMPARISON:
				if (token.equals("="))
					token = "==";
				else if (token.equals("<>"))
					token = "!=";
				break;
			case EVENT:
				token = "me->_input.event." + token;
				break;
			case IFVAR:
			case INTVAR:
				token = "me->" + token;
				break;
			}
			guard.append(token);
			if (type != TokenType.OPARENTHESIS)
				guard.append(" ");
		}
		if (guard.length() == 0)
			return "ERROR OF SORTS";
		guard.deleteCharAt(guard.length() - 1);
		return guard.toString();
	}

	/**
	 * Pretty prints the ECC transition conditions.
	 * @param state the state currently being visited 
	 * @param numOfStates total number states for the ECC
	 */
	protected void printTransitions(SyncState state, int numOfStates) throws IOException {
		int len = state.conditions.length;
		assert (len == state.children.length) : "Conditions and children length do not match.\n";

		String line = "";
		int i = 0;
		for (;;) {
			if (state.conditions[i].equalsType(ConditionType.IMMEDIATE)) {
				if (i == 0) {
					if (opts.isSimul()) {
						printTransitionForSim(state.getName(),
								state.children[i].getName(), "1");
					}
					if (numOfStates > 1)
						cprinter.print("me->_" + statePrefix + "state = "
								+ state.children[0].index + ";");
					cprinter.print("me->_" + statePrefix + "entered = false;");
					
					/* Kyle:
					// Print out the exit action for this state
					printActions(state.actions, true);
					// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
					if( state.conditions[i].getActions() != null )
					{
						printActions(state.conditions[i].getActions(), false);
					}
					*/
					cprinter.print("continue;");
				}
				else {
					cprinter.print(line + "{");
					cprinter.indent();
					if (opts.isSimul()) {
						printTransitionForSim(state.getName(),
								state.children[i].getName(), "1");
					}
					if (numOfStates > 1)
						cprinter.print("me->_" + statePrefix + "state = "
								+ state.children[i].index + ";");
					cprinter.print("me->_" + statePrefix + "entered = false;");
					
					/* Kyle:
					// Print out the exit action for this state
					printActions(state.actions, true);
					// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
					if( state.conditions[i].getActions() != null )
					{
						printActions(state.conditions[i].getActions(), false);
					}
					*/
					cprinter.print("continue;");
					cprinter.unindent();
					cprinter.print("}");
				}
				break;
			}
			LinkedList<Token> tokens = state.conditions[i].getConditionTokens();
			line += ("if (" + conditionToString(tokens) + ") {");
			cprinter.print(line);
			cprinter.indent();
			if (opts.isSimul()) {
				printTransitionForSim(state.getName(),
						state.children[i].getName(),
						state.conditions[i].getCondition());
			}
			
			
			if (numOfStates > 1)
				cprinter.print("me->_" + statePrefix + "state = "
						+ state.children[i].index + ";");
			cprinter.print("me->_" + statePrefix + "entered = false;");
			/* Kyle:
			// Print out the exit action for this state
			printActions(state.actions, true);
			// Allowance for Actions on transitions to create Mealy / Hybrid ECCs
			if( state.conditions[i].getActions() != null )
			{
				printActions(state.conditions[i].getActions(), false);
			}
			*/
			cprinter.print("continue;");
			cprinter.unindent();
			cprinter.print("}");
			i++;
			if (i >= len)
				break;
			line = "else ";
		}
	}

	/*
	 * Print C code to add status to 'log' for sending to IDE
	 */
	private void printTransitionForSim(String src, String dest, String cond)
			throws IOException {
		if (statePrefix.length() > 0)
			cprinter.println("appendTransitionToXML(me->_simtransitions, \""
					+ statePrefix + "." + src + "\", \"" + statePrefix + "."
					+ dest + "\", \"" + cond + "\");");
		else
			cprinter.println("appendTransitionToXML(me->_simtransitions, \""
					+ src + "\", \"" + dest + "\", \"" + cond + "\");");
	}

	private void printEventOForSim(String signal, boolean withIf)
			throws IOException {
		/*
		 * if( withIf ) {
		 * cprinter.println("if( me->_output.event."+signal+" )");
		 * cprinter.indent(); }
		 * 
		 * cprinter.println("appendEventOutputToXML(me->_simevents, \""+signal+
		 * "\");");
		 * 
		 * if( withIf ) { cprinter.unindent(); }
		 */
	}

	private void printCompositeConnectionsForSim(Block b) throws IOException {
		Instance instance = getInstance(b.getInstance());
		String insName = b.getInstanceName();
		String insType = b.getInstanceType();

		if (b.getOutputEvents() != null) {
			for (Event e : b.getOutputEvents()) {
				Signal sig = new Signal(new PortName(insName, insType,
						e.getName()), PortType.LOCAL);
				HashSet<Signal> bindings = instance.getBindings(sig);
				if (bindings == null)
					continue;
				if (bindings.size() < 1)
					continue;

				cprinter.println("if( me->" + b.getInstanceName()
						+ "._output.event." + e.getName() + "){");
				cprinter.indent();

				// Event connections
				for (Signal binding : bindings) {
					cprinter.println("appendConnectionToXML(me->_simconnections, \""
							+ sig.getFullName()
							+ "\",\""
							+ binding.getFullName() + "\");");
				}

				VarDeclaration[] vars = e.withVar;
				if (vars == null) {
					cprinter.unindent();
					cprinter.println("}");
					continue;
				}

				for (int j = 0; j < vars.length; j++) {
					sig = new Signal(insName, insType, vars[j].getName(),
							vars[j].getType(), vars[j].getArraySize(),
							PortType.LOCAL);
					bindings = instance.getBindings(sig);
					if (bindings == null) {
						// OutputManager.printNotice(insName, "Instance: " +
						// insName + " has no connections to data port: " +
						// sig.getFullName(), OutputLevel.WARNING);
						continue;
					}
					if (bindings.size() < 1)
						continue;

					// Data connection
					for (Signal binding : bindings) {
						cprinter.println("appendConnectionToXML(me->_simconnections, \""
								+ sig.getFullName() + "\", \""
								+ binding.getFullName() + "\");");
					}

				}

				cprinter.unindent();
				cprinter.println("}");

			}
		}
	}

	private void printCompositeConnectionsForSim(Instance instance) throws IOException {
		FunctionBlock b = FunctionBlock.getFunctionBlock(instance,
				instance.getFQName());

		if (b.outputEvents != null) {
			for (Event e : b.outputEvents) {
				Signal sig = new Signal(new PortName(instance.name,
						instance.type, e.getName()), PortType.LOCAL);
				HashSet<Signal> bindings = instance.getBindings(sig);
				if (bindings == null)
					continue;
				if (bindings.size() < 1)
					continue;

				cprinter.println("if( me->" + instance.name + "._output.event."
						+ e.getName() + "){");
				cprinter.indent();

				// Event connections
				for (Signal binding : bindings) {
					cprinter.println("appendConnectionToXML(me->_simconnections, \""
							+ sig.getFullName()
							+ "\",\""
							+ binding.getFullName() + "\");");
				}

				VarDeclaration[] vars = e.withVar;
				if (vars == null) {
					cprinter.unindent();
					cprinter.println("}");
					continue;
				}

				for (int j = 0; j < vars.length; j++) {
					sig = new Signal(instance.name, instance.type,
							vars[j].getName(), vars[j].getType(),
							vars[j].getArraySize(), PortType.LOCAL);
					bindings = instance.getBindings(sig);
					if (bindings == null) {
						// OutputManager.printNotice(insName, "Instance: " +
						// insName + " has no connections to data port: " +
						// sig.getFullName(), OutputLevel.WARNING);
						continue;
					}
					if (bindings.size() < 1)
						continue;

					// Data connection
					for (Signal binding : bindings) {
						cprinter.println("appendConnectionToXML(me->_simconnections, \""
								+ sig.getFullName()
								+ "\", \""
								+ binding.getFullName() + "\");");
					}

				}

				cprinter.unindent();
				cprinter.println("}");

			}
		}
	}
	
	/**
	 * Matches ST data types with C primitive types. If a match is not found, a
	 * user-defined type is assumed.
	 * 
	 * @param IEC 61499 type
	 * @return C equivalent type
	 */
	/*
	public static String getCDataType(String type) {
		if (type.isEmpty())
			return "void";
		else if (type.equalsIgnoreCase("ANY"))
			return "void*";
		else if (type.equalsIgnoreCase("BOOL"))
			return "bool";
		else if (type.equalsIgnoreCase("SINT"))
			return "char";
		else if (type.equalsIgnoreCase("INT"))
			return "short";
		else if (type.equalsIgnoreCase("DINT"))
			return "int";
		else if (type.equalsIgnoreCase("LINT"))
			return "long long";
		else if (type.equalsIgnoreCase("USINT"))
			return "unsigned char";
		else if (type.equalsIgnoreCase("UINT"))
			return "unsigned short";
		else if (type.equalsIgnoreCase("UDINT"))
			return "unsigned int";
		else if (type.equalsIgnoreCase("ULINT"))
			return "unsigned long long";
		else if (type.equalsIgnoreCase("REAL"))
			return "float";
		else if (type.equalsIgnoreCase("LREAL"))
			return "double";
		else if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			return "FBstring";
		// else if (type.equalsIgnoreCase("WSTRING")) return "Wstring";
		else if (type.equalsIgnoreCase("BYTE"))
			return "unsigned char";
		else if (type.equalsIgnoreCase("WORD"))
			return "unsigned short";
		else if (type.equalsIgnoreCase("DWORD"))
			return "unsigned int";
		else if (type.equalsIgnoreCase("LWORD"))
			return "unsigned long long";
		// else if (type.equalsIgnoreCase("DATE_AND_TIME")) return "struct timeval";
		else if (type.equalsIgnoreCase("TIME"))
			return "long long";
		else
			return type;
	}
	*/
	
	/**
	 * Matches ST data types with portable C primitive types. These "portable" 
	 * types need to be defined by the user for a given platform in an 
	 * appropriate header file. This header file should then be included with 
	 * the generated code during compilation. If a match is not found for a 
	 * given ST data type, a user-defined type is assumed.
	 * 
	 * @param IEC 61499 type
	 * @return C equivalent type
	 */
	public static String getPortableCType(String type) {
		if (type.isEmpty())
			return "void";
		else if (type.equalsIgnoreCase("ANY"))
			return "void*";
		/*
		else if (type.equalsIgnoreCase("BOOL"))
			return "bool";
		else if (type.equalsIgnoreCase("SINT"))
			return "sbyte1";
		else if (type.equalsIgnoreCase("INT"))
			return "sbyte2";
		else if (type.equalsIgnoreCase("DINT"))
			return "sbyte4";
		else if (type.equalsIgnoreCase("LINT"))
			return "sbyte8";
		else if (type.equalsIgnoreCase("USINT"))
			return "ubyte1";
		else if (type.equalsIgnoreCase("UINT"))
			return "ubyte2";
		else if (type.equalsIgnoreCase("UDINT"))
			return "ubyte4";
		else if (type.equalsIgnoreCase("ULINT"))
			return "ubyte8";
		else if (type.equalsIgnoreCase("REAL"))
			return "real32";
		else if (type.equalsIgnoreCase("LREAL"))
			return "real64";
		else if (type.equalsIgnoreCase("STRING") || type.equalsIgnoreCase("WSTRING"))
			return "FBstring";
		//else if (type.equalsIgnoreCase("WSTRING")) return "Wstring";
		else if (type.equalsIgnoreCase("BYTE"))
			return "ubyte1";
		else if (type.equalsIgnoreCase("WORD"))
			return "ubyte2";
		else if (type.equalsIgnoreCase("DWORD"))
			return "ubyte4";
		else if (type.equalsIgnoreCase("LWORD"))
			return "ubyte8";
		//else if (type.equalsIgnoreCase("DATE_AND_TIME")) return "struct timeval";
		else if (type.equalsIgnoreCase("TIME"))
			return "sbyte8";
		*/
		else
			return type;
	}
	
	public boolean isUCOSresource() {
		return isUCOStask;
	}
}
