/**
 * Class for generating synchronous multirate code. The generated code currently works
 * only with uC/OS-II.
 * @author lihsien
 */
package ucos;

import ir.*;
import ccode.*;
import fb.*;
import fbtostrl.*;

import java.io.IOException;
import java.util.*;

/**
 * Helper class for representing prioritized resources (for multirate execution)
 * @author lihsien
 */
class PrioritizedResource {
	String name;
	String type;
	int rate;
	int prio;
	FBType[] subBlocks;
	
	PrioritizedResource(String n, String t, FBType[] blocks) {
		name = n;
		type = t;
		subBlocks = blocks;
	}
}

/**
 * Helper class to sort prioritized resources according to their priorities.
 * @author lihsien
 */
class SortedResources {
	private LinkedList<PrioritizedResource> sorted = new LinkedList<PrioritizedResource>();
	private int min;
	private int max;
	
	SortedResources() {}
	
	void add(PrioritizedResource res) {
		if (res.rate <= min) {
			sorted.addFirst(res);
			min = res.rate;
		}
		else if (res.rate >= max) {
			sorted.addLast(res);
			max = res.rate;
			if (min == 0) {
				// This is for the initial case when the first element is added
				min = max;
			}
		}
		else {
			int size = sorted.size();
			for (int i = 1; i < size; i++) {
				if (res.rate > sorted.get(i-1).rate && res.rate <= sorted.get(i).rate) {
					sorted.add(i, res);
					break;
				}
			}
		}
	}
	
	void sort() {
		int size = sorted.size();
		if (size <= 1)
			return;
		
		PrioritizedResource first = sorted.getFirst();
		for (int i = 1; i < size; i++) {
			PrioritizedResource second = sorted.get(i);
			if (first.rate == second.rate){
				if (first.prio > second.prio) {
					sorted.remove(i-1);
					sorted.add(i, first);
				}
			}
			first = second;
		}
	}
	
	final LinkedList<PrioritizedResource> getSortedList() {
		return sorted;
	}
}

public class UCOSGenerator extends CProgGenerator {
	public UCOSGenerator(Device dev, HashSet<Block> comBlocks, OutputPath o) {
		super(dev, comBlocks, o);
	}
	
	/* DESCRIPTION: Generates code for a given device
	 * PARAMETERS: fileName - base name of the output file(s) produced
	 */
	public void generateCode(String fileName) throws IOException {
		CodePrinter printer = new CodePrinter(fileName + ".c");
		printer.print("// This file is generated by FBC.", 1);
		
		if (device.comment != null)
			printer.print("// " + device.comment, 1);
		
		for (int i = 0; i < device.resources.length; i++) {
			printer.print("#include \"" + device.resources[i].resType.getTargetType() + ".h\"");
		}
		printer.print("");
		
		printer.print("int main(void)");
		printer.print("{");
		printer.indent();
		
		SortedResources sortedResources = new SortedResources();
		for (int i = 0; i < device.resources.length; i++) {
			String resType = device.resources[i].resType.getTargetType();
			String res = device.resources[i].name;
			printer.print(resType + " " + res + ";");
			printer.print(resType + "init(&" + res + ");");
			
			Parameter[] params = device.resources[i].params; 
			if (params != null) {
				VarDeclaration[] paramVars = device.resources[i].resType.
						getInterfaceList().inputVars;
				PrioritizedResource resource = new PrioritizedResource(res, resType, 
						device.resources[i].resType.subBlocks); 
				for (int j = 0; j < params.length; j++) {
					if (FBtoStrl.opts.isGNUuCOS()) {
						String name = params[j].name;
						if (name.equals("RATE")) {
							resource.rate = Integer.parseInt(params[j].value);
							sortedResources.add(resource);
							continue;
						}
						else if (name.equals("PRIO")) {
							if (!params[j].value.isEmpty())
								resource.prio = Integer.parseInt(params[j].value);
							continue;
						}
					}
					
					VarType paramVar = setParamValue(paramVars, params[j]);
					if (paramVar == null)
						continue;
					String[] inits = CGenerator.makeInitialization(paramVar, res + ".", 
							(byte)0x02, res);
					for (String init : inits)
						printer.print(init);
				}
			}
		}
		printer.print("");
		
		printer.print("OSInit();");
		sortedResources.sort();
		LinkedList<PrioritizedResource> sorted = sortedResources.getSortedList();
		String firstResource = sorted.getFirst().name;
		int size = sorted.size();
		for (int i = 0; i < size; i++) {
			PrioritizedResource resource = sorted.get(i); 
			String res = resource.name;
			printer.print("OSTaskCreate(" + resource.type + "run, &" + res + ", &" + res + 
					"Stack[" + res + "_STACK_SIZE - 1], " + Integer.toString(i + 1) + ");");
		}
		printer.print("OSStart();", 1);
			
		//Now, print out all deferred resources
		for (Resource res : device.resources) {
			LinkedList<CodeGenerator> cgs = res.resType.getDeferredBlocks();
			CodeGenerator cg = cgs.removeLast();
			if (firstResource.equals(res.name))
				cg.setLateCode("/* ENABLE uC/OS TICKER INTERRUPT HERE *******************************/");
				
			// Get the periods of all multirate messages
			cg.setMsgPeriodMap( getMsgPeriods(sorted) );
				
			cg.generateCode(cg.getFileName(), false, null);
		}
		
		printer.print("return 0;");
		printer.unindent();
		printer.print("}");
		printer.close();
	}
	
	/**
	 * Returns all the multirate messages that are sent/received by "resources," 
	 * together with the period of each message.
	 * This method also does some error checking to ensure that each received
	 * message has one and only one sender.
	 * @param resources the list of all multirate resources in the device
	 * @return All multirate messages that are sent/received by "resources" with 
	 * their respective periods.
	 */
	private static HashMap<String, MsgPeriods> getMsgPeriods(LinkedList<PrioritizedResource> 
			resources) {
		HashMap<String, MsgPeriods> messages = new HashMap<String, MsgPeriods>(resources.size());
		
		for (PrioritizedResource resource : resources) {
			if (resource.subBlocks == null)
				continue;
		
			ArrayList<ComMessage> sendMsgs = new ArrayList<ComMessage>();
			ArrayList<ComMessage> recvMsgs = new ArrayList<ComMessage>();
			for (FBType sub : resource.subBlocks)
				retrieveMessages(sub, sendMsgs, recvMsgs, "SENDuCOS_", "RECVuCOS_");
		
			for (ComMessage msg : sendMsgs) {
				String varName = msg.getMessage();
				if ( messages.containsKey(varName) ) {
					MsgPeriods periods = messages.get(varName);
					if (periods.getSendPeriod() == 0)
						periods.setSendPeriod(resource.rate);
					else {
						OutputManager.printError(resource.name, 
							"SEND block with parameter `" + varName + "\' already instantiated", 
							OutputLevel.FATAL);
						System.exit(0);
					}
				}
				else
					messages.put(varName, new MsgPeriods(resource.rate, 0));
			}
			for (ComMessage msg : recvMsgs) {
				String varName = msg.getMessage();
				if ( messages.containsKey(varName) ) {
					MsgPeriods periods = messages.get(varName);
					if (periods.getRecvPeriod() == 0)
						periods.setRecvPeriod(resource.rate);
					else {
						OutputManager.printError(resource.name, 
							"RECV block with parameter `" + varName + "\' already instantiated", 
							OutputLevel.FATAL);
						System.exit(0);
					}
				}
				else
					messages.put(varName, new MsgPeriods(0, resource.rate));
			}
		}
		
		return messages;
	}
	
	/**
	 * Generates .h and .c files containing all the global variables used in a program.
	 * @param outputPath path to place the generated file
	 * @param srcDependencies set of additional source dependencies that need to 
	 *        be considered for makefile generation
	 * @param globalVars list of all global variables to be generated
	 * @param devName device name
	 * @throws IOException
	 */
	protected void createGlobalVarsFile(String outputPath, HashSet<String> srcDependencies, 
			HashMap<String, GlobalVar> globalVars, String devName) throws IOException {
		Set<String> varNames = globalVars.keySet();
		if (varNames.isEmpty())
			return;
		
		String file = getGlobalVarsFileName(devName);
		String path = outputPath + file;
		CodePrinter hprint = new CodePrinter(path + "h");
		hprint.print("// This file is generated by FBC.", 1);
		String macroHeader = CodeGenerator.makeHeaderMacro(file + "h");
		hprint.print("#ifndef " + macroHeader);
		hprint.print("#define " + macroHeader, 1);
		hprint.print("#include \"fbtypes.h\"");
		hprint.println();
		hprint.print("/* BEGIN APPLICATION SPECIFIC CONSTANTS ***************************************/");
		hprint.print("enum {_BASE_PERIOD = 10}; // base period of multirate system--customize as needed");
		hprint.print("/* END APPLICATION SPECIFIC CONSTANTS *****************************************/", 1);
		
		CodePrinter cprint = new CodePrinter(path + "c");
		srcDependencies.add(file + "c");
		cprint.print("// This file is generated by FBC.", 1);
		cprint.print("#include \"" + file + "h\"");
		cprint.print("#include \"fbtypes.h\"", 1);
		
		for (String varName : varNames) {
			GlobalVar global = globalVars.get(varName);
			if (!global.isDirectAccess()) {
				hprint.print("enum {_PRESENT = 1, _NEW = 2, _ABSENTNEW = 2, _PRESENTNEW = 3};", 1);
				break;
			}
		}
		
		for (String varName : varNames) {
			GlobalVar global = globalVars.get(varName);
			printMethodAccessGlobalVars(global, hprint, cprint, varName, devName);				
		}
		
		hprint.println();
		hprint.print("#endif // " + macroHeader);		
		hprint.close();
		cprint.close();
	}
	
	/**
	 * Prints global variables that are accessed using wrapper functions.
	 * @param global information about the global variables
	 * @param hprint code printer for the .h file
	 * @param cprint code printer for the .c file
	 * @param varName name of the global variable
	 * @param devName device name
	 * @throws IOException
	 */
	private static void printMethodAccessGlobalVars(GlobalVar global, CodePrinter hprint, 
			CodePrinter cprint, String varName, String devName) throws IOException {
		VarDeclaration status = global.getStatus();
		String array = CodeGenerator.getArrayIndex(status.getArraySize(), "", 
				status.getName()) + ";";
		String bufType = "struct B" + varName;
		
		if (hprint != null) {
			hprint.print("typedef struct {");
			hprint.indent();
			hprint.print(status.getType() + " " + status.getName() + array);
			hprint.print(bufType + " {");
			hprint.indent();
			VarDeclaration[] vars = global.getMembers(devName);
			for (VarDeclaration var : vars) {
				array = CodeGenerator.getArrayIndex(var.getArraySize(), "", var.getName()) + ";";
				hprint.print(var.getType() + " " + var.getName() + array);
			}
			hprint.unindent();
			hprint.print("} buffer;");
			hprint.unindent();
			hprint.print("} " + global.getTypeName() + ";");
		}
		String write = makePrototype(global.getWriteMethod());
		String writeNull = makePrototype(global.getWriteNullMethod()); 
		String read = makePrototype(global.getReadMethod());
		if (hprint != null) {
			hprint.print(write + ";");
			hprint.print(writeNull + ";");
			hprint.print(read + ";");
			hprint.println();
		}
	
		if (cprint != null) {
			String msgID = global.getRawTypeName();
			MsgPeriods periods = CodeGenerator.msgPeriodMap.get(msgID);
			boolean fast2slow = periods.getSendPeriod() <= periods.getRecvPeriod();
			String statusVar = varName + "." + status.getName();
			cprint.print("static " + global.getTypeName() + " " + varName + ";");
			cprint.print(write);
			cprint.print("{");
			cprint.indent();
			if (fast2slow)
				cprint.smartPrint("if (sample == 0 || !(" + statusVar + " & _NEW)) {");
			cprint.print(varName + ".buffer = *( (" + bufType + "*)msg );");
			cprint.print(statusVar + " = _PRESENTNEW;");
			if (fast2slow)
				cprint.smartPrint("}");
			cprint.unindent();
			cprint.print("}");
		
			cprint.print(writeNull);
			cprint.print("{");
			cprint.indent();
			if (fast2slow) {
				cprint.print("if (sample == 0 || !(" + statusVar + " & _NEW))");
				cprint.indent();
			}
			cprint.print(statusVar + " = _ABSENTNEW;");
			if (fast2slow)
				cprint.unindent();
			cprint.unindent();
			cprint.print("}");
		
			cprint.print(read);
			cprint.print("{");
			cprint.indent();
			cprint.smartPrint("if (" + statusVar + " & _NEW) {");
			cprint.print("if (" + statusVar + " == _PRESENTNEW)");
			cprint.indent();
			cprint.print("*( (" + bufType + "*)buf ) = " + varName + ".buffer;");
			cprint.unindent();
			cprint.print(statusVar + " &= ~_NEW;");
			cprint.smartPrint("}");
			cprint.print("return (" + statusVar + " & _PRESENT);");
			cprint.unindent();
			cprint.print("}");
			cprint.println();
		}
	}
	
	/**
	 * Makes the prototype for a given function.
	 * @param proto prototype of a function
	 * @throws IOException
	 * @return C-style function prototype
	 */
	private static String makePrototype(Prototype proto) {
		VarDeclaration[] vars = proto.getArguments();
		StringBuilder prototype = new StringBuilder(CGenerator.getPortableCType(proto.getType()) +
				" " +  proto.getName() + "(");
		if (vars[0] == null)
			prototype.append("void");
		else {
			int i = 0;
			for (;;) {
				prototype.append(CGenerator.getPortableCType(vars[i].getType()) + " " + 
						vars[i].getName());
				i++;
				if (i >= vars.length)
					break;
				prototype.append(", ");
			}	
		}
		prototype.append(")");
		return prototype.toString();
	}
}
