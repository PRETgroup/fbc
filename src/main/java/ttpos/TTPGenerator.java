/**
 * Class for generating TTP-OS-related code.
 * @author lihsien
 */
package ttpos;

import ir.*;
import fb.Device;
import fbtostrl.OutputPath;
import ccode.*;
import java.io.IOException;
import java.util.*;

public class TTPGenerator extends CProgGenerator {
	public TTPGenerator(Device dev, HashSet<Block> comBlocks, OutputPath o) {
		super(dev, comBlocks, o);
	}
	
	/**
	 * Prints the main file if generating code for TTP-OS
	 * @param printer pretty printer
	 * @throws IOException
	 */
	private void makeTTPOSmain(CodePrinter printer) throws IOException {
		printer.print("#include <string.h>");
		printer.print("#include \"TTPos.h\"");
		printer.print("#include \"TTPCftl.h\"");
		printer.print("#include \"ttpc_msg.h\"");
		printer.print("#include \"hal.h\"", 1);
		
		printer.print("/* Reboot is defined in the board-support-package */");
		printer.print("void init (void);");
		printer.print("ubyte4 lStackStart [128];");
		printer.print("const ubyte4 lStack = (ubyte4) &lStackStart [127];");
		printer.print("ubyte4 user_stack_array [400];");
		printer.print("const ubyte4 user_stack = (ubyte4) &user_stack_array [399];");
		printer.print("extern char __DATA_ROM [];");
		printer.print("extern char __DATA_RAM [];");
		printer.print("extern char __DATA_END [];", 1);
		
		printer.print("#define APP_MODE am // CUSTOMIZE AS NEEDED");
		printer.print("tt_declare_app_mode(APP_MODE);", 1);
		
		for (int i = 0; i < device.resources.length; i++)
			printer.print(device.resources[i].resType.getTargetType() + " " + device.resources[i].name + ";");
		printer.println();
		
		printer.print("// Init function: CUSTOMIZE AS NEEDED");
		printer.print("void init(void)");
		printer.smartPrint("{");
		printer.smartPrint("}", 1);

		printer.print("// The main function is the first function called after the execution of the"); 
		printer.print("// initialization of board-support-package");
		printer.print("void main(void)");
		printer.smartPrint("{");
		for (int i = 0; i < device.resources.length; i++)
			printer.print(device.resources[i].resType.getTargetType() + "init(&" + device.resources[i].name + ");");
		printer.println();
		printer.print("// Start the operating system with a certain application mode");
		printer.print("tt_start_OS (&am);");
		printer.smartPrint("}", 1);
		
		printer.print("void initcopy(void)");
		printer.print("{");
		printer.indent();
		printer.print("// Move initialized data from ROM to RAM if defined at different locations");
		printer.print("if (__DATA_ROM != __DATA_RAM) {");
		printer.indent();
		printer.print("memcpy(__DATA_RAM,__DATA_ROM,__DATA_END-__DATA_RAM);");
		printer.unindent();
		printer.print("}");
		printer.unindent();
		printer.print("}", 1);
		
		printer.print("// tt_startup_hook is called before the actual tasks are executed");
		printer.print("void tt_startup_hook(void)");
		printer.print("{");
		printer.indent();
		printer.print("init(); // first, initialize the application");
		printer.print("tt_start_TTP(); // then, start TTP/C");
		printer.unindent();
		printer.print("}", 1);
		
		printer.print("#define RESTART_REASONS CNIPROTSM_AE | CNIPROTSM_SE | CNIPROTSM_CB |  CNIPROTSM_MV");
		printer.print("void tt_background_hook(void)");
		printer.print("{");
		printer.indent();
		printer.print("// Check if the controller is still working");
		printer.print("if (!TTPC_CONTROLLER_ON() || (TTPC_PROTOCOL_ERROR() & (RESTART_REASONS))) {");
		printer.indent();
		printer.print("tt_hal_set_mode(KERNEL);");
		printer.print("TTPC_SET_CONTROLLER_OFF();");
		printer.print("// tt_hal_reset jumps into the ROM --");
		printer.print("// RAM debugging is not possible after that function call");
		printer.print("tt_hal_reset ();");
		printer.unindent();
		printer.print("}");
		printer.unindent();
		printer.print("}", 1);
		  
		printer.print("void tt_error_hook(tt_Status error, tt_Type_ID task_id)");
		printer.smartPrint("{");
		printer.smartPrint("if ((error == TT_E_DEADLINE_VIOLATION) && (error == error) && (task_id == task_id)) {");
		printer.smartPrint("// Set breakpoint here or output task_id over serial link to detect"); 
		printer.smartPrint("// violating task");
		printer.smartPrint("}");
		printer.smartPrint("tt_hal_set_mode(KERNEL);");
		printer.smartPrint("TTPC_SET_CONTROLLER_OFF();", 1);
		printer.smartPrint("// tt_restart jumps into the ROM --");
		printer.smartPrint("// RAM debugging is not possible after that function call");
		printer.smartPrint("tt_hal_reset();");
		printer.smartPrint("}", 1);
	}
	
	/* DESCRIPTION: Generates code for a given device
	 * PARAMETERS: fileName - base name of the output file(s) produced
	 */
	public void generateCode(String fileName) throws IOException {
		CodePrinter printer = new CodePrinter(fileName + ".c");
		printer.print("// This file is generated by FBC.", 1);
		
		if (device.comment != null)
			printer.print("// " + device.comment, 1);
		
		for (int i = 0; i < device.resources.length; i++) {
			printer.print("#include \"" + device.resources[i].resType.getTargetType() + ".h\"");
		}
		printer.print("");
		
		makeTTPOSmain(printer);
		printer.close();
	}
}
